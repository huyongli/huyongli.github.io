{"pages":[{"title":"关于我","text":"介绍我是老胡，工作在武汉的应城人。 闷而不骚的Android码农一枚，爱编程爱足球。 githubhttps://github.com/huyongli 微博老胡-Tiger 联系方式个人微信，欢迎添加交流，添加时请备注：博客","link":"/about/index.html"},{"title":"分类","text":"原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/categories/index.html"},{"title":"标签","text":"原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/tags/index.html"}],"posts":[{"title":"AndroidStudio使用技巧","text":"AndroidStudio使用技巧本文主要是记录从我使用AndroidStudio以来遇到的一些问题和一些技巧。 初次使用AndroidStudio，第一次创建Android工程编译时会比较慢，这中间涉及到三个过程： 可能会去下载最新的SDK，所以在创建工程之前可以先将SDK更新完成 AndroidStudio工程会使用gradle构建，因此会联网下载gradle，这个过程比较慢要耐心等待 下载工程中的一些依赖包，比如junit 有时候使用AndroidStudio进行rebuild和clean时，会报错如下：Failed to complete gradle execution cause by...，一般此错误可以通过设置gradle的VM参数解决： -Xmx256m(设置方式为：File &gt; Setting &gt; Gradle &gt; Gradle Vm Option)，如果此方法无效，可以选择直接升级AS的版本到最新版本再试，还有其他可能的原因是工程JDK版本与AS设置的JDK版本不同 设置AndroidStudio的不同主题背景： File &gt; Setting &gt; Appearance&amp;Behavior &gt; Appearance 下的Theme可以选择你要使用的主题 设置编辑区的字体和字体大小:File &gt; Setting &gt; Editor &gt; Color&amp;Fonts &gt; Font,在右边需要先将主题另存之后，再去编辑字体和大小 自定义AS的Logcat里不同级别的日志文字的颜色:File &gt; Setting &gt; Editor &gt; Color&amp;Fonts &gt; Android Logcat,同样需要先另存当前主题之后才能自定义给个级别的日志文字颜色 鼠标移动到某个变量和类上面显示提示信息的设置：File &gt; Setting &gt; Editor &gt; 点击下面的General,在右边选中Show quick doc on mouse move Delay 设置代码行号一直显示而不是重启后又不显示了：File &gt; Setting &gt; Editor &gt; General &gt; Appearance,在右边选中Show Line numbers 快速按Shift键两次，调出文件全局搜索对话框(根据文件名搜索)，可以搜索Java文件和资源文件 Ctrl+H 全局文本搜索快捷键，可以搜索全部文本内容，包括资源文件 Ctrl+T：打开某个方法的实现类，打开某个id的资源文件 工程中设置使用本地安装的gradle进行构建，而不是联网下载gradle最新版本： 打开android-studio/plugins/android/lib/templates/gradle/wrapper/gradle/wrapper/gradle-wrapper.properties，修改distributionUrl=file\\:/home/zzq/.gradle/distribution/gradle-2.2.1-all.zip AndroidStudio启动时默认直接就打开了上次打开的工程，没有像第一次启动那样可以选择，此问题可以这样解决：File &gt; Setting &gt; Appearance &amp; Behavior &gt; System Settings下将Reopen last project on startup的选择取消掉，设置为非选中状态即可 支持驼峰命令选择File &gt; Setting &gt; Editor &gt; General &gt; Smart Keys，在右边选择Use &quot;CamelHumps&quot; words，此时如果仍然希望当鼠标在单词上双击之后选中整个单词，需要如下设置：File &gt; Setting &gt; Editor &gt; General，在右边取消选中 Honor &quot;CamelHumps&quot; words settings when selecting on double click 给代码的变量名添加前缀，如非静态成员变量以’m’开头，请如下设置：File &gt; Setting &gt; Editor &gt; Code Style &gt; Java，在右边选择Code Generation，然后给要配置的相关字的添加前缀 File &gt; Setting &gt; Appearance&amp;Behavior &gt;SystemSetting &gt; HttpProxy下设置代理不起作用时，可以在工程目录下的gradle.properties文件中添加代理设置即可： systemProp.http.proxyHost=ip地址 systemProp.http.proxyPort=端口 systemProp.https.proxyHost=ip地址 systemProp.https.proxyPort=端口 AS创建Module时，在资源目录res下只生成了mipmap等资源文件夹，此文件夹主要是用来存放应用启动图标的，其他的图片资源文件还是应该放在drawable等文件夹中。为了在创建Module时同时也生成对应的drawable文件夹，只需要做如下配置： 进入Android Studio的安装目录 依次进入plugins/android/lib/templates/gradle-projects/NewAndroidModule 用边界器打开recipe.xml.ftl文件，在&lt;mkdir at=&quot;${escapeXmlAttribute(resOut)}/drawable&quot; /&gt;下方依次加入下面三行配置： mkdir at=&quot;${escapeXmlAttribute(resOut)}/drawable-hdpi&quot; mkdir at=&quot;${escapeXmlAttribute(resOut)}/drawable-xhdpi&quot; mkdir at=&quot;${escapeXmlAttribute(resOut)}/drawable-xxhdpi&quot; 通过类似的方式还可以在colors.xml文件中生成常用颜色 在build.gralde中生成自定义配置 在.gitignore文件中生成自定义忽略文件配置 配置代码模板， Android Studio中提供了很多方便的活动模板(Live Templates)，例如：输入sout后按enter键，Android Studio会自动帮我们写入System.out.println();其实sout就是AS自带的一个活动模板： 先打开：File &gt; Setting &gt; Editor &gt; Live Templates 点击最右侧的加号并选择Template Group 在弹出的对话框中输入一个活动模板分组的名称，如:custom 在左侧选中上一步创建的custom分组，点击右边的加号 选择Live Template，在Abbreviation中对输入模板简写方式，如：sout 在Description中输入这个活动模板的描述 在Template Text中输入模板代码，如：System.out.println(); 点击下方的Define按钮，选中Java表示这个模板用于Java代码 点击右侧的Edit variables 选择Expression下拉框中的className并勾选Skip if... 这个操作的作用是AS会自动将我们在上一步中用'$'符包裹的className自动替换为当前类不含包含的类名 点击Apply和ok让设置生效 至此，我们自定义的custom模板组中的psh活动模板就自定义完成 Android Studio添加本地jar包依赖，在Module的build.gradle文件中进行如下方式配置 compile files('libs/TigerDB.jar')添加某个单一jar包的依赖 compile fileTree(dir: 'libs',include: ['*.jar']) 将libs目录下的jar包全部添加为依赖 持续更新… 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/AndroidStudio使用技巧.html"},{"title":"Android中OkHttp的使用","text":"前段时间研究了下Android里面非常火爆的网络请求库OkHttp，这篇文章主要来介绍下OkHttp的常用请求的使用方式，后面一篇文章会介绍本人基于OkHttp封装的一个操作更简单、更适用于项目的网络请求库TigerOkHttp，其源码及Demo地址为：https://github.com/huyongli/TigerOkHttp 一、说明对于OkHttp的基本介绍，以及为什么要使用OkHttp而不再使用HttpURLConnection或者是HttpClient，各位自己找度娘去，我这里就不再废话了。 使用OkHttp之前，需要先下载OkHttp.jar包，大家可以在https://github.com/square/okhttp去下载OkHttp的最新jar包以及源码， 同时因为OkHttp内部依赖okio，所以大家还要自行下载okio.jar包，下载地址在这里https://github.com/square/okio 二、使用教程1.Get请求123456789101112131415161718192021222324//创建OkHttpClient对象，用于稍后发起请求OkHttpClient client = new OkHttpClient();//根据请求URL创建一个Request对象Request request = new Request.Builder().url(\"https://github.com/huyongli/TigerOkHttp\").build(); //根据Request对象发起Get同步Http请求Response response = client.newCall(request).execute(); //根据Request对象发起Get异步Http请求，并添加请求回调client.newCall(request).enqueue(new Callback() { @Override public void onResponse(final Response response) throws IOException { //请求成功，此处对请求结果进行处理 //String result = response.body().string(); //InputStream is = response.body().byteStream(); //byte[] bytes = response.body().bytes(); } @Override public void onFailure(Request request, IOException e) { //请求失败 }}); 上面的代码示例演示了OkHttp中一个普通的Http get请求是如何实现的，对于上面的代码，作一下简单的说明 既然是get请求，当然得先构造好你要请求的URL 有了请求URL，紧接着就是需要通过这个URL构造一个请求对象Request 当然有时候可能你需要对这个Http请求添加一些自定义的请求头信息header，这时你在构造Request对象之前通过Request.Builder builder = new Request.Builder()创建的builder 对象来添加自己需要添加的请求头信息builder.addHeader(key, value) OkHttp是自带请求缓存控制策略的，如果你想改变某个请求的缓存控制策略，你也可以通过builder对象来修改缓存策略builder.cacheControl() 通过上述步骤构造好请求对象Request之后，通过OkHttpClient创建一个Call任务对象，这个对象有execute()和cancel()等方法对Call任务对象进行执行和取消 如果是同步阻塞请求的话，直接执行Call对象的execute()方法即可得到请求结果。 如果是异步请求的话，就需要执行Call对象的enqueue(new Callback(){})方法，将任务对象添加到任务请求调度队列中，同时添加请求回调接口。 请求成功之后，可以得到一个Response对象，如果想获得返回的字符串结果则可以通过response.body().string()，如果想获得返回结果的二进制数据的话可以通过response.body().bytes()，如果想获得返回的InputStream的话可以通过response.body().byteStream() 通过上面我们可以发现在Response对象中我们可以获取InputStream对象，所以从此处我们可以看出在异步请求onResponse(Response response)回调方法中我们可以通过IO方式来进行写文件，所以在此回调中我们可以进行大文件的下载处理，同时也说明此回调并不是在UI线程中执行的，所以此处如果要进行UI操作的话各位需要自行处理下。 2.Post请求上面对OkHttp的Get请求分析完之后，OkHttp的整个请求流程和处理流程就清晰，Post请求和Get请求的流程都是一样，区别只是在于Request对象构造上有区别。123456789//创建OkHttpClient对象OkHttpClient client = new OkHttpClient();//通过FormEncodingBuilder对象添加多个请求参数键值对FormEncodingBuilder builder = new FormEncodingBuilder();builder.add(\"method\", \"post\").add(\"param\", value);//通过FormEncodingBuilder对象构造Post请求体RequestBody body = builder.build();//通过请求地址和请求体构造Post请求对象RequestRequest request = new Request.Builder().url(url).post(body).build(); 上面的代码演示了如何构造普通Post请求(不包含文件上传)的请求体和请求对象，请求对象构造成功之后，后面的请求过程和处理流程就和Get请求是一样的了。 3.文件上传12345678910111213//多个图片文件列表 List&lt;File&gt; list = new ArrayList&lt;File&gt;();//多文件表单上传构造器MultipartBuilder multipartBuilder = new MultipartBuilder().type(MultipartBuilder.FORM);//添加一个文本表单参数multipartBuilder.addFormDataPart(\"method\", \"upload上传\");for(File file : list) { if(file.exists()) { multipartBuilder.addFormDataPart(file.getName(), file.getName(), RequestBody.create(MediaType.parse(\"image/png\"), file)); }}//构造文件上传时的请求对象RequestRequest request = new Request.Builder().url(url).post(multipartBuilder.build()).build(); 文件上传时的重点是通过MultipartBuilder构造器添加要上传的文件和表单参数，OkHttp中文件上传时，没有可以直接实现上传进度显示的接口，这个需要手动对OkHttp中的请求体进行扩展，这篇文章中就不写了，在下篇文章介绍TigerOkHttp时我会进行介绍。 4.文件下载文件下载功能在第一点Get请求的几点说明中已经介绍过了，无论你是通过Get请求还是Post请求，只需要从请求结果对象Response中获取到结果输入流InputStream，然后通过IO操作进行写文件即可实现文件下载功能。在通过IO操作写文件时，也可以自行实现下载进度显示的功能。 5.编码问题在OkHttp中，无论是Get请求还是Post请求所有参数的编码方式都是默认采用UTF-8的编码方式进行编码。 所以在进行Get请求或Post请求时，文本参数都不需要我们进行手动编码，但是在服务端进行参数解析时，需要做简单的处理，这里我只说明tomcat下运行的Java后台服务的处理方式： 针对Get请求，我们只需要在tomcat的server.xml文件中设置默认编码方式(URIEncoding=”UTF-8″ )为UTF-8即可，注意此编码设置只对Get请求有效。 针对Post请求，我们在解析获取参数值之前需要手动设置请求的编码方式为UTF-8，如：req.setCharacterEncoding(“UTF-8”); OkHttp封装框架–TigerOkHttp以上就是OkHttp最基本的用法，下篇文章我会介绍我自己基于OkHttp更进一步封装的网络请求库TigerOkHttp，它主要包含了如下功能特点： 一般的get同步阻塞请求和异步请求 一般的post同步阻塞请求和异步请求 实现了文件上传功能（包含文件上传进度回调显示） 实现了大文件下载功能，只需要指定文件下载路径即可，也包含了下载进度的回调显示 实现了请求结果的自动解析，用户也可以根据需求扩展自定义结果解析类 对所有请求都支持直接将结果解析转换为JavaBean对象或集合 支持对返回结果结构的自定义，例如设置返回结果结构为：{flag：1|0，error：错误信息，result：请求结果}，结果解析的时候会按照此结构进行结果解析 支持取消某个请求 write by laohu 2016-1-5 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Android中OkHttp的使用.html"},{"title":"Android基础之TableLayout中TextView文本无法自动换行","text":"最近项目中用到了TableLayout布局，发现该布局下的TextView控件的内容无法达到自动换行的效果，布局代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:background=\"@drawable/sys_shade_bg_color\" android:orientation=\"vertical\" android:paddingLeft=\"@dimen/gap_20\" android:paddingTop=\"@dimen/gap_30\" android:paddingRight=\"@dimen/gap_20\"&gt; &lt;TableLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"40dp\"&gt; &lt;TableRow android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:paddingBottom=\"10dp\" &gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"right\" android:text=\"@string/about_company_address\" android:textColor=\"@color/white\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:singleLine=\"false\" android:text=\"公司地址1公司地址2公司地址3公司地址4公司地址5公司地址6\" android:textColor=\"@color/white\" /&gt; &lt;/TableRow&gt; &lt;TableRow android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:paddingBottom=\"@dimen/gap_10\" &gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"right\" android:text=\"@string/about_company_phone\" android:textColor=\"@color/white\" /&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"XXX-XXXXXXX\" android:textColor=\"@color/white\" /&gt; &lt;/TableRow&gt; &lt;/TableLayout&gt;&lt;/LinearLayout&gt; 这样布局后，理所当然的认为没问题，毕竟我的TextView中添加了singline属性为false，结果发现效果不是我 想要的 查看布局效果，发现跟我预期的不一样，公司地址的文本虽然换行了，但是有部分字被隐藏了没有显示出来，而且可以明显的看到展示公司地址文本的TextView的宽度已经超出了屏幕，很显然这就是导致部分文字没显示出来的原因。 既然子布局TextView的宽度超出了TableLayout的宽度，那就想办法让子布局的宽度根据容器的宽度进行收缩，而TableLayout刚好有个属性shrinkColumns可以设置其子布局的宽度收缩以适应容器的大小。 我设置TableLayout的属性android:shrinkColumns=”1″后，立马就达到了我想要的效果。 另外TableLayout还有个属性stretchColumns是用来设置子布局的宽度进行拉伸适应容器大小的 这两个属性的具体用法，大家自行去补脑吧。 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Android基础之TableLayout中TextView文本无法自动换行.html"},{"title":"Android基础之shape使用","text":"Android中的shape标签用于描述形状，可以在布局文件layout和选择器selector中使用，它有6个子标签，具体如下： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;!-- 设置圆角效果 --&gt; &lt;corners android:radius=\"5dp\"/&gt; &lt;!-- 设置背景渐变色 --&gt; &lt;gradient android:startColor=\"@color/red\" android:endColor=\"@color/black\" android:centerColor=\"@color/white\" android:angle=\"-90\" android:gradientRadius=\"90\"/&gt; &lt;!-- 边距间隔 --&gt; &lt;padding android:left=\"10dp\" android:top=\"10dp\" android:right=\"10dp\" android:bottom=\"10dp\"/&gt; &lt;!-- 大小 --&gt; &lt;size android:width=\"20dp\" android:height=\"20dp\"/&gt; &lt;!-- 背景填充色 --&gt; &lt;solid android:color=\"@color/red\"/&gt; &lt;!--边框线 --&gt; &lt;stroke android:color=\"@color/black\" android:width=\"2dp\"/&gt;&lt;/shape&gt; shape：根节点 有一个shape属性，可以设置不同的形状 android:shape=&quot;line&quot;：设置shape为线形（包括实线、虚线） android:shape=&quot;rectangle&quot;：设置shape为矩形 android:shape=&quot;oval&quot;：设置shape为椭圆形 android:shape=&quot;ring&quot;：设置shape为环形 corners子节点：设置圆角效果 android:radius：圆角的半径 gradient子节点：背景渐变色 android:startColor：渐变起始色 android:endColor：渐变结束色 android:centerColor:渐变过程中中间的颜色 android:angle:渐变的角度朝向(45的倍数)，默认朝向为从左至右，每增加45度，则逆时针转动45度开始渐变 android:gradientRadius:这个属性还不知道是什么意思 padding子节点：边距，该标签的几个属性就比较常用比较简单了，就不描述了 size子节点：大小，这个标签的属性也比较简单 solid子节点：背景填充色 android:color:背景颜色，设置该标签属性之后，gradient标签将不会起作用 stroke子节点：线（可以设置控件的边框，也可以设置一条实线或虚线） android:color：线的颜色 android:width：线的宽度 android:dashGap：虚线间的间距 android:dashWidth：每个虚线段的长度（当设置为虚线的时候，最好不要设置android:width属性） 一般比较常用的是边线，填充色，背景色这三个标签 如果要为某个控件设置背景边框、渐变色、填充色或者是通过View设置控件间的分割线，都可以使用shape配合selector来进行实现 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Android基础之shape使用.html"},{"title":"Android基础之点击两次返回键退出程序","text":"Android应用中退出应用程序通常有两种做法，一种是使用选择对话框询问用户是否退出应用程序，另外一种是快速点击返回按钮两次然后退出应用。其中第二种实现方式较为普遍，而且我个人认为这种方式用户体验性要好点。下面，我介绍两种常用的点击两次返回退出应用的实现方式。 通过标识变量进行控制。首先定义一个布尔变量，赋初始值false。然后监听手机返回按钮，当点击返回按钮时，如果该布尔变量值为false，则把这个变量置为true；如果该变量为true，则退出程序。最后定义一个时间任务，2秒执行一次，如果布尔变量为true，则重置为false。这里定义一个循环周期为2秒的任务是为了达到快速点击两次的效果。这样，在第一次点击返回按钮时，仅仅改变布尔值变量，而不会退出，第二次点击才会退出。如果用户点击了一次，那么2秒之后布尔变量又被重置为false，只有2秒内的两次点击才会退出程序。代码如下： 123456789101112131415161718192021private static Boolean isQuit = false;private Timer timer = new Timer();@Overridepublic void onBackPressed() { if (isQuit == false) { isQuit = true; Toast.makeText(getBaseContext(), \"再按一次返回键退出程序\", Toast.LENGTH_SHORT).show(); TimerTask task = null; task = new TimerTask() { @Override public void run() { isQuit = false; } }; timer.schedule(task, 2000); } else { finish(); System.exit(0); android.os.Process.killProcess(android.os.Process.myPid()); }} 通过两次点击返回按钮时的时间间隔进行判断。这种实现方式主要是用第二次点击返回按钮时的时间减去第一次点击的返回按钮时的时间，看这个时间差是否大于2秒，如果大于2秒则提示需要再点击一次才能退出，如果时间差小于等于2秒，则退出应用，实现代码如下： 123456789101112private long exitTime = 0;@Overridepublic void onBackPressed() { if(System.currentTimeMillis() - exitTime &gt; 2000) { Toast.makeText(this, \"再按一次退出程序\", Toast.LENGTH_SHORT).show(); exitTime = System.currentTimeMillis(); } else { finish(); System.exit(0); android.os.Process.killProcess(android.os.Process.myPid()); }} 我个人认为第二种实现方式更简单，更好理解，推荐使用这种实现方式。 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Android基础之点击两次返回键退出程序.html"},{"title":"Android基础之解压zip中文乱码处理","text":"####乱码原因分析一般我们使用的Windows系统外部文件默认都是GBK编码方式，Mac系统默认的好像是UTF-8(同事的电脑就是，不知道其他人的是不是)，Linux的没验证过，这里我讨论的是Windows下打包的zip文件。 Java中自带的ZipEntry解压缩的编码方式是UTF-8，而且没有可以自定义编码方式的接口，所以当我们使用UTF-8编码去解压缩GBK编码的文件的时，解压缩出来的中文部分当然是乱码，所以Mac上打包的zip用Java的自带解压缩接口解压出来是没有问题的。 ####解决方式找到了问题所在，解决方式也就比较简单了，既然是编码方式不同导致的，那我们保证编码方式统一即可，压缩zip时系统编码很难改变，那我们就从解压缩的编码方式入手，自定义解压缩的编码。 Apache中是有完整的替代解决方式的，但是Apache的包相对于Android说有点偏大不适合于Android环境，我们只需要找到解压缩的那部分代码进行改造即可，我这里找到了一个改造好的解压缩替代包，测试可行。示例代码如下：1234567891011121314151617181920212223242526272829303132333435363738import com.file.zip.ZipEntry;import com.file.zip.ZipFile;/** * @param file 待解压文件 * @param dir 解压后文件的存放目录 * @throws IOException */public void unzip(File file, String dir) throws IOException { ZipFile zipFile = new ZipFile(file, \"GBK\");//设置压缩文件的编码方式为GBK Enumeration&lt;ZipEntry&gt; entris = zipFile.getEntries(); ZipEntry zipEntry = null; File tmpFile = null; BufferedOutputStream bos = null; InputStream is = null; byte[] buf = new byte[1024]; int len = 0; while (entris.hasMoreElements()) { zipEntry = entris.nextElement(); // 不进行文件夹的处理,些为特殊处理 tmpFile = new File(dir + zipEntry.getName()); if (zipEntry.isDirectory()) {//当前文件为目录 if (!tmpFile.exists()) { tmpFile.mkdir(); } } else { if (!tmpFile.exists()) { tmpFile.createNewFile(); } is = zipFile.getInputStream(zipEntry); bos = new BufferedOutputStream(new FileOutputStream(tmpFile)); while ((len = is.read(buf)) &gt; 0) { bos.write(buf, 0, len); } bos.flush(); bos.close(); } }} 改造后的ZipEntry.jar包的下载地址：http://download.csdn.net/detail/huyongl1989/9120755 write by laohu2015-09-26 21:34:09 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Android基础之解压zip中文乱码处理.html"},{"title":"Android开发问题汇总–持续更新","text":"Android开发中遇到的小问题汇总，会持续更新。 提供网上一个Android开放问题汇总贴：https://github.com/JohnTsaiAndroid/AndroidTips TextView控件中给文本添加下划线的几种方式: 1.资源文件中用HTML标签把文本包起来即可 123&lt;resources&gt; &lt;string name=\"hello\"&gt;&lt;u&gt;hello&lt;/u&gt;&lt;/string&gt;&lt;/resources&gt; Java代码中可以这样处理：1234TextView textView = (TextView)findViewById(R.id.tv_test); textView.setText(Html.fromHtml(\"&lt;u&gt;\"+\"hello\"+\"&lt;/u&gt;\"));//或者这样处理textView .getPaint().setFlags(Paint.UNDERLINE_TEXT_FLAG ); //下划线 当将一个Android工程设置为Library之后，在另外一个Android工程中如果通过Configure build Path –&gt; Java Build Path –&gt; Project选项 –&gt; Add刚刚设置的library工程的话，是无法识别library工程中的资源文件的(引用资源文件编译不通过)。应该这样设置Configure build Path –&gt; Android –&gt; library选项 –&gt; Add刚刚设置的library工程。 Java中三目运算符如果和自动拆箱一起用会出现空指针异常，如下代码：123Map&lt;String, Boolean&gt; map = new HashMap&lt;String, Boolean&gt;();Boolean b = (map != null ? map.get(\"test\") : false);System.out.println(b); 出现空指针的原因是因为Java三目运算符中第二、三位操作数为基本类型和对象时，会自动将对象拆箱为基本类型数据进行运算(大家可以自己去看官方文档)，上述代码中刚好符合这种情况(第二位为对象，第三位为基本类型)，map.get(“test”)在实际执行中是这样执行的：((Boolean)map.get(“test”)).booleanValue()，将map中取得的Boolean对象自动拆箱为基本类型，而这个地方map.get(“test”)取出的值为null，自动拆箱的时候就会出现空指针了。如果这个地方一定要用三目运算符，只需要保证第二、三位操作数均为对象即可123Map&lt;String, Boolean&gt; map = new HashMap&lt;&gt;();Boolean b = (map != null ? map.get(\"test\") : Boolean.valueOf(false));System.out.println(b); Activity中两个Fragment进行切换时，例如：有FragmentA和FragmentB，进入Activity的时候，默认显示FragmentA，我点击FragmentA中的某个按钮切换到FragmentB，同时调用addToBackStack加入到返回栈，当我在FragmentB中点击返回按钮回到FragmentA时，FragmentA中的onResume方法却不执行。遇到这个问题的话可以看看在Activity中是否还保持了对FragmentB的引用，比如加入到了某个集合中或是声明成了Activity的成员变量，都会引发此问题。 Android中内部类就算实现了Serializable接口，也不能通过Intent进行序列化传参。如果传递的参数为序列化对象，该对象类不能是某个类里面的内部类。 java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState。出现问题的时机：我在进行Activity跳转时，会调用super.onBackPressed()方法手动finish掉当前的Activity（继承自android.support.v4.app.FragmentActivity），当屏幕处于竖屏状态时没有任何问题，但是当我设置为横屏在进行跳转操作时，会出现上述异常。 异常信息如下：123456789101112131415161718192021222324252627java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1343) at android.support.v4.app.FragmentManagerImpl.popBackStackImmediate(FragmentManager.java:486) at android.support.v4.app.FragmentActivity.onBackPressed(FragmentActivity.java:179) at com.emap.base.BaseActivity.finishActivity(BaseActivity.java:360) at com.emap.air.activity.IndexActivity$1.handleMessage(IndexActivity.java:128) at android.os.Handler.dispatchMessage(Handler.java:99) at android.os.Looper.loop(Looper.java:137) at android.app.ActivityThread.main(ActivityThread.java:5119) at java.lang.reflect.Method.invokeNative(Native Method) at java.lang.reflect.Method.invoke(Method.java:511) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:834) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:601) at dalvik.system.NativeStart.main(Native Method) 通过上述异常可以看出错误出现的原因并不是我自己写的代码导致的，猜测的话可能跟系统版本有关。 解决办法：将super.onBackPressed()替换成finish()方法来结束当前Activity即可。 参考文章：http://zhiweiofli.iteye.com/blog/1539467 TextView通过代码设置字体大小要使用如下方式textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, getResources().getDimensionPixelSize(R.dimen.dp_10));必须要使用该方法设置单位类型，否则设置的字体效果会和你预期的不一样 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Android开发问题汇总–持续更新.html"},{"title":"Android百度地图导航功能的那些坑","text":"实现步骤 首先要先在AndroidManifest.xml中注册导航服务 &lt;service android:name=&quot;com.baidu.navi.location.f&quot; android:enabled=&quot;true&quot;&gt;&lt;/service&gt; 添加相关的权限，我也不知道哪些是必须的，我直接把Demo里面的相关权限配置全部拉过来了 在导航之前要先调用BaiduNaviManager.getInstance().initEngine对导航引擎进行初始化。可以通过NaviEngineInitListener接口检查导航引擎初始化是否成功，同时通过LBSAuthManagerListener接口对API-Key进行Key校验是否成功，status结果为0代表key校验成功。 必须将Demo中assert目录下的两个文件BaiduNaviSDK_Resource_v1_0_0.png，channel拷贝到自己项目的assert目录下去，否则导航引擎无法初始化成功。 在导航引擎初始化成功后，调用导航功能前调用BaiduNaviManager.getInstance().checkEngineStatus(context)检测导航引擎是否初始化成功。 调用BaiduNaviManager.getInstance().launchNavigator开始导航。 关键代码相关代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213 public static void launchNavi(final Activity activity, List points ){ if(points.size() &lt; 2) { Toast.makeText(activity, \"数据不合法，暂时无法导航\", Toast.LENGTH_SHORT).show(); return; } BaiduNaviManager.getInstance().launchNavigator(activity, points, //路线点列表 NE_RoutePlan_Mode.ROUTE_PLAN_MOD_MIN_TIME, //算路方式 false, //真实导航 BaiduNaviManager.STRATEGY_FORCE_ONLINE_PRIORITY, //在离线策略 new OnStartNavigationListener() { //跳转监听 @Override public void onJumpToNavigator(Bundle configParams) { Intent intent = new Intent(activity, NaviBdMapActivity.class); intent.putExtras(configParams); activity.startActivityForResult(intent,REQUESTCODE_NAVI_FINISH); } @Override public void onJumpToDownloader() { } } ); } /** * 初始化导航引擎 * Author: hyl * Time: 2015-7-9下午4:56:18 * @param activity */ public static void initNaviEngine(final Activity activity) { BaiduNaviManager.getInstance().initEngine(activity, Utils.getRootPath(), new SPMNaviEngineInitListener(), new LBSAuthManagerListener() { @Override public void onAuthResult(int status, String msg) { String str = null; if (0 == status) { str = \"key校验成功!\"; } else { str = \"key校验失败, \" + msg; } } } ); } private static class SPMNaviEngineInitListener implements NaviEngineInitListener { public void engineInitSuccess() { Log.i(\"Navi\", \"导航初始化成功\"); } public void engineInitStart() { } public void engineInitFail() { Log.i(\"Navi\", \"导航初始化失败\"); } }; public class NaviBdMapActivity extends Activity { public void onCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); // 创建NmapView if (Build.VERSION.SDK_INT &lt; 14) { BaiduNaviManager.getInstance().destroyNMapView(); } MapGLSurfaceView nMapView = BaiduNaviManager.getInstance().createNMapView(this); // 创建导航视图 View navigatorView = BNavigator.getInstance().init( NaviBdMapActivity.this, getIntent().getExtras(), nMapView); // 填充视图 setContentView(navigatorView); BNavigator.getInstance().setListener(mBNavigatorListener); BNavigator.getInstance().startNav(); // 初始化TTS. 开发者也可以使用独立TTS模块，不用使用导航SDK提供的TTS BNTTSPlayer.initPlayer(); // 设置TTS播放回调 BNavigatorTTSPlayer.setTTSPlayerListener(new IBNTTSPlayerListener() { @Override public int playTTSText(String arg0, int arg1) { // 开发者可以使用其他TTS的API return BNTTSPlayer.playTTSText(arg0, arg1); } @Override public void phoneHangUp() { // 手机挂断 } @Override public void phoneCalling() { // 通话中 } @Override public int getTTSState() { // 开发者可以使用其他TTS的API, return BNTTSPlayer.getTTSState(); } }); BNRoutePlaner.getInstance().setObserver( new RoutePlanObserver(this, new IJumpToDownloadListener() { @Override public void onJumpToDownloadOfflineData() { } })); } private IBNavigatorListener mBNavigatorListener = new IBNavigatorListener() { @Override public void onYawingRequestSuccess() { // TODO 偏航请求成功 } @Override public void onYawingRequestStart() { // TODO 开始偏航请求 } @Override public void onPageJump(int jumpTiming, Object arg) { // TODO 页面跳转回调 if (IBNavigatorListener.PAGE_JUMP_WHEN_GUIDE_END == jumpTiming) { finishActivity(); } else if (IBNavigatorListener.PAGE_JUMP_WHEN_ROUTE_PLAN_FAIL == jumpTiming) { finishActivity(); } } @Override public void notifyGPSStatusData(int arg0) { } @Override public void notifyLoacteData(LocData arg0) { } @Override public void notifyNmeaData(String arg0) { } @Override public void notifySensorData(SensorData arg0) { } @Override public void notifyStartNav() { BaiduNaviManager.getInstance().dismissWaitProgressDialog(); } @Override public void notifyViewModeChanged(int arg0) { } }; @Override public void onResume() { BNavigator.getInstance().resume(); super.onResume(); BNMapController.getInstance().onResume(); }; @Override public void onPause() { BNavigator.getInstance().pause(); super.onPause(); BNMapController.getInstance().onPause(); } @Override public void onConfigurationChanged(Configuration newConfig) { BNavigator.getInstance().onConfigurationChanged(newConfig); super.onConfigurationChanged(newConfig); } public void onBackPressed() { BNavigator.getInstance().onBackPressed(); } @Override public void onDestroy() { BNavigator.destory(); BNRoutePlaner.getInstance().setObserver(null); super.onDestroy(); } public void finishActivity() { finish(); overridePendingTransition(R.anim.in_from_right,R.anim.out_to_left); }} 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Android百度地图导航功能的那些坑.html"},{"title":"Android调用相机无法执行onActivityResult或data为null","text":"最近项目中调用系统相机时遇到了这么个问题：红米手机无法执行onActivityResult回调，部分华为手机无法获取到照片数据，最后各种分析，各种网上搜索资料折腾了好久，最后终于把问题解决，当看到问题的最终原因时，我也是醉了，简直就是坑爹坑大发了。 最开始用红米手机调用系统相机的时，当我拍照完成点击那个勾勾始终无法返回到前面的界面上，也就是无法调用onActivityResult函数取到拍照的照片，在网上搜索了一圈，没找到解决办法，都说是红米的系统问题，无法解决，项目比较紧张，刚好客户的手机全部是统一型号的华为荣耀6Plus，这个问题丢着暂时没管了。后来现场同事批量测试机器时，发现有3台手机可以拍照，但是在onActivityResult回调中获取到的照片数据为null，但是其他的同型号手机又没这个问题，这问题看着真是坑爹啊。 远程调试代码后发现，我在调用系统相机时设置的照片存放目录无法创建成功，我调用系统相机的代码如下：12345678910111213public void takePicture() { //照片存放目录 File file = new File(mPicDirectory); if(!file.exists()) {//目录不存在则创建该目录及其不存在的父目录 file.mkdirs(); } Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); mPicName = getPictureName();//获取照片名称 mPicPath = mPicDirectory + mPicName;//照片存储路径 //将照片保存到mPicPath位置 intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File(mPicPath))); startActivityForResult(intent, CODE_RESULT_TAKE_PHOTO);} 我调试的时候在onActivityResult回调里通过照片路径获取Bitmap对象的时候发现获取到的Bitmap对象一直为null，所以就猜想是不是照片没保存成功，我在文件管理系统里去找这个照片的时候发现，连照片存储目录mPicDirectory都不存在，我再次跟踪代码发现file.mkdirs()始终返回的都是false。看来问题的最终原因是这个：无法创建目录和文件(华为手机系统在拍照输出的时候，如果输出文件路径不存在时竟然没有任何提示和异常，这点对于发现问题的根源有点困难)。然后我又去检查了权限、手机设置里面的权限等所有有可能涉及的问题，结果依然没有效果。既然这些都不是导致目录创建失败的原因，那会不会是目录路径本身不正确呢，我的目录路径是这样获取的： 12345678910111213141516171819202122232425262728String mPicDirectory = FileManager.getPath() + Configuration.SYS_PHOTO_PATH; //FileManager的部分代码是这样的，这个代码是以前的同事写的，没有细看过： public static String getPath(){ boolean sdCardExist = Environment.getExternalStorageState() .equals(android.os.Environment.MEDIA_MOUNTED); //判断sd卡是否存在 return !sdCardExist ? MOBILE_PATH : SD_PATH;} //sdcard路径private static String SD_PATH = Environment.getExternalStorageDirectory().getAbsolutePath(); //应用数据路径public static final String MOBILE_PATH = Environment.getDataDirectory().getAbsolutePath(); //这里有一段静态代码块static{ File f = new File(\"/storage/sdcard1\"); if(f.exists()){ long size = getFreeSize(\"/storage/sdcard1\"); long sd0Size = getFreeSize(\"/storage/sdcard0\"); if(size &gt; sd0Size){ SD_PATH = \"/storage/sdcard1\"; } }} 当我看到上面的静态代码块的时候，我立马就知道了问题的原因，静态代码块中做了一个剩余空间判断，选取的是空间比较大的那个sdcard路径，而且代码都是写死的Environment.getExternalStorageDirectory().getAbsolutePath()系统这个代码是获取手机里的内置SDCard的路径，我的红米手机自己又额外插了一张内存卡，这个是手机的外接SDCard，用Environment.getExternalStorageDirectory()获取到只是手机自带的外置SDCard路径，不能获取自己插入的内存卡路径，我的手机通过Environment.getExternalStorageDirectory()方式获取的路径是/storage/sdcard0（我手机内置的SDCard），而通过可用空间比较之后发现该卡的可用空间少于/storage/sdcard1（我自己插入的SDCard），所以最终路径变成了/storage/sdcard1，而在Android4.4以上后，不允许三方App对外接的SDCard进行操作，因此我们队最后得到的这个目录是没有写入权限的，所以我创建照片存储目录的时候一直失败，所以拍照的时候照片数据没有地方可以输出，华为手机是直接体现在照片数据无法获取，而红米手机则是直接不允许返回到前面的调用界面。 Google在Android中限制三方App操作外接SDCard的原文如下： The WRITE_EXTERNAL_STORAGE permission must only grant write access to the primary external storage on a device. Apps must not be allowed to write to secondary external storage devices, except in their package-specific directories as allowed by synthesized permissions. 后来想了想，调用相机这么简单的一个功能，红米的系统应该不可能给阉割掉，所以出了问题还是老老实实的先找自己代码的问题吧。至于那个外接SDCard的写入权限还有待寻找答案。 系统内置SDCard写入、删除、读写权限： 1234//文件创建、删除权限&lt;uses-permission android:name=\"android.permission.MOUNT_UNMOUNT_FILESYSTEMS\" /&gt;//文件读写权限，只针对于手机内存的SDCard，对外接SDCard无效&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Android调用相机无法执行onActivityResult或data为null.html"},{"title":"Behavior-UC-Main-Page","text":"老规矩，还是先上效果图 github地址 前面我也写过一篇关于UC浏览器首页滑动动画效果的文章UC浏览器首页滑动动画实现，只不过这篇文章是通过自定义View的方式实现这个滑动效果。最近在看Behavior相关的东西，所以使用Behavior又实现了一次UC浏览器主页的滑动效果，使用Behavior实现相比较自定义View的实现方式还是要简单方便很多。 View结构分析UC首页滑动过程中可以分为四个View在参与滑动，具体的分析流程可以参见UC浏览器首页滑动动画实现这篇文章的分析，这里简要罗列下： UCViewTitle:首页标题栏视图(UC首页显示UC头条) UCViewHeader:首页头部导航视图(UC首页显示各个网站ICON入口) UCViewContent:首页内容视图(UC首页显示新闻内容的列表) UCViewTab:首页内容Tab导航视图(UC首页显示新闻分类的View) Behavior既然已经决定通过Behavior实现此效果，那下面几个概念就必须要弄清楚： Behavior必须作用于CoordinatorLayout直接子View才会生效 Behavior其实是对嵌套滑动的应用，因为CoordinatorLayout其实是实现嵌套滑动，最终对嵌套滑动的执行交给Behavior来实现，所以Behavior的滑动处理必须要有能触发嵌套滑动的子View触发才会起作用 关于嵌套滑动 Android实现嵌套滑动只需要实现NestedScrollingParent和NestedScrollingChild这两个接口即可 在嵌套滑动过程中子View(实现NestedScrollingChild接口)会将自身的滑动情况通知父View(实现NestedScrollingParent接口)，不一定是直接父View，父View做完相关动作之后再通知子View，也就是子View其实是整个嵌套滑动的发起者 CoordinatorLayout实现了NestedScrollingParent接口作为嵌套滑动的父View，因此如果要处理Behavior中对于滑动的相关处理，就需要有一个嵌套滑动的子View来触发这个Behavior 实现 上面分析UC首页时发现有个显示新闻的列表，因此我们可以用RecyclerView作为列表，因为RecyclerView实现了NestedScrollingChild接口，可以作为嵌套滑动的子View 因为是多个视图的同时滑动处理，所以在实现Behavior时需要选择一个依赖，这里我选择前面说过的UCViewHeader作为其他视图Behavior的依赖 在看了AppBarLayout的源码之后，发现其子类ScrollingViewBehavior继承至HeaderScrollingViewBehavior,在查看源码之后发现如下几个类可以抽出来为我们所用HeaderScrollingViewBehavior,ViewOffsetBehavior,ViewOffsetHelper HeaderScrollingViewBehavior:继承该类后，应用此Behavior的View布局时会自动在其依赖View的下方 ViewOffsetBehavior：继承该类后，应用此Behavior的View在布局时会自动进行移动处理 UCViewTitleBehavior实现UCViewTitle在初始时是不可见的，我采用设置其TopMargin让其不可见，然后在滑动过程中再慢慢滑动到可见，当前完全可见时滑动结束，此时其translationY为0，当滑动未开始时其translationY为-height12345678910111213141516171819202122232425262728293031323334public class UCViewTitleBehavior extends ViewOffsetBehavior&lt;View&gt; { ... @Override public boolean onLayoutChild(CoordinatorLayout parent, View child, int layoutDirection) { //因为UCViewTitle默认是在屏幕外不可见，所以在UCViewTitle进行布局的时候设置其topMargin让其不可见 ((CoordinatorLayout.LayoutParams) child.getLayoutParams()).topMargin = -child.getMeasuredHeight(); return super.onLayoutChild(parent, child, layoutDirection); } @Override public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) { return isDependOn(dependency); } @Override public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) { int headerOffsetRange = -child.getMeasuredHeight();// int titleOffsetRange = child.getMeasuredHeight();//滑动总距离 if (dependency.getTranslationY() == headerOffsetRange) {//滑动初始位置 child.setTranslationY(titleOffsetRange); } else if (dependency.getTranslationY() == 0) {//滑动结束位置 child.setTranslationY(0); } else {//滑动过程中 child.setTranslationY((int) (dependency.getTranslationY() / (headerOffsetRange * 1.0f) * titleOffsetRange)); } return false; } private boolean isDependOn(View dependency) { //确定UCViewHeader作为依赖 return dependency != null &amp;&amp; dependency.getId() == R.id.news_view_header_layout; }} 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Behavior-UC-Main-Page.html"},{"title":"Flutter实战之封装一个LinearLayout","text":"序在APP开发过程中，经常遇到需要添加背景、设置边距、动态显示和隐藏某个组件。 但是在Flutter中，能同时具有添加背景、设置边距、阴影、边框、圆角的布局只有Container(参考我上一篇文章的介绍Flutter入门之Row、Column、Container布局)，这个已经算是业务功能比较多的组件了，而要想实现组件的显示和隐藏则需要用到另外一个组件Offstage，水平的线性布局则需要用到组件Row，垂直的线性布局则需要用到组件Column，而Row和Column这两个布局都不具备直接设置背景、边距、显示和隐藏等功能。在开发过程中这种需求又很常见，不可能每个地方都把这些代码重复一遍，所以对这几个组件封装一下，实现了一个类似Android中LinearLayout布局的组件很有必要。 封装LinearLayout封装成LinearLayout其实很简单，就是将Row、Column、Offstage、Container四个组件合理的组合在一起就可以了。 首先要暴露一个参数确定是水平的线性布局还是垂直的线性布局 将Container经常用到的背景、边距参数暴露出来 将Row、Column中用到的主轴、交叉轴的对齐方式暴露出来 将Row、Column中主轴size的适配方式暴露出来 暴露出一个方法用来动态改变组件的显示和隐藏 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import &apos;package:flutter/material.dart&apos;;import &apos;package:flutter_library/common/util.dart&apos;;enum LayoutOrientation { horizontal, vertical }class LinearLayout extends StatefulWidget { final LayoutOrientation orientation; final bool isVisible; final Decoration background; final EdgeInsetsGeometry padding; final EdgeInsetsGeometry margin; final List&lt;Widget&gt; children; final MainAxisAlignment mainAxisAlignment; final MainAxisSize mainAxisSize; final CrossAxisAlignment crossAxisAlignment; LinearLayout({ Key key, this.orientation, this.isVisible = true, this.background, this.padding, this.margin, this.children = const &lt;Widget&gt;[], this.mainAxisAlignment = MainAxisAlignment.start, this.mainAxisSize = MainAxisSize.min, this.crossAxisAlignment = CrossAxisAlignment.center, }) : super(key: key); @override LinearLayoutState createState() { return LinearLayoutState(); }}class LinearLayoutState extends State&lt;LinearLayout&gt; { bool _isVisible = true; @override void initState() { _isVisible = widget.isVisible; super.initState(); } @override Widget build(BuildContext context) { return isNotNull(_isVisible) ? Offstage( offstage: !_isVisible, child: _buildLayoutWidget(), ) : _buildLayoutWidget(); } Widget _buildLayoutWidget() { if (_isNeedContainerWidget()) { return _buildContainerWidget(); } else { return _buildOrientationWidget(); } } bool _isNeedContainerWidget() { return isNotNull(widget.background) || isNotNull(widget.padding) || isNotNull(widget.margin); } Widget _buildContainerWidget() { return Container( decoration: widget.background, padding: widget.padding, margin: widget.margin, child: _buildOrientationWidget(), ); } Widget _buildOrientationWidget() { if (widget.orientation == LayoutOrientation.horizontal) { return _buildHorizontalWidget(); } else { return _buildVerticalWidget(); } } Widget _buildVerticalWidget() { return Column( mainAxisSize: widget.mainAxisSize, mainAxisAlignment: widget.mainAxisAlignment, crossAxisAlignment: widget.crossAxisAlignment, children: widget.children, ); } Widget _buildHorizontalWidget() { return Row( mainAxisSize: widget.mainAxisSize, mainAxisAlignment: widget.mainAxisAlignment, crossAxisAlignment: widget.crossAxisAlignment, children: widget.children, ); } bool isVisible() { return _isVisible; } void setVisible(bool isVisible) { setState(() { _isVisible = isVisible; }); }} package:flutter_library/common/util.dart文件代码如下：1234567bool isNull(dynamic obj) { return obj == null;}bool isNotNull(dynamic obj) { return obj != null;} LinearLayout使用12345678910111213141516171819202122232425262728293031323334353637383940414243class LinearLayoutSampleWidget extends StatefulWidget { @override State&lt;StatefulWidget&gt; createState() { return LinearLayoutSampleState(); }}class LinearLayoutSampleState extends State&lt;LinearLayoutSampleWidget&gt; { GlobalKey&lt;LinearLayoutState&gt; _key = GlobalKey&lt;LinearLayoutState&gt;(); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(&apos;LinearLayout Sample&apos;), ), body: LinearLayout( background: BoxDecoration(color: Colors.blue), orientation: LayoutOrientation.vertical, children: &lt;Widget&gt;[ LinearLayout( key: _key, background: BoxDecoration(color: Colors.red), orientation: LayoutOrientation.horizontal, mainAxisSize: MainAxisSize.min, children: &lt;Widget&gt;[ Icon(Icons.list), Text(&apos;线性布局&apos;) ], ), FlatButton( onPressed: () { bool isVisible = _key.currentState.isVisible(); _key.currentState.setVisible(!isVisible); }, child: Text(&apos;切换显示&apos;), ) ], ) ); }} 这里重点说一下Demo中的GlobalKey&lt;LinearLayoutState&gt; _key = GlobalKey&lt;LinearLayoutState&gt;()这段代码，这个就是用来给LinearLayout设定一个唯一标识符，这样才能在后面点击按钮的时候调用setVisible方法来显示和隐藏。而泛型LinearLayoutState则是我封装的代码中的一个类，因为我的setVisible方法暴露在此State中。 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Flutter-For-LinearLayout.html"},{"title":"Flutter入门之Could not find lint-gradle-api.jar","text":"这两天在学习Flutter，学习过程中尝试着写了个Demo，然后在Android平台运行想看下效果，结果直接gradle都没过，错误提示如下：123Where: Build file &apos;PROJECTPATH/android/app/build.gradle&apos; line: 25What went wrong: A problem occurred evaluating project &apos;:app&apos;.Could not resolve all files for configuration &apos;classpath&apos;. Could not find lint-gradle-api.jar (com.android.tools.lint:lint-gradle-api:26.1.2). Searched in the following locations: https://jcenter.bintray.com/com/android/tools/lint/lint-gradle-api/26.1.2/lint-gradle-api-26.1.2.jar 看到这个错误第一反应是这个库在仓库里没找到，然后看了下Android工程根目录下的build.gradle文件，其配置如下：123456allprojects { repositories { google() jcenter() }} 然后我又给了加了个mavenCentral()，结果运行依旧是这个错误，而且我的网络是没有任何问题的。 前面的方式无法解决后，就在flutter的github里的issue中看了半天，然后发了一种说法： 在你的flutter安装目录下找到文件：flutter/packages/flutter_tools/gradle/flutter.gradle 打开该文件将文件中如下脚本内容：123456repositories { jcenter() maven { url &apos;https://dl.google.com/dl/android/maven2&apos; }} 修改成：123456repositories { maven { url &apos;https://dl.google.com/dl/android/maven2&apos; } jcenter()} 也就是将maven和jcenter调换一个顺序。 我使用这种方式解决了编译错误的问题，当然还有个前提条件是你的网络可以成功访问google。我没有试过国内网络的环境，不过按照这种方式国内网络环境可以将仓库地址改为国内镜像地址，至于具体镜像地址，大家可以在网上找。 我代码中使用的flutter版本为：sdk: &quot;&gt;=2.0.0-dev.68.0 &lt;3.0.0&quot; 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Flutter-For-Start-Build-Error.html"},{"title":"Flutter实战之Gank Demo实践","text":"初学Flutter，看了两天文档，花了两天时间利用gank.io提供的api接口实践了下Flutter，写了个Demo. 主要实践了Flutter的如下几个知识点： 如何使用dio框架发起网络请求 如何实现常用布局，如： 水平布局: Row 垂直布局: Column 层叠布局: Stack 如何设置间距: Padding 如何显示网络图片Image 如何使用下拉刷新组件: RefreshIndicator 如何使用ListView组件，以及添加上拉加载更多功能 如何给普通widget添加事件监听: GestureDetector 如何实现水波纹效果: InkWell 如何使用Card实现卡片式布局 在Flutter中如何使用WebView 如何创建Material Design风格的应用以及自定义其主题样式 如何使用AppBar组件同时给其添加TabBarView组件和BottomNavigationBar 如何进行页面跳转: Navigator Demo代码地址请戳这这这 Demo效果如如下： 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Flutter-Gank-Demo.html"},{"title":"Flutter入门之Row、Column、Container布局","text":"序写过Android的都知道Android中有个很常用布局LinearLayout，它可以实现线性的横向或纵向的布局结构。对于学习Flutter的Android开发者来说，肯定也想知道Flutter中该如何实现线性布局结构。 在Flutter中线性布局结构的实现是通过两个不同的widget分别来实现横向和纵向布局结构的。组件Row用来实现横向的线性布局，而组件Column则用来实现纵向的线性布局，而Container则是用来设置背景、设置大小、设置边距(padding)的布局。下面来分别介绍三个组件的相关属性： ContainerContainer的构造函数如下：1234567891011121314Container({ Key key, this.alignment, this.padding, Color color, Decoration decoration, this.foregroundDecoration, double width, double height, BoxConstraints constraints, this.margin, this.transform, this.child, }) 属性 key: 该属性代表当前widget的唯一标识符(类似于Android中的id)，在程序运行过程中，如果想调用该widget的某个方法，那就需要设置该属性值，该属性不是必须值 alignment: 子元素的对齐方式，官方已经提供了几种常用的对齐方式 padding: 这个比较好理解，跟Android中的是一个意思，内边距 color: 设置组件的背景色 decoration: 与color属性功能一样，都是设置背景，不过decoration功能更强大，它可以设置背景图片、圆角、渐变、阴影、边框等 width &amp; height: 组件的宽高 constraints: 组件的宽高限制 margin: 外边距 transform: 矩阵转换 child: 子元素 另外在使用过程中，Container如果作为应用的根节点的话，它的宽高会自动填充为屏幕大小。 RowRow的构造函数如下：12345678910Row({ Key key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline textBaseline, List&lt;Widget&gt; children = const &lt;Widget&gt;[], }) 关键属性 key: 该属性代表当前widget的唯一标识符(类似于Android中的id)，在程序运行过程中，如果想调用该widget的某个方法，那就需要设置该属性值，该属性不是必须值 mainAxisAlignment: 子元素在主轴的对齐方式，Row的主轴即为水平方向 mainAxisSize: 主轴方向大小适配方式，只有两种取值方式： MainAxisSize.max 主轴方向大小(在Row中指宽度)与父容器大小相同(即Android中的match_parent) MainAxisSize.min 主轴方向大小(在Row中指宽度)由子元素决定(即Android中的wrap_content) crossAxisAlignment: 子元素在交叉轴(垂直方向)的对齐方式 children: 子元素列表 ColumnColumn的构造函数12345678910Column({ Key key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline textBaseline, List&lt;Widget&gt; children = const &lt;Widget&gt;[], }) 关键属性 key: 该属性代表当前widget的唯一标识符(类似于Android中的id)，在程序运行过程中，如果想调用该widget的某个方法，那就需要设置该属性值，该属性不是必须值 mainAxisAlignment: 子元素在主轴的对齐方式，Column的主轴即为垂直方向 mainAxisSize: 主轴方向大小适配方式，只有两种取值方式： MainAxisSize.max 主轴方向大小(在Column中指高度)与父容器大小相同(即Android中的match_parent) MainAxisSize.min 主轴方向大小(在Column中指高度)由子元素决定(即Android中的wrap_content) crossAxisAlignment: 子元素在交叉轴(水平方向)的对齐方式 children: 子元素列表 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Flutter-Row-Column-Container.html"},{"title":"Behavior实现滑动隐藏ToolBar与BottomNavigation","text":"多说无益，先上效果图img\\material-design 这个效果其实是和SegmentFault的首页效果是一样的。 Demo github地址戳这里 来由 前几天有人问我这样的效果如何实现，有何思路，我的第一反应就是使用Behavior来实现这个效果，使用Behavior实现此效果比自定义View实现此效果绝对要简单很多，之后找时间了实现了这个效果。 思路用过ToolBar + CoordinatorLayout + AppBarLayout的人应该知道这三者组合使用再设置合适的参数(没用过的人赶紧去看看吧，或者看我的Demo也可以哟)，就可以实现滑动隐藏显示ToolBar，因此这部分的效果Android使用Behavior已经替我们实现好了，没必要再去费神了，而且它的效果也蛮不错。 接下来我们要考虑的就是如何实现在滑动的时候也隐藏底部的BottomNavigation，既然前面我已经说过用Behavior来实现此效果，因此我们需要自定义一个Behavior来实现滑动隐藏BottomNavigation。 撸代码在前面一篇文章自定义Behavior实现快速返回效果(没看过的请先看看)中我已经介绍了自定义Behavior的相关知识，这里就不再赘述了。 先来看看ToolBar滑动隐藏的代码12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/appBarLayout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolBar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@android:color/holo_blue_dark\" app:title=\"ToolBar Title\" app:titleTextColor=\"@android:color/white\" app:layout_scrollFlags=\"scroll|enterAlways\"/&gt; &lt;/android.support.design.widget.AppBarLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 上面属性设置中app:layout_scrollFlags=&quot;scroll|enterAlways&quot;这个是必须要有，否则话滑动的时候ToolBar是不会滑动的。 那滑动隐藏BottomNavigation的这个Behavior该如何实现呢？其实很简单，我们在滑动列表的时候可以看到当ToolBar往上滑的时候BottomNavigation会同时往下滑，因此这里我可以把ToolBar作为BottomNavigation的依赖，ToolBar往上滑动多少BottomNavigation就同时往下滑动多少(这里我实现时保证了两者高度一致)。 既然知道了依赖关系也知道了滑动方向和滑动距离，再实现Behavior就简单多了，代码如下：1234567891011121314151617181920212223242526272829303132333435public class BottomNavigationViewBehavior extends CoordinatorLayout.Behavior&lt;View&gt; { public BottomNavigationViewBehavior() { } public BottomNavigationViewBehavior(Context context, AttributeSet attrs) { super(context, attrs); } @Override public boolean onLayoutChild(CoordinatorLayout parent, View child, int layoutDirection) { ((CoordinatorLayout.LayoutParams) child.getLayoutParams()).topMargin = parent.getMeasuredHeight() - child.getMeasuredHeight(); return super.onLayoutChild(parent, child, layoutDirection); } @Override public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) { //因为Behavior只对CoordinatorLayout的直接子View生效，因此将依赖关系转移到AppBarLayout return dependency instanceof AppBarLayout; } @Override public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) { //得到依赖View的滑动距离 int top = ((AppBarLayout.Behavior)((CoordinatorLayout.LayoutParams)dependency.getLayoutParams()).getBehavior()).getTopAndBottomOffset(); //因为BottomNavigation的滑动与ToolBar是反向的，所以取-top值 ViewCompat.setTranslationY(child, -top); return false; }} 上面的代码中获取依赖视图AppBarLayout的滑动距离时需要注意几点： 通过AppBarLayout.getTranslationY()无法获取到正确的滑动距离 通过AppBarLayout.getTop()无法获取到正确的滑动距离 最后查看源码后发现通过AppBarLayout.Behavior.getTopAndBottomOffset()可以获得正确的滑动距离值 现在Behavior实现了，我们再来看完整的布局文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/appBarLayout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolBar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@android:color/holo_blue_dark\" app:title=\"ToolBar Title\" app:titleTextColor=\"@android:color/white\" app:layout_scrollFlags=\"scroll|enterAlways\"/&gt; &lt;android.support.design.widget.TabLayout android:id=\"@+id/tabLayout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"@android:color/holo_blue_light\" app:tabTextColor=\"@android:color/white\" app:tabGravity=\"center\" app:tabIndicatorColor=\"@android:color/white\" app:tabSelectedTextColor=\"@android:color/holo_red_dark\"/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/viewpager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@android:color/white\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"/&gt; &lt;android.support.design.widget.BottomNavigationView android:id=\"@+id/bottomNavigationView\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@android:color/holo_blue_dark\" android:layout_gravity=\"bottom\" app:menu=\"@menu/bottom_menus\" app:layout_behavior=\"cn.ittiger.stickynavigation.behavior.BottomNavigationViewBehavior\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 对于布局中的ToolBar和BottomNavigationView也可以换成其他任意View来实现滑动隐藏效果。 Demo的完整代码在这 github地址 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Header-Footer-scroll-hide.html"},{"title":"Exception与Error","text":"相同点Exception和Error都是继承自Throwable，在Java中只有Throwable的实例才可以被抛(throw)出或捕获(catch)，它是java异常处理机制的基本组成类型。 Exception和Error体现了Java平台设计者对不同异常情况的分类 Exception Exception是程序正常运行中，可以预料的意外情况，可能并且应该被捕获从而进行相应的处理 Exception又分为编译器异常和运行期异常。 编译器异常在代码中必须显示的进行捕获处理，这也是编译期检查的一部分。 运行期异常就是在程序运行过程中，由于程序逻辑等原因导致的运行异常，比如：NullPointerException,ArrayIndexOutOfBoundsException之类，这类异常通常都是可以通过编码避免的逻辑错误，具体根据需要来判断是非需要补货，并不会在编译期强制要求 ErrorError是指在正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序(比如JVM自身)处于正常、不可恢复的状态。所以既然是非正常情况，那么也不便于也不需要捕获，常见的比如OutOfMemoryError之类，都是Error的子类。 ClassNotFoundException &amp;&amp; NoClassDefFoundErrorClassNotFoundException在程序运行过程中通过某个类的字符串名称加载该类时，如果没有找到具有指定名称的类的定义的时候就会抛出ClassNotFoundException异常。通过字符串限定类名加载类主要有如下三种方式： Class.forName(java.lang.String) ClassLoader.findSystemClass(java.lang.String) ClassLoader.loadClass(java.lang.String, boolean) NoClassDefFoundError如果JVM或者ClassLoader实例尝试加载（可以通过正常的方法调用，也可能是使用new来创建新的对象）类的时候却找不到类的定义。要查找的类在编译的时候是存在的，运行的时候却找不到了。这个时候就会导致NoClassDefFoundError 造成该问题的原因可能是打包过程漏掉了部分类，或者jar包出现损坏或者篡改。解决这个问题的办法是查找那些在开发期间存在于类路径下但在运行期间却不在类路径下的类。 注意点 在开发过程中尽量不要捕获类似Exception这样的通用异常，而是应该捕获特定异常，因为特定异常可以尽可能多的告知我们错误信息，而通用异常则会隐藏一些信息 程序中不要捕获不希望被捕获的异常，有些时候我们可能更希望RuntimeException扩散出来，而不是被捕获 不要吞掉异常。很多人经常写出这样的代码，因为这样会导致程序出现问题的时候，我们很难定位和发现错误123456//下面就是一个吞掉异常的例子try { //业务逻辑。。。} catch(IOException e) { e.printStackTrace();} try-catch-finally在处理java异常的方法中try-catch-finally是最常用的方式，但是在使用该代码块的时候会有一些隐藏的问题，主要是在方法返回值的问题上。 按照一般的惯性认知：当遇到return语句的时候，执行函数会立刻返回。但是在java中遇到finally的时候就有会例外。 除了return语句，try代码块中的break和continue语句也可能使控制权进入finally代码块。 当函数返回值是引用类型同时存在finally语句块时要特别注意，如果在finally块中对返回的引用对象属性进行了更改，这时即使没有在finally块中显示调用return语句，这个更改也会作用在返回值上。1234567891011121314public User getUser() { User user = null; try { user = new User(&quot;user&quot;); //其他业务逻辑。。。 return user; } catch(IOException e) { //... } finally { if(user != null) { user.setName(&quot;user1&quot;); } }} 上述代码中该函数最终返回的User对象的name属性其实为user1 产生上述问题的原因是因为JVM会保证在return语句执行之前，先执行finally语句 性能问题另外一个使用try-catch要注意的点是try-catch代码段会产生额外的性能开销，它往往会影响JVM对代码进行优化，所以建议仅捕获有必要的代码段，不要一个try-catch包住大段的代码。因此使用异常控制代码流程也不是一个好注意，它远比通常意义上的条件语句(if/else,swich)要低效 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Java-Exception-Error.html"},{"title":"强引用、软引用、弱引用、虚引用","text":"在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。 强引用特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。 通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。 软引用特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。 应用场景软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。 弱引用弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。 在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 应用场景弱应用同样可用于内存敏感的缓存。 虚引用特点：虚引用也叫幻象引用，通过PhantomReference类来实现。 无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。12ReferenceQueue queue = new ReferenceQueue ();PhantomReference pr = new PhantomReference (object, queue); 程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。 应用场景可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Java-Reference.html"},{"title":"String、StringBuffer与StringBuilder","text":"StringString的创建机制因为String在Java中使用过于频繁，Java为了避免在系统中产生大量的String对象，引入了字符串常量池的概念。 其运行机制是： 创建一个字符串时，首先检查池中是否有值相同的字符串对象(equals决定)，如果有则不需要创建而是直接从常量池中找到的该字符串对象的引用； 如果没有则新建一个字符串对象，返回该对象引用，并且将新创建的字符串对象放入池中 但是通过new方法创建的String对象是不检查字符串池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入池中。 举例：123456789//通过直接量赋值方式，放入字符串常量池String str1 = &quot;123&quot;; //通过new方式赋值方式，不放入字符串常量池String str2 = new String(“123”);//此时的str1 != str2String str3 = &quot;1&quot; + &quot;2&quot; + &quot;3&quot;;//str3 == str1 是成立的 上述代码中在编译期的时候，str3即被编译成”123”字符串，而此时常量池中已经存在该字符串，所以str3与str1是相等的 String的特性不可变String对象一旦生成，则不能再对它的值进行改变，这里的不可变指这个字符串对象无法改变，而我们平时定义的字符串变量虽然可以改变，但是实质上它是改变了这个变量的引用，相当于将这个变量指向了另外一个字符串对象，而一开始的字符串对象还是没有变的。 不可变的主要作用在于当一个对象需要被多线程共享，并且访问频繁时，可以省略同步和锁等待的时间，从而大幅度提高系统性能。 不可变模式是一个可以提高多线程程序的性能，降低多线程程序复杂度的设计模式。 针对常量池的优化当2个String对象拥有相同的值时，他们只引用常量池中的同一个拷贝。当同一个字符串反复出现时，这个技术可以大幅度节省内存空间。123String str1 = &quot;123&quot;;String str2 = &quot;123&quot;;//此时的str1 == str2是成立的 为什么不可变我们看String的源码可以发现String底层是采用字符数组(char[])来存储字符串值，该数组的定义如下1private final char value[]; 这个数组定义为private final，在java中数组也是对象，所以当String对象一旦初始化完成，其内部变量value的引用就无法改变，顶多只能改变数组中元素的值，但是在看遍String的所有方法后，发现String中根本没有一个方法可以改变value这个char数组里面的元素，所以在String初始化完成后即不可变。12String a = &quot;abcde&quot;;a = a.subString(1);//这时a=&quot;bcde&quot; 虽然我们在编码过程中经常会调用String的toLowerCase,substring等方法，如上面的例子中虽然a最终被改变成了&quot;bcde&quot;，但是实际上这是生成的一个新字符串对象，只是将变量a的引用指向了这个新对象，而没有改变原有字符串对象&quot;abcde&quot;的值。 StringBuffer &amp; StringBuilderStringBuffer和StringBuilder都实现了AbstractStringBuilder抽象类，拥有几乎一致对外提供的调用接口； 其底层在内存中的存储方式与String相同，都是采用char数组存储数据，只是这个char数组没被final修饰，因此这个char数组的引用可以改变且该数组中的元素也可以改变，所以StringBuffer/StringBuilder对象的值是可以改变的。 而StringBuffer/StringBuilder在改变char数组过程中是在该对象自身内部进行的，所以对象本身的引用还是同一个。因此定义一个StringBuffer/StringBuilder变量，修改其值之后，其引用还是同一个，不会改变。 两者对象在构造过程中，首先按照默认大小申请一个字符数组，由于会不断加入新数据，当超过默认大小后，会创建一个更大的数组，并将原先的数组内容复制过来，再丢弃旧的数组。因此，对于较大对象的扩容会涉及大量的内存复制操作，如果能够预先评估大小，可提升性能。 唯一需要注意的是：StringBuffer是线程安全的，但是StringBuilder是线程不安全的。可参看Java标准类库的源代码，StringBuffer类中方法定义前面都会有synchronize关键字。为此，StringBuffer的性能要远低于StringBuilder。 应用场景 在字符串内容不经常发生变化的业务场景优先使用String类。例如：常量声明、少量的字符串拼接操作等。如果有大量的字符串内容拼接，避免使用String与String之间的“+”操作，因为这样会产生大量无用的中间对象，耗费空间且执行效率低下（新建对象、回收对象花费大量时间）。 在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在多线程环境下，建议使用StringBuffer，例如XML解析、HTTP参数解析与封装。 在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在单线程环境下，建议使用StringBuilder，例如SQL语句拼装、JSON封装等。 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Java-String-StringBuffer-StringBuilder.html"},{"title":"多线程之：Synchronized与ReentrantLock","text":"什么是线程安全 保证多线程环境下共享的、可修改的状态的正确性。(这里的状态在程序中可以看作为数据) 反着来说则是如果状态非共享、不可修改，也就不存在线程安全的问题 保证线程安全的两种方法 封装，通过封装将对象内部状态隐藏、保护起来 不可变，将状态改为不可变,例如将状态定义为final 线程安全要保证的基本特性 原子性 相关操作不会在中途被其他线程所干扰，一般通过同步机制实现 可见性 一个行程修改了某个共享变量，其新状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的 有序性 保证线程内串行语义，避免指令重排 Synchronized与ReentrantLocksynchronizedsynchronized可以很方便的解决多线程间资源共享同步的问题，也就是我们平常所说的线程安全问题。 它可以修饰方法和代码块，无法是用作何种修饰，synchronized获取的锁都是对象。 关于synchronized的使用这里就不说了。 ReentrantLockReentrantLock一般称为再入锁,是Lock的实现类，是一个互斥的同步器。 再入锁通过代码直接调用 lock() 方法获取，代码书写也更加灵活。同时ReentrantLock 提供了很多实用的方法，能够实现很多synchronized 无法做到的细节控制，比如可以控制 fairness，也就是公平性，或者利用条件定义等。 但是，编码中也需要注意，必须要明确调用 unlock() 方法释放，不然就会一直持有该锁。 条件变量(Condition)ReentrantLock配合条件变量（java.util.concurrent.locks.Condition），可以将复杂而晦涩的同步操作转变为直观可控的对象行为。 条件变量最为典型的应用场景就是标准类库中的 ArrayBlockingQueue等，看下源码： 通过再入锁获取条件变量:1234567891011121314/** Condition for waiting takes */private final Condition notEmpty;/** Condition for waiting puts */private final Condition notFull; public ArrayBlockingQueue(int capacity, boolean fair) { if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition();} 两个条件变量是从同一再入锁创建出来，然后使用在特定操作中，如下面的 take 方法，判断和等待条件满足:1234567891011public E take() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { while (count == 0) notEmpty.await(); return dequeue(); } finally { lock.unlock(); }} 当队列为空时，试图take获取元素的线程会等待其他元素入队操作的发生，而不是直接返回，这是 BlockingQueue 的语义，使用条件 notEmpty 就可以优雅地实现这一逻辑。 那么，怎么保证入队触发后续 take 操作呢？请看 enqueue 实现：1234567private void enqueue(E e) { final Object[] items = this.items; items[putIndex] = e; if (++putIndex == items.length) putIndex = 0; count++; notEmpty.signal(); // 通知等待的线程，非空条件已经满足} 通过 signal/await 的组合，完成了条件判断和通知等待线程，非常顺畅就完成了状态流转。注意，signal 和 await 成对调用非常重要，不然假设只有 await 动作，线程会一直等待直到被打断（interrupt） 性能比较synchronized 和 ReentrantLock 的性能不能一概而论，早期版本 synchronized 在很多场景下性能相差较大，在后续版本进行了较多改进。 在低竞争场景中synchronized表现可能优于 ReentrantLock 而在多线程高竞争条件下，ReentrantLock比synchronized有更加优异的性能表现。 高竞争如果大部分情况，每个线程都不需要真的获取锁，就是低竞争；反之，大部分都要获取锁才能正常工作，就是高竞争 用法比较 Lock使用起来比较灵活，但是必须有释放锁的配合动作 Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁 Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等 特性比较ReentrantLock的优势体现在： 具备尝试非阻塞地获取锁的特性：当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁 能被中断地获取锁的特性：与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放 超时获取锁的特性：在指定的时间范围内获取锁；如果截止时间到了仍然无法获取锁，则返回 可以控制线程的竞争公平性 注意事项在使用ReentrantLock类的时，一定要注意三点： 在finally中释放锁，目的是保证在获取锁之后，最终能够被释放 不要将获取锁的过程写在try块内，因为如果在获取锁时发生了异常，异常抛出的同时，也会导致锁无故被释放。 ReentrantLock提供了一个newCondition的方法，以便用户在同一锁的情况下可以根据不同的情况执行等待或唤醒的动作。 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Java-Synchronized-ReentrantLock.html"},{"title":"final、finally、finalize","text":"final final可以用来修饰类、方法、变量，修饰对象不同所代表的意义也不同 修饰类则代表该类不可继承扩展 修饰方法则代表该方法不可重写 修饰变量则代表该变量某种程度不可更改。为什么说是某种程度呢，因为这需要根据变量的类型来区分 如果修饰的变量是基本类型，则该变量赋值一次之后就无法修改，这是final就是不可变的标志 如果修饰的变量是引用类型，那么该变量赋值一次之后，就无法修改该变量的引用，但是该引用对象的属性还是可以更改的，比较常见的就是变量引用了一个List,虽说用了final修饰，但是依然可以对该List的元素进行各种操作 将变量或参数使用final修饰可以清楚的避免意外赋值导致的编码错误 因为final修饰变量产生了某种程度的不可变的特性，所以它可以保护只读数据，因此在并发编程中使用final修饰变量有利于减少额外的同步开销，也可以省去一些防御性拷贝必要，从而提升性能 finallyfinally是java保证重点代码一定要被执行的一种机制。我们可以使用try-finally或try-catch-finally来进行类型关闭JDBC链接、保证unlock锁等操作 finalizefinalize 是基础类java.lang.Object的一个方法,它的作用是保证对象在被垃圾收集器收集前完成特定资源的回收。finalize机制现在已经不推荐使用，并且在JDK9开始被标记为deprecated。 如果调用了finalize方法，则会导致该对象称为“特殊公民”，JVM需要对它进行额外的处理。这样反而导致了finalize成为了快速回收的阻碍者，它可能导致你的对象经过多个垃圾收集周期才能被回收。 在实践中因为finalize拖慢垃圾收集，导致大量对象堆积，也是一种典型的导致OOM的原因。 因为我们要确保回收资源就是因为资源都是有限的，垃圾收集的时间不可预测，可能会极大加剧资源占用。所以对于消耗非常高频的资源，千万不要指望finalize去承担资源释放的职责。 资源用完立刻显示释放，或者利用资源池尽量重用 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Java-final-finally-finalize.html"},{"title":"Hash冲突解决方法","text":"何为Hash冲突假设Hash表大小为5(即5个槽位)，现在要把2,5,6,7,8这几个数存储到Hash表中，假设hash函数为hash(num)=num % size 简单计算下，第一个数2的hash值为2所以放到第三个槽中，第二个数5的hash值为0放到第一个槽中，第三个数6的hash值为1放到第二个槽中，如下图所示： 1号槽 2号槽 3号槽 4号槽 5号槽 5 6 2 第四个数7的hash值也为2，应该放到第二个槽位，但是第二个槽位中已经放有数据了，这种情况就属于hash冲突。简单来说，就是两个不同的数据经过hash函数计算之后得到了相同的hash值，这就叫做hash冲突。 如何解决冲突开放地址法开放地址法也称为再散列法 基本原理当关键字key的哈希地址 p=hash(key)出现冲突时，以hash值p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，然后将相应元素存入其中 基本公式12p = hash(key)h = (p + di) % m 上面的公公式中： hash(key)是根据关键字key计算得到的hash值p di是一个增量序列，根据这个增量序列取值的区分，开放地址法也有不同的区分 m是hash表的表长(表大小) 线性探测再散列当上述公式中的增量序列di的取值为递增顺序取值时即为线性探测再散列1di = 1,2,3,4,5 ... n-1,n (n &lt;= m - 1) 这种方式在发生hash冲突时，会逐步向后移动一个位置，顺序的查看下一个槽位，一直到找出下一个空的槽位或是直到查遍全表 当hash值p出现冲突时，则将数据放到(p + 1) % m处，如果此时还存在冲突，则将数据放到(p + 2) % m处，如果再次存在冲突，则将数据放到(p + 3) % m处，依次类推 二次探测再散列当di的取值规则如下时则称为二次探测再散列11*1,-1*1, 2*2,-2*2, 3*3,-3*3, ..., k*k,-k*k (k &lt;= m/2) 当hash值p出现冲突时，则将数据放到(p + 1) % m处，如果此时还存在冲突，则将数据放到(p - 1) % m处，如果再次存在冲突，则将数据放到(p + 4) % m处，如果依然存在冲突，则将数据放到(p - 4) % m处，依次类推 伪随机探测再散列当di的取值是随机数序列时则称为伪随机探测再散列12di = 随机数序列//假设有个随机数序列：2，8，3，5，11，6，7 当hash值p出现冲突时，则将数据放到(p + 2) % m处，如果此时还存在冲突，则将数据放到(p + 8) % m处，如果再次存在冲突，则将数据放到(p + 3) % m处，如果依然存在冲突，则将数据放到(p + 5) % m处，依次类推 缺点 对开放地址法构造的哈希表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点 开放地址法要求哈希表空间大于或等于装填数据数目 再哈希法这种方式是构造多个不同的哈希函数1hi = RHi(key) i=1,2,3,...,k 当哈希值hi = RH1(key)发生冲突时，再计算hi = RH2(key)….一直到不产生冲突为止。 优缺点这种方式不容易产生聚集，但是增加了计算时间 链地址法这种方法的原理是将所有哈希值为i而导致冲突的元素构成一个同义词单链表，并将单链表的头指针存在哈希表的第i个槽位中。因此对哈希值为i的元素的查找、添加、删除都是在此单链表中进行。结构如下图 优点 处理冲突简单，无堆积现象，即非同义词不会产生冲突，平均查找路径较短 链地址法中各链表的节点空间都是动态申请的，因此链地址法比较适合构造Hash表前无法确定表长的业务场景 链地址法构造的哈希表删除操作比较容易实现，只需要简单的删除链表上对应的节点即可 缺点链地址法的指针需要额外的空间 建立公共溢出区这种方法的原理是将哈希表分为基本表和溢出表两部分，凡是和基本表中元素发生冲突的元素均存入溢出表 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Java-hash-conflict.html"},{"title":"Kotlin Coroutine(协程) 基本知识","text":"Kotlin Coroutine(协程)系列：1. Kotlin Coroutine(协程) 简介2. Kotlin Coroutine(协程) 基本知识3. Android中用Kotlin Coroutine(协程)和Retrofit进行网络请求和取消请求这篇文章主要介绍协程中的一些基本概念。 挂起函数(suspend关键字) Kotlin中提供了关键字suspend用来描述一个函数为挂起函数，写法如下：1234//官方提供的函数suspend fun delay(timeMillis: Long) { ...} 以上写法就代表delay函数为一个挂起函数。 在前面一篇文章Kotlin Coroutine(协程) 简介中我提到过挂起函数只会挂起当前协程，不会挂起阻塞当前协程所处的线程。事实上，想要执行协程就至少需要一个挂起函数，因此挂起函数是协程中一个非常重要的概念。 特点 挂起函数能用普通函数的方式获取参数和返回值 调用挂起函数时，可能会挂起当前协程(如果挂起函数的相关调用已经有结果，那么系统可能会选择不挂起)，而不会挂起所在的线程。 挂起函数执行结束后，协程会自动恢复执行，此时才能继续执行挂起函数后续的代码 挂起函数只能在协程或其他挂起函数中调用，否则会编译报错 suspend可以将普通函数、扩展函数、lambda表达式均标记为挂起函数 CoroutineScope官方描述：为协程定义了一个范围 Defines a scope for new coroutines. 也可以理解为协程的上下文环境，更通俗点你可以将其看作为一个协程。 我们再来看下官方源码中的定义：123456public interface CoroutineScope { /** * Context of this scope. */ public val coroutineContext: CoroutineContext} 通过这个代码我们可以看到CoroutineScope初始定义中只有一个协程上下文CoroutineContext对象，所以协程的上下文对象其实是由CoroutineContext决定的，因此将CoroutineScope看作协程更好理解。 CoroutineContext协程上下文，包含了协程中的一些元素，主要有Job和CoroutineDispatcher Job协程的后台任务，它有自己的生命周期，该任务可以被取消。 Job可以有父Job，当父Job被取消时，其所有子Job也会被取消。 Job有三种状态: isActive 是否处于活动状态 isCompleted 是否完成 isCancelled 是否被取消 可参考下表：State | [isActive] | [isCompleted] | [isCancelled] ——————————– | ———- | ————- | ————- | New (optional initial state) | false | false | false | Active (default initial state) | true | false | false | Completing (transient state) | true | false | false | Cancelling (transient state) | false | false | true | Cancelled (final state) | false | true | true | Completed (final state) | false | true | false | 当创建协程开始执行并获取到Job对象后，如果想等该协程执行结束再执行其他的业务逻辑，那么可以调用Job.join()方法，该方法会等待该协程任务执行结束，该方法为挂起函数。 Deferred它是Job的子类，与Job不同的是它可以有返回值，而Job是没有返回值的。 通过调用Deferred的await()方法即可拿到返回值，而await()方法也是一个挂起函数，因此调用该方法时会挂起当前协程，直到拿到返回值协程重新恢复执行。 Android中协程结合Retrofit发起网络请求可以考虑使用该类获取请求结果 CoroutineDispatcher协程调度器，它可以将协程的执行局限在指定的线程中，它有四个默认的实现： Dispatchers.Default 默认调度器，在使用launch和async等协程构造器创建协程时，如果不指定调度器则会使用此默认调度器，该调度器会让协程在JVM提供的共享线程池中执行 Dispatchers.Main 主线程调度器，让协程在主线程即UI线程中执行 Dispatchers.IO 让协程在IO线程(子线程)中执行，该调度器会与Dispatchers.Default调度器共享同一个线程池 Dispatchers.Unconfined 该调度器不指定协程在某个线程中执行。设置了该调度器的协程会在调用者线程中启动执行直到第一个挂起点，挂起后，它将在挂起函数执行的线程中恢复，恢复的线程完全取决于该挂起函数在哪个线程执行。 newSingleThreadContext 这是Kotlin另外提供的一个调度器，它会为协程启动一个新的线程。一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 close 函数，或存储在一个顶级变量中使它在整个应用程序中被重用。 另外需要注意的是：协程调度器默认承袭外部协程的调度器。 GlobalScope这是一个全局的CoroutineScope不会受任何Job约束，通过它创建的是全局协程，它会在整个应用的生命周期中运行，不能被取消 launch函数这是一个扩展的CoroutineScope实例方法，同时也是一个很常用的协程构建器。 通过其默认参数会创建一个不会阻塞当前线程且会立即执行的协程，该方法会返回一个Job对象，该方法默认承袭所在的CoroutineScope对象的调度器。 1234val scope = CoroutineScope(Dispatchers.Main + Job())scrope.launch { //协程实现} 上述代码通过launch创建的协程会在UI线程中执行 1234val scope = CoroutineScope(Dispatchers.Main + Job())scrope.launch(Dispatchers.IO) { //协程实现} 上述代码通过launch创建的协程会在IO线程中执行 runBlocking这是一个全局的协程构建器，可以在任何地方调用。 该构建器会创建一个阻塞当前线程的协程，所以该构建器不建议使用在协程内。 async和launch函数一样，也是CoroutineScope的扩展实例方法，它也是一个常用的协程构建器，不同是它创建协程时返回的是Deferred,通过Deferred可以拿到执行结果123456789val a = async { log(\"I'm computing a piece of the answer\") 6}val b = async { log(\"I'm computing another piece of the answer\") 7}log(\"The answer is ${a.await() * b.await()}\") delay全局函数 让协程休眠指定时间，类似于Java中的Thread.sleep的作用 delay是一个挂起函数，调用后不会阻塞挂起当前线程 当协程的休眠时间到了之后，当前所处协程会重新恢复执行 withContext切换协程上下文，一般主要用来切换协程所在的线程环境，如从主线程切换到IO线程。 调用该方法不会创建新的协程，同时是一个挂起函数 该方法会有一个返回值，其返回值为withContext中lambda表达式的返回值 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Kotlin-Coroutine-Basic-Knowledge.html"},{"title":"Kotlin Coroutine(协程) 简介","text":"Kotlin Coroutine(协程)系列：1. Kotlin Coroutine(协程) 简介2. Kotlin Coroutine(协程) 基本知识3. Android中用Kotlin Coroutine(协程)和Retrofit进行网络请求和取消请求 协程介绍 协程是可挂起计算的实例。 它在概念上类似于线程，在这个意义上，它需要一个代码块运行，并具有类似的生命周期，它可以被创建和启动，但它不绑定到任何特定的线程。 它可以在一个线程中挂起其执行，并在另一个线程中恢复。而且，像future 或 promise那样，它在完结时可能伴随着某种结果（值或异常） 协程开发人员这样描述协程： 协程就像非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。 如上面所说，协程是由开发者自己控制的，因此在使用协程时我们一定要记住一点，我们必须知道我们使用的协程在何时挂起，它又在何时重新恢复执行，如果没法知道这两点，那就意味着我们无法控制协程，这个时候要慎用协程。 为什么使用协程使用协程可以提高线程的利用率。通常我们在Android中发起一个网络请求都会经历如下几步： 在主线程中创建一个请求任务，如：Retrofit.Call 为这个任务分配一个子线程去执行请求任务，如：调用Retrofit.Call.enqueue(callback)方法 子线程发起请求后将会阻塞等待网络请求的返回结果，拿到结果后会将数据转换成我们需要的实体对象 在主线程中执行回调接口，执行余下的业务操作 上面的流程中为请求任务分配子线程一般都会配合线程池去做，以防止不断创建线程而产生系统开销，但在线程真正执行过程中经常会遇到因磁盘IO或者是网络请求等操作而导致线程阻塞，而此时当前线程只能阻塞等待，无法做任何事情，在等待的这段时间里线程相当于白白了浪费了自身资源，导致线程自身利用率低下。 在Android中改用协程发起网络请求流程如下： 在主线程中创建一个协程，在协程中创建网络请求任务 为协程分配一个子线程去发起网络请求 挂起子线程中的协程，此时仅仅是协程挂起，该子线程并没有挂起阻塞 协程等待请求结果回来之后，会在子线程中重新恢复协程执行 在主线程中执行某个回调，拿到请求数据执行余下的业务操作 在上述流程步骤3中挂起协程后子线程并不会阻塞，此时该子线程可以被系统分配去做其他的事情，当协程挂起结束时重新在子线程中恢复执行。这样该线程就不会存在因阻塞导致的空闲浪费，提高了线程利用率。 总的来说，使用协程可以最大程度的复用线程，通过让线程满载运行，从而达到充分的利用CPU提高系统性能。 告别回调地狱使用协程另外一个好处就是可以让开发者们告别异步编程中的回调地狱，简化异步编程，让写异步代码和写同步代码一样简单，增强了代码的可读性、可理解性和可维护性。 举个例子假定有个登录有如下流程： 发请求获取用户token 根据token获取用户信息 常用实现方式代码如下：1234567fun login() { requestToken { token -&gt; requestUserInfo(token) { user -&gt; Log.i(\"tag\", user.toString()) } }} 上面的例子是Android开发中经常会遇到的问题，一个请求依赖前一个请求的结果，这个时候经常会出现这样的写法，在第一个请求的成功回调中根据请求结果发起第二个网络请求。这里还只存在两层的嵌套，试想一下，如果嵌套层次出现4次，5次，甚至更多会出现怎样的情况，估计开发者自己写起来都会崩溃。 使用RxJava实现代码如下：123456Single.fromCallable { requestToken() } .map { token -&gt; requestUserInfo(tokenm) } .subscribe( { user -&gt; Log.i(\"tag\", user.toString()) }, // onSuccess { e -&gt; e.printStackTrace() } // onError ) 使用RxJava的实现方式虽然将回调嵌套改成了链式写法，阅读起来要稍微好点，但是依然存在回调而且增加了实现的复杂度，对不熟悉RxJava的人来说更少增加了难度。 使用协程实现方式代码如下：12345fun login() { val token = requestToken() val user = requestUserInfo(token) Log.i(\"tag\", user.toString())} 怎么样，使用协程的写法是不是简便很多，而且看起来非常符合人们的阅读和理解习惯。 Android中使用协程示例自己写了一个Android使用协程配合Retrofit发起网络请求的Demo，主要包含了如下内容： 如何将Kotlin Coroutine(协程)和Retrofit结合使用 如何在Kotlin Coroutine(协程)切换协程所在线程 如何在Kotlin Coroutine(协程)中将两个请求结果进行合并 Kotlin Coroutine(协程)中如何实现并发请求 MVP开发模式中如何在Presenter生命周期结束时优雅的取消协程 如何将一个普通异步操作改造为协程中的挂起函数 代码地址：https://github.com/huyongli/AndroidKotlinCoroutine 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Kotlin-Coroutine-Guide.html"},{"title":"记一次9.png的填坑之旅","text":"最近在项目中进行界面调整时遇到了一个9.PNG图引起的View的padding值不正常导致UI显示不符合预期结果的问题。这篇文章就来记录我当时遇到的问题的表现形式，以及如何根据问题找到产生问题的原因，及其最后的解决办法。 问题表现形式不多说，直接上出现问题的视图表现形式的截图： 我的实现上图中我实现的是一个ListView，同时自定义实现一个视图Png9View extends FrameLayout作为ListView的item视图，为每个item设置灰色背景色。Png9View视图中的白色部分是一个线性布局，并为线性布局顶部添加了一个蓝色的分割线，其底部添加了一个红色的分割线，中间是一个TextView。 大家可以看下item视图实现代码如下，整个Demo的代码在这里https://github.com/huyongli/AndroidDemo：12345678910111213141516171819202122public class Png9View extends FrameLayout { private LinearLayout mContainer; public Png9View(Context context) { this(context, null); } public Png9View(Context context, AttributeSet attrs) { this(context, attrs, 0); } public Png9View(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); init(context); } private void init(Context context) { LayoutInflater.from(context).inflate(R.layout.png_9_view, this, true); mContainer = (LinearLayout) findViewById(R.id.root); setBackgroundColor(getResources().getColor(android.R.color.darker_gray)); mContainer.setBackgroundResource(R.drawable.bg); }} png_9_view布局代码如下：123456789101112131415161718192021222324252627&lt;merge xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;LinearLayout android:id=\"@+id/root\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\"&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"1dp\" android:background=\"@android:color/holo_blue_dark\"/&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:layout_margin=\"10dp\" android:background=\"@color/colorAccent\" android:textColor=\"@android:color/white\" android:gravity=\"center_vertical\" android:text=\"测试视图标题\"/&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"1dp\" android:background=\"@android:color/holo_red_dark\"/&gt; &lt;/LinearLayout&gt;&lt;/merge&gt; ListView的布局如下：1234567&lt;ListView android:id=\"@+id/listView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:dividerHeight=\"0dp\" android:divider=\"@null\"&gt;&lt;/ListView&gt; 问题？通过上面的效果截图我们很容易发现在第一个Png9View的底部红色分割线和第二个Png9View的顶部蓝色分割线中还有一小段灰色的间隔，而这个灰色间隔显然与我的期望效果不一样，那这个灰色间隔是哪里来的呢？我的代码里好像没有任何设置会出现这样的效果啊。 问题分析出现上面的问题后我第一个想到的就是打开开发者模式中显示布局边界，结果竟然发现这个灰色间隔是Png9View的一部分，而其颜色也刚好与Png9View的背景色相同，但我并没有为LinearLayout视图设置过margin啊，ListView也没有设置过divider，所以看到这个现象时感到很奇怪。想了会也没想出个所以然来，很是费解啊~~~ 后来想到在Android Studio 2.2.2中有个新工具Layout Inspector(该工具在Tools -&gt; Android -&gt; Layout Inspector)可以进行UI分析，于是用该工具对界面进行分析最后发现了问题的原因，大家看下我对上面的界面进行分析的截图： 上面的图中，我选中的是Png9View的布局文件中的id为root的LinearLayout(左边圈中的)，右边圈的是该布局的相关属性值信息，可以看到该线性布局有的paddingBottom属性值为5，而我也并没有为该LinearLayout设置过margin属性值，那这个值是怎么来的呢？ 这个时候我就只能想到该线性布局设置的背景图片bg.9.png了这个地方了。于是我就猜想难道是因为设置了这个.9图才导致了这个问题？为了验证我的猜想，于是我就直接将背景换成了一个颜色作为背景，结果发现就正常了。到这里基本上就可以肯定这个问题就是9.png图干的好事了。 给大家看下我设置的这个图片是什么样的 解决办法因为我们项目中这个.9图本身就是为了达到白色的效果，所以我直接用背景颜色代替图片作为背景图解决了我的这个问题，这样还可以减少图片资源。 疑问看了上面的分析之后，可能大家会问另外一个问题，既然这个paddingBottom值是属于LinearLayout的，那为什么会产生margin的效果呢？padding应该是当前布局的内容距离当前布局的边距，那也应该是白色啊，怎么这个padding区域显示的却是其父布局Png9View的背景色呢，怎么就产生了margin的效果呢？ 大家伙别急，原因且待下篇分解。。。 write by laohu2016年11月5日15:14:09 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/My-9.png-hold-the-fat-lady-tour.html"},{"title":"React Native学习问题记录","text":"最近做了一个RN的项目，RN小白，自然遇到了不少问题，这里记录一下。 命令行下启动IOS版本时出现如下错误： 1xcrun: error: unable to find utility &quot;instruments&quot;, not a developer tool or 这个是装完xcode后模拟器无法识别的问题，解决办法是在终端下执行如下命令： 12345 sudo xcode-select -s /Applications/Xcode.app/Contents/Developer/ ``` 2. 终端命令启动某个APP时，出现红屏错误，而上面显示的错误信息表明加载代码的路径与当前要运行的代码路径不相符。这个错误应该是你上一次运行了另外一个APP，而当你再次运行第二个不同的APP时没有把上一个APP的终端监听给关掉。此时只需要关闭react-native start的监听终端即可，然后重启APP3. 在使用`react-devtools`查看APP的布局结构时，出现如下信息而无法链接上APP Waiting for React to connect 1在终端下执行如下命令，然后重启`react-devtools`即可 adb reverse tcp:8097 tcp:8097 1234564. `ScrollView`中`TextInput`的焦点问题。当`ScrollView`中存在`TextInput`时，当输入完文字后，`TextInput`会还占用焦点，导致`ScrollView`内的其他元素需要点击两次才能起作用，这时需要设置`ScrollView`的如下属性：`keyboardShouldPersistTaps=&quot;handled&quot;`即可5. 针对软键盘遮挡问题，我试了几种方案，发现下面两种方案比较简单有效： - RN官方提供的`KeyboardAvoidingView`方案最简单有效 - 另外一种方案是自己监听软键盘的打开与关闭然后结合`Animated`动画来实现软键盘的遮挡问题，这种方案比较灵活6. IOS启动指定版本模拟器: `react native run-ios --simulator &quot;iPhone X&quot;`7. Android打包失败，信息如下： What went wrong:Execution failed for task ‘:app:bundleReleaseJsAndAssets’. A problem occurred starting process ‘command ‘node’’ 1这个错误的可能原因是gradle deamon的缓存问题，关掉cradle deamon，重新再执行一次就可以解决 ./gradlew –stop` 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/RN-Problem-Record.html"},{"title":"RecyclerView子View宽度不充满父容器","text":"今天用RecyclerView写了简单的例子，使用的是LinearLyaoutManager，子View采用的TextView，准备写个简单的List展示，我的RecyclerView和TextView的宽度布局都采用的是match_parent，结果显示出来之后发现子View的宽度压根就没有充满屏幕。之前也用过RecyclerView，但是没有遇到过这个问题，很不解啊~~~网上查阅之后说是在Adapter的onCreateViewHolder方法中构造View的时候不能用如下方式：1View.inflate(mContext, R.layout.item_layout, null); 必须要换成下面的构造方式把parent带进去：1LayoutInflater.from(mContext).inflate(R.layout.item_layout, parent, false); 而我的Adapter中刚好就使用的是第一种方式，于是立马换成下面的第二种方式实现，运行看效果，果然充满了屏幕~~~这个问题还真是奇葩啊~ 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/RecyclerView子View宽度不充满父容器.html"},{"title":"Retrofit2使用介绍","text":"前言对于还不知道Refrofit是什么的同学，我只能说你们太out了，赶紧去Google下，本文是针对Retrofit2.0的使用介绍，当然大家也可以直接去官网上去看使用介绍 添加依赖要使用Retrofit首先得添加gradle依赖12compile &apos;com.squareup.retrofit2:retrofit:2.0.2&apos;compile &apos;com.squareup.retrofit2:converter-gson:2.0.0&apos; 声明服务接口依赖添加完成之后，就可以开始撸代码了，首先我们要新建一个Interface，这个接口就是你要请求的接口服务类，就像这个样子 123456public interface RetrofitService { @GET(\"getModelService\") Call&lt;User&gt; getModelService(); ...} 上面这个接口中暂时只声明了一个方法，而在Retrofit中想这样声明的一个方法就代表了一个具体的Http请求接口。Retrofit中方法上添加@GET注解就表示当前方法代表一个Get请求，我们声明的这个请求方法不带任何参数，且返回结果是User对象。@GET注解括号中的值getModelService就代表http请求地址的具体指向，这个值与下面baseUrl中配置的URL一起组成一个完整的请求地址Retrofit就是这么任性，它可以帮我们把http的请求结果自动转换成Javabean对象，这将为我们减少不少编码工作。 构造Retrofit对象接口服务声明完成之后，我们接着需要新建一个Retrofit对象12345Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://localhost:8080/AndroidService/\") .addConverterFactory(GsonConverterFactory.create()) .build();RetrofitService service = retrofit.create(RetrofitService.class); 通过上面的代码我们就创建了一个Retrofit对象，同时通过这个Retrofit对象将我们前面声明的服务接口进行了实例化，有了这个服务接口实例化对象，我们就可以调用接口里面声明的方法进行http请求了。 另外需要说明是我们在设置baseUrl的时候一般在都是以/结尾，而不是在接口方法中的url以/开头 前面说的Retrofit会将请求结果自动转换成Javabean对象，其实这个是需要配置结果转换器的，就像上面我配置的addConverterFactory(GsonConverterFactory.create())，配置了这个转换器工厂之后，就会将请求得到的JSON数据自动转换成Javabean对象。同样如果请求得到的数据是xml类型的话，转换成Javabean对象则需要配置成其他类型的转换器 Retrofit其实已经为我们提供了多种转换器供我们选择： Gson: com.squareup.retrofit2:converter-gsonJackson: com.squareup.retrofit2:converter-jacksonMoshi: com.squareup.retrofit2:converter-moshiProtobuf: com.squareup.retrofit2:converter-protobufWire: com.squareup.retrofit2:converter-wireSimple XML: com.squareup.retrofit2:converter-simplexmlScalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars 同步请求前面准备工作都完成了，ok，可以开始发起请求了12345Call&lt;User&gt; call = service.getModelServiceSync();Response&lt;User&gt; response = call.execute();if(response.isSuccessful()) { User user = response.body();} 这就是Retrofit的基本使用流程：添加依赖–&gt;声明接口–&gt;创建Retrofit和接口对象–&gt;选择执行同步异步请求 异步请求同步请求执行call.execute()即可，异步请求则是这样：12345678910111213call.enqueue(new Callback&lt;User&gt;() { @Override public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) { if(response.isSuccessful()) { User user = response.body(); } } @Override public void onFailure(Call&lt;User&gt; call, Throwable t) { }}); 带参Get请求如果要实现带参数的Get请求，则需要将我们上面的方法声明改成如下形式12@GET(\"getModelService\")Call&lt;User&gt; getModelService(@Query(\"param1\") boolean param1, @Query(\"param2\") boolean param2); Retrofit中我们只需要将要传输到服务端的参数添加@Query注解即可，而@Query注解括号中的值param1和param2则是对应的参数名 Retrofit也为我们提供了另外一种形式，使用@QueryMap注解来声明一个集合作为请求参数12@GET(\"getModelService\")Call&lt;User&gt; getModelService(@QueryMap Map&lt;String, String&gt; parmas); 动态URL如果我们有两个这样的请求地址12http://localhost:8080/AndroidService/user/zhangsanhttp://localhost:8080/AndroidService/user/lisi 这两个请求地址很明显，除了最后的一段不一样其他的都一样。因此如果按照上面的做法的话，我们要请求这两个服务就需要声明两个接口方法，如果这两个请求地址没有其他参数的话声明两个接口方法不是感觉很累赘，所以Retrofit为我们提供了动态构造URL的方式来声明类似请求地址的接口方法。12@GET(\"user/{path}\")Call&lt;User&gt; getModelService(@Path(path) String path, @Query(\"param1\") boolean param1, @Query(\"param2\") boolean param2); 上面的方法中，@GET注解中{path}就代表URL可以动态变化的那一部分，@Path注解则表示该方法参数的值就是{path}中的动态值 Post请求123@FormUrlEncoded@POST(\"postService\")Call&lt;String&gt; postModelService(@Field(\"msg\") String msg, @Field(\"string\") boolean isString); Retrofit中的Post请求则需要将前面的@GET注解换成@POST注解，而Post请求的文本参数则用注解@Field来声明，同时还必须给方法添加注解@FormUrlEncoded来告知Retrofit参数为表单参数，如果只为参数增加@Field注解，而不给方法添加@FormUrlEncoded注解运行时会抛异常。 如果Post请求有很多参数同样也可以使用集合的方式进行声明123@FormUrlEncoded@POST(\"{path}\")Call&lt;User&gt; postModelService(@Path(\"path\") String path, @FieldMap Map&lt;String, String&gt; map); Retrofit中提供了注解@FieldMap用来声明一个Map类型的集合作为Post请求的表单参数 Post请求的服务接口声明完成之后，讲得到的Call对象调用execute或者enqueue即可发起同步或异步的Post请求 以上就是Retrofit2的基本使用，下一篇文章我讲接着介绍Retrofit2中的文件上传和文件下载，以及如何实现文件上传和下载过程中的进度条 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Retrofit2使用介绍.html"},{"title":"TextSwitcher与ViewSwitcher学习笔记","text":"TextSwitcher和ViewSwitcher是什么，有什么用呢？ 其实大家从名字就可以看出来其大概意思，TextSwitcher是用来切换文本显示的，而ViewSwitcher是用来切换视图显示的，实际上他们也的确是用来做这个的，只不过他们在切换视图显示的时候允许添加切换的动画效果。TextSwitcher其实也是ViewSwitcher的子类实现。 TextSwitcher使用我们先来看看TextSwitcher的用法：关键布局代码如下：123456789&lt;Button android:id=\"@+id/button\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"change\"/&gt;&lt;TextSwitcher android:id=\"@+id/switcher\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"/&gt; Java代码如下： 12345678910111213141516171819202122232425262728//设置显示Text文本的View创建工厂//这是通过代码的方式创建显示文本的视图，也可以直接在布局中设置显示文本的视图，这个在讲ViewSwitcher的用法的时候再说mTextSwitcher.setFactory(new ViewSwitcher.ViewFactory() { @Override public View makeView() { TextView t = new TextView(TextSwitcherActivity.this); t.setGravity(Gravity.TOP | Gravity.CENTER_HORIZONTAL); t.setTextAppearance(TextSwitcherActivity.this, android.R.style.TextAppearance_Large); return t; } }); Animation in = AnimationUtils.loadAnimation(this, android.R.anim.fade_in); Animation out = AnimationUtils.loadAnimation(this, android.R.anim.fade_out); mTextSwitcher.setInAnimation(in);//设置文本出现动画 mTextSwitcher.setOutAnimation(out);//设置文本消失动画 mTextSwitcher.setCurrentText(String.valueOf(mCount));//设置初始值，初始值不显示动画 int mCount = 0; mButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { mCount++; mTextSwitcher.setText(String.valueOf(mCount));//更新文本显示值，会出现动画 } }); 当你点击界面上的按钮的时候，会不断的更新TextSwitcher的显示值，而在更新过程中文本会出现一个淡入淡出的效果，这个效果就是通过动画产生的。 ViewSwitcher使用接着我们再来看看ViewSwitcher的使用布局代码： 1234567891011121314151617181920&lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;20dp&quot; android:text=&quot;change&quot;/&gt;&lt;ViewSwitcher android:id=&quot;@+id/viewSwitcher&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;ImageView android:layout_width=&quot;300dp&quot; android:layout_height=&quot;300dp&quot; android:src=&quot;@drawable/image1&quot;/&gt; &lt;ImageView android:layout_width=&quot;300dp&quot; android:layout_height=&quot;300dp&quot; android:src=&quot;@drawable/image2&quot;/&gt;&lt;/ViewSwitcher&gt; 上面的布局中我们给ViewSwitcher添加了两个子视图，注意这里只能添加两个直接子视图，否则初始化会出现异常，至于原因后面接着说。前面说过TextSwitcher也可以通过布局设置文本显示视图，它的设置方式与ViewSwitcher其实也是一样的。 ok，接着上Java代码 12345678910111213//因为我们已经通过布局的方式设置了要切换的视图，所以就不需要再设置Factory去生成切换视图了Animation slide_in_left = AnimationUtils.loadAnimation(this, android.R.anim.slide_in_left);Animation slide_out_right = AnimationUtils.loadAnimation(this, android.R.anim.slide_out_right);mViewSwitcher.setInAnimation(slide_in_left);//设置图片出现动画mViewSwitcher.setOutAnimation(slide_out_right);//设置图片消失动画mButton2.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { mViewSwitcher.showNext(); }}); 上面就是ViewSwitcher的使用方式，其实用起来还是很简单的。通过自定义动画，我们可以为两个View切换时添加更多漂亮有趣的动画效果 使用场景在Android开发中视图切换显示还是很常见的，比如应用加载数据时显示加载动画视图数据视图隐藏，而加载成功后加载动画视图隐藏数据视图显示，这个场景使用ViewSwitcher来实现应该会更简单，更方便。 源码探究 前面说到过ViewSwitcher只能存在两个直接子视图，否则会初始化失败，这是为什么呢？通过源码我们可以找到答案 1234567@Overridepublic void addView(View child, int index, ViewGroup.LayoutParams params) { if (getChildCount() &gt;= 2) { throw new IllegalStateException(&quot;Can&apos;t add more than 2 views to a ViewSwitcher&quot;); } super.addView(child, index, params);} 在前面ViewSwitcher的使用中我们点击按钮的时候直接调用了mViewSwitcher.showNext();，既然只能有两个子视图，那我们每次点击都showNext()怎么会没出现越界异常呢？ok，我们还是看看源码中是怎么实现的 123456789101112131415161718192021@android.view.RemotableViewMethodpublic void showNext() { setDisplayedChild(mWhichChild + 1);}@android.view.RemotableViewMethodpublic void setDisplayedChild(int whichChild) { mWhichChild = whichChild; if (whichChild &gt;= getChildCount()) { mWhichChild = 0; } else if (whichChild &lt; 0) { mWhichChild = getChildCount() - 1; } boolean hasFocus = getFocusedChild() != null; // This will clear old focus if we had it showOnly(mWhichChild); if (hasFocus) { // Try to retake focus if we had it requestFocus(FOCUS_FORWARD); }} 通过上面的实现我们可以看到当其显示的child索引出现越界之后，会自动的进行循环显示，这也是为什么一直调用showNext()没出现越界异常的原因 切换原理我们再来看看其切换显示过程中视图的显示和隐藏及动画是如何实现的12345678910111213141516171819void showOnly(int childIndex, boolean animate) { final int count = getChildCount(); for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (i == childIndex) { if (animate &amp;&amp; mInAnimation != null) { child.startAnimation(mInAnimation); } child.setVisibility(View.VISIBLE); mFirstTime = false; } else { if (animate &amp;&amp; mOutAnimation != null &amp;&amp; child.getVisibility() == View.VISIBLE) { child.startAnimation(mOutAnimation); } else if (child.getAnimation() == mInAnimation) child.clearAnimation(); child.setVisibility(View.GONE); } }} 上面的代码实现也很简单，当显示指定索引的child时，将其设置为可见并执行mInAnimation，其他视图在设置为不可见并执行mOutAnimation动画 Factory作用原理123456789101112131415public void setFactory(ViewFactory factory) { mFactory = factory; obtainView(); obtainView();}private View obtainView() { View child = mFactory.makeView(); LayoutParams lp = (LayoutParams) child.getLayoutParams(); if (lp == null) { lp = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT); } addView(child, lp); return child;} 通过源码实现我们可以知道mTextSwitcher.setFactory(mFactory)设置完成之后，ViewSwitcher会立刻生成两个视图作为其子视图作为切换显示用。 示例代码在这里：https://github.com/huyongli/AndroidDemo 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/TextSwitcher-ViewSwitcher.html"},{"title":"WordPress安装插件提示无法创建目录","text":"出现这个问题有几种可能： 服务器没有安装vsftpd服务，很明显我装了 vsftpd的用户没有对plugin目录的写权限，检查之后发现我新建的用户是有这个权限的 如果没有写权限的话，需要对WordPress的目录 /var/www/html/wp-content/plugins赋予写权限的，我们来个直接的运行命令： chmod 777 /var/www/html/wp-content/plugins，主要是的第三个7起作用，对其他用户赋予读写权限 最后检查发现我的vsftpd.conf配置文件中 chroot_local_user的值设置成了No， 该配置表示我的本地Ftp用户不能切换到ftp主目录外的其他目录，而我的ftp主目录与WordPress的Plugin的目录明显不是同一个。既然该用户都不能切换目录，如何到Plugin目录进行写操作呢，所以立马更改该配置为YES，再次安装插件就成功了 另外，如果还不行的话可以检查下vsftpd.conf配置文件中 chroot_list_enable的值，如果chroot_list_enable=YES该配置表示 /etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录。 chroot_local_user配置与chroot_list_enable配置通过搭配能实现以下几种效果： ①当chroot_list_enable=YES，chroot_local_user=YES时，在/etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录；未在文件中列出的用户，不能切换到其他目录。 ②当chroot_list_enable=YES，chroot_local_user=NO时，在/etc/vsftpd.chroot_list文件中列出的用户，不能切换到其他目录；未在文件中列出的用户，可以切换到其他目录。 ③当chroot_list_enable=NO，chroot_local_user=YES时，所有的用户均不能切换到其他目录。 ④当chroot_list_enable=NO，chroot_local_user=NO时，所有的用户均可以切换到其他目录 如果WordPress上传多媒体文件(图片)时提示无法建立目录wp-content/uploads…，则可以将目录 /var/www/html/wp-contents的权限也赋予为读写权限 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/WordPress安装插件提示无法创建目录.html"},{"title":"WordPress安装插件提示无法定位WordPress内容目录（wp-content）","text":"在我刚把WordPress环境搭建好后，安装插件的时候提示如下错误信息： WordPress安装插件提示无法定位WordPress内容目录（wp-content），最后找网上搜索之后，发现下面的方法可行： 在WordPress配置文件 wp-config.php最后加上如下代码： 123//-----无法定位WordPress Content目录(wp-content) 解决方案---------begin if(is_admin()) {add_filter('filesystem_method', create_function('$a', 'return \"direct\";' ));define( 'FS_CHMOD_DIR', 0751 );} //-----无法定位WordPress Content目录(wp-content) 解决方案---------end 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/WordPress安装插件提示无法定位WordPress内容目录（wp-content）.html"},{"title":"整洁代码的理解","text":"前段时间看了《代码整洁之道》这本书，书中的一些观点讲的很不错，这些观点很容易让人对号入座，也很容易让人知道自己写的代码是否漂亮、是否整洁。通过这篇文章记录下读后感和书中的一些观点。 为什么要整洁代码 很多时候我们修复bug或开发新功能时都会先看看周边的相关代码(开发过程中经常碰到前面写的代码到后面就忘了，回看代码是常事)，如果想要bug或新功能写的轻松那自然就要求代码阅读也轻松。不整洁的代码阅读起来会轻松吗。 相信很多人都不愿意去接手别人写的二手代码，为什么呢，因为很多人写的代码质量很一般，让其他的人阅读他的代码很是困难。所以整洁的代码也能帮助其他人轻松的理解自己的代码。 整洁代码核心思想如何在意代码这跟生活是一个道理，当你真正在意某件事情的时候，在意到什么程度，事情在意程度不一样，对事情的处理态度和方式也不一样。所以只有你真正的在意你写的代码，你才会去关注代码的质量，写出整洁漂亮的代码。 我有一个Android开发的QQ群，经常在群里听到有人说公司领导不在乎代码质量和实现过程，只关注结果，所以他们也不关注自己写的代码是否漂亮是否整洁，只求赶快完成功能交差。我相信有很多这样的程序员都是这样，只追求功能实现，从来不管代码写的怎么样，因为他们不注重自己写的代码怎么样，他们只看重自己能不能在规定时间内向领导交差。 天敌：后面再优化很多程序员都有一个习惯，经常会说：先实现目前的功能，等后面有时间了再来优化代码。其实大家也知道结果了，基本上大部分的人后面都不会去做什么代码优化，前面的说辞也变成了说说而已。 所以写代码的时候如果当时能写出更好的代码就当时一次性写好，不要想着以后再去优化，这基本是不可能的了。时间长了就会在不知不觉中养成习惯，如果每次都想着以后再优化，那每次写代码基本上都不会去关注代码的质量，相反每次编码都尽自己最大努力去写好，时间长了你的代码质量和要求自然就上去了。 什么样的代码是整洁代码 代码逻辑一目了然，很清楚方法、类、模块做的是什么事情 整洁的代码只专注于做好一件事(不论是方法、类还是模块)，处理的事情多了，自然就会让逻辑变的复杂 让代码块小，小块的代码便于阅读和理解 尽量减少依赖，让代码便于维护 性能调至最优，省得引诱做没规矩的优化，搞出一堆混乱代码来 依据某种分层战略完善错误处理代码 如何写出整洁代码减少重复代码当代码中一段代码多次出现的时候，就表示某种想法没有在代码中得到良好的体现。所以减少重复代码以提高代码表达力，尽早构建简单抽象。 使用异常代替错误码错误码通常是枚举或者是常量，而这样的错误码就像磁铁一样，导致所有用到这些错误码类都需要导入引用它，一旦错误码需要修改就需要修改所有的这些类。而使用异常则不会存在这些问题，新异常可以从异常类里直接派生出来，而不需要修改已有代码。 有意义的命名命名要名副其实选一个好的名称是比较耗费时间的，但是一旦选对了名称那省下的时间是很可观的。类名、变量名、方法名应该就可以答复大部分的问题，例如它做了什么事，怎么做。如果名称需要注释来补充，那就不算名副其实。 避免误导 例如：字母l和数字1，字母o和数字0，这两种就很容易让人傻傻分不清 不要使用外形太像的命名方式，比如：ControllerForEfficientHandlingOfStrings和ControllerForEfficientStorageOfStrings，这种名称很长又只有细微差别的命名方式很容易迷惑 不要使用有特殊意义的字符串来命名。做有意义的区分12345public static void copyChars(char a1[], char a2[]) { for(int i = 0; i &lt; a1.length; a1++) { a2[i] = a1[i]; }} 上面的代码虽然很简单，但是命名方式还是很有问题的，如果把参数名分别改为source和destination对整个方法的实现来说就要清晰很多 使用读得出来的名称命名的时候尽量使用大众熟知的单词，不要使用自造词、拼音单词混用或是自己偷懒将单词进行简写之类，这样的命名只会增加代码的阅读负担，让人看的云里雾里。 使用可搜索的名称在阅读代码的过程中常用的功能就是搜索，所以一个方便搜索的名称还是很重要的。比如一个字符串最大长度只允许为7，代码中有好几个地方需要做这种判断，但是经常就有人偷懒直接使用数字7进行判断，那在代码搜索的时候是搜索7容易还是搜索MAX_LENGTH_SEVEN容易，答案很明显了。 对于搜索来说，长名称胜于短名称，搜得到的名称胜于用自造编码代写的名称。 类名、函数名 类是对一类具有共同特征的事物的抽象，所以类和对象名应该是名称或名词短语，而不应该是动词 方法通常是完成了一件什么事，所以方法名应当是动词或动词短语。 函数 让函数表达其意图，该给函数赋予哪些属性，好让读者一看就知道函数是什么样的程序 函数第一规则就是要短小、尽量的短小 很多人在看别人的代码的时候一旦遇上很长的函数，心理就开始打退堂鼓了，为什么呢？其实很重要的一个原因就是因为长函数的实现逻辑都弄的比较复杂，而且这个函数可能做了好几件事，阅读起来会让人很吃力。而短小的函数一眼看上去逻辑就比较清晰简单，至少阅读的人心理上就要好受很多。 函数只做一件事 每个函数应该只做一件事，如果一个函数实现里做了多件事，那势必会让这个函数变的比较长。 函数参数尽量少 输出参数比输入更难以理解，尽量以返回值作为输出 很多人在方法实现的时候喜欢将List作为方法参数输入而方法返回类型为void(在Android开发中尤其多)，然后在方法实现里修改List的元素，后面直接用这个List作为修改后的List。这种写法稍不注意就会引发bug，而且不容易被发现。 不要用标记参数(boolean) 使用标记参数会增加函数的理解度和复杂度。一旦使用标记参数，就意味着你的函数实现里其实是做了两件不同的事。 将多个参数封装成一个类 如果一个函数有多个参数的话，就需要考虑将这些参数封装成一个类，使用对象作为参数输入了。 不要在函数中做函数名以外的事情 抽离try-catch代码块 处理错误异常也是一件事，所以要抽离 将被调用函数的实现直接定义在调用者的下方 使用这种方式方便阅读，避免阅读过程中来回的代码切换。 在web开发中jslint有条规则是将方法安装字母顺序进行排序，我个人不太认可这种方式，我认为将被调用函数的实现直接定义在调用者的下方这种方式比较好。 避免急于求成编码的时候先按照思路实现，然后再斟酌打磨，按照规则打磨出整洁的代码。要想一次就写出完美的代码是不太可能的。先按思路实现，等你实现完可能就会发现有更好的实现方式，或者是更好的命名，这时慢慢的斟酌，慢慢的修改。 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Thinking-Code-Clean.html"},{"title":"Hexo搭建静态博客","text":"前言前段时间因为我的WordPress博客进入后台非常慢，严重影响操作使用，再加上服务器时间的限制，所以就讲博客从WordPress迁移到了Hexo上，这篇文章记录下我创建Hexo博客的一些流程步骤。 HexoHexo是一个简单地、轻量地、基于NodeJS的一个静态博客框架，可以方便的生成静态网页托管在github或者是国内的coding.net上 Github PagesGitHub Pages 可以被认为是用户编写的、托管在github上的静态网页。因为Github的空间免费稳定， 因此可以用于将自己的静态站点托管在github上来搭建自己的个人博客站点。另外国内的coding.net也支持Pages服务，同样可以进行托管静态网页。 Github上生成的网站的默认域名一般都是username.github.io，这里的username是指你在github上注册的用户名，当然github的网站也支持自定义绑定域名。 安装Git因为我们要将最终的静态网页文件推送到github上，所以第一步我们需要先在机器上安装Git，Git下载地址：https://git-for-windows.github.io/，安装完成之后配置好相关全局参数，如user，email等 安装NodeJS因为Hexo是基于NodeJS的，所以还需要安装NodeJS，下载地址：http://nodejs.org/ 安装Hexo在磁盘上任意目录下右键鼠标选择Git Bash，使用如下命令进行Hexo的安装npm install -g hexo 创建Hexo项目初始化Hexo项目在磁盘上新建一个文件夹作为自己Hexo项目的根目录，如：D:\\Hexo，在此目录下右键鼠标选择Git Bash，然后执行如下命令进行Hexo项目的初始化hexo init 安装Hexo项目依赖npm install 本地查看Hexo站点依赖安装完成之后，Hexo项目就算建好了，接下来我们使用如下命令检查项目是否成功创建：12hexo generate //此命令表示生成静态文件hexo server //比命令表示启动服务，启动之后在本地可以查看站点 执行上述两个命令之后，可以在命令行上看到提示，在浏览器中访问http://localhost:4000，可以成功访问则表示你的Hexo项目创建成功了。 创建Github仓库在github上创建一个与自己账户名一致的仓库：账号名.github.io，当然没有github账号的赶紧先去注册一个账号。 生成SSH密钥执行如下命令生成SSH密钥1ssh-keygen -t rsa -C “你的邮箱地址”，按3个回车，密码为空 执行完成之后，在C:\\Users\\Administrator\\.ssh下会生成两个文件id_rsa和id_rsa.pub 打开id_rsa.pub，复制全文，打开https://github.com/settings/ssh，Add SSH key，粘贴复制的文本内容 这样设置之后，将静态文件从本地推送到github上时就不要输入用户名和密码了，当然也可以不设置github的ssh，这样的话在推送文件到github上时会提示你输入用户名和密码 配置Hexo项目Hexo目录结构Hexo项目创建成功之后，我们在项目根目录下会发现这样几个我们经常用到的目录 source 这个目录是用来存放我们写的博客文件 themes 这个目录里是所有hexo安装的主题 _config.yml 这个文件是Hexo项目的主配置文件 配置Hexo使用文本编辑器打开上面介绍的_config.yml文件，按照官网https://hexo.io/docs/configuration.html上的提示配置好相关配置，具体配置细节我就不多介绍了，自己在官网上看吧 我只介绍一个配置项deploy配置，这个配置就是用来配置你的静态站点是要部署到哪个上面，一般都是用github，以我的配置为例：1234deploy: type: git repo: https://github.com/huyongli/huyongli.github.io.git branch: master 注意配置参数与值之间是需要有一个空格的，不然配置是无法生效的，type表示我们使用的是git，repo表示你github上的仓库地址，branch表示你仓库的分支，一般默认都是master 部署Hexo配置完Hexo之后，就可以将Hexo站点部署到github上了，执行如下命令进行部署：12hexo generatehexo deploy 如果在部署的过程中出现如下错误：1234ERROR Deployer not found: git执行如下命令：npm install hexo-deployer-git --save 在创建Hexo或是部署的过程中可能会多次出现类似的错误，一般都是使用npm install hexo-deployer-XXX --save类似的命令进行插件安装 上述命令执行成功后，重新部署，部署成功后，命令行上会提示Deploy done: git 成功部署后，过个几分钟就可以在浏览器上通过你的仓库地址访问你的博客了，还是以我的为例：http://huyongli.github.io 安装Hexo主题Hexo默认的主题很丑，如果想自己的博客看着舒服的话，需要安装另外的主题插件，我使用主题的是next 进入next主题主页https://github.com/iissnan/hexo-theme-next将此主题代码完整下下来，然后解压放到Hexo根目录下的themes目录下，然后将hexo项目的主题配置修改为next：theme: next 至于next主题的具体配置参考该主题的详细使用介绍吧http://theme-next.iissnan.com/ 到此，整个Hexo的安装部署就结束了 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/create-hexo-blog.html"},{"title":"微信小程序之入门项目","text":"最近在学习微信小程序，尝试着写了一个足球视频播放的小程序，先放效果截图吧 通过这个小程序的练习熟悉小程序中网络加载，页面编写和配置，页面跳转及传参，页面展示时的数据绑定以及独立模块的引用等知识点。 当然写小程序最重要的一点是必须要熟悉CSS样式的编写，对于我这种对CSS不熟的人来说真是太困难了。一个界面效果都需要调上半天。 项目代码地址如下：https://github.com/huyongli/WXSoccerVideo 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/weixin-xcx-first-project.html"},{"title":"微信小程序之页面数据绑定及页面跳转传参","text":"在写前面的小程序入门项目时，发现有两个很常用而且觉得也算比较重要的知识点，这里记录下： 页面数据绑定比如你的页面需要显示一个Hello字符串，这个这个字符串可能会根据某些情况会动态变化，这个时候就需要进行数据绑定展示了 在wxml文件布局如下：1&lt;view&gt;{{message}}&lt;/view&gt; 在js中设置好变量如下： 123456Page({ data: { message: \"Hello\", number: 1 }}); 就这样data里面的message属性就可以通过view组件展示出来了，看了上面的写法，也很容易明白，组件展示数据信息时是通过1{{属性名称}} 这的写法与data里面的属性进行绑定的。 如果在数据信息展示出来后，后面要更新这个属性信息的展示的话，就不能简单的通过this.data.message=&quot;Hello World&quot;来实现，因为这样是无法达到改变数据信息的目的的。小程序中改变数据信息要求使用函数setData()函数来实现。例如上面我们修改message`的值的话需要进行如下操作： 123this.setData({ message: \"Hello World\"}); 通过该函数更新之后，页面上会自动的更新展示，而不需要我们去进行额外的操作，微信将数据的展示与更新进行了分离，只要你使用特定的方法修改属性值，界面就会自动更新，这样的实方式比起android中的手动通知更新要方便很多 页面跳转参数小程序中从一个页面跳转到另外一个页面有几种方式，这里我以wx.navigateTo()跳转进行说明：我从index页面跳转到logs页面，很简单 123wx.navigateTo({ url: '../log/logs}) 那如果我在跳转的同时要向logs页面传递参数该怎么办呢，也很简单，直接在url后拼接相关参数即可(与http中的get请求的传参方式是一样的) 123wx.navigateTo({ url: '../video/video?message=' + this.data.message + \"&amp;number=\" + this.data.number}) 参数是传过去了，那在logs页面中该如何获取这些参数呢？其实也很简单： 1234onLoad: function (options) { var message = options.message; var number = options.number;} 如上所示，我们在新页面的onLoad函数中就可以直接获取到传递过来的参数信息。 点击View传参在我前面的文章 微信小程序之入门项目中点击视频列表中的某一项跳转到视频播放页面，而在点击列表中的某一项时，需要获取当前项的数据信息，如果我想通过点击事件就将这些数据信息作为参数传递过去该怎么做呢？代码如下： 1&lt;view wx:for=\"{{tab.videos}}\" wx:for-item=\"video\" data-video=\"{{video}}\" wx:key=\"*this\" bindtap=\"onItemClick\"&gt; 上面的代码通过for循环实现了一个列表，并为每一项绑定了点击事件，而view组件实现中有一个属性是微信没有提供的：data-video，这个属性是我们手动添加上去的，微信中如果要在wxml中传递参数到点击事件中的话则可以通过data-**的形式进行传参(**号即为参数名称)，此处是将每一项数据video作为参数进行传递，同时参数名称为video 接下来再来看看点击事件中如何获取该video信息： 12345onItemClick: function (event) { var video = event.currentTarget.dataset.video; var url = video.url; var title = video.title; } 没错，就像代码中写的，在点击事件中我们可以通过event.currentTarget.dataset获取传过来的video信息，这个参数在调试的时候也是可以通过event对象看到的 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/weixin-xcx-data-binding-and-params-transfer.html"},{"title":"微信小程序之Tab切换","text":"做过android的都知道在android里面实现Tab切换非常简单，使用android提供的TabLayout+ViewPager很容器就实现了Tab切换的效果。 但是小程序中是没有提供类似可以直接使用的组件，因此想要实现此功能需要我们自己去编码实现。在上一篇文章中我提到的小程序练手项目就实现了Tab切换效果，具体效果图可以参考文章微信小程序入门项目。 实现思路翻看小程序的文档可以发现，微信为我们提供了一个swiper组件，通过该组件可以实现view的滑动切换，它的功能与android中的ViewPager是类似的。因此实现Tab切换现在只需要实现头部的Tabbar即可，对于该功能我们可以采用多个横向排列的view组件构成一个Tabbar，每个view组件作为一个Tab项，然后再将其点击事件与swiper进行关联即可实现Tab的点击和滑动切换功能。而对于Tabbar的当前Tab项下面的指示器我们可以采用border-bottom样式实现，也可以单独使用一个view组件作为指示器，我这里采用的是第二种方式实现指示器。 代码实现代码如下： 页面布局代码1234567891011121314151617181920212223242526&lt;view class=\"page\"&gt; &lt;view class=\"navbar\"&gt; &lt;block wx:for=\"{{tabs}}\" wx:key=\"*this\"&gt; &lt;view id=\"{{index}}\" class=\"navbar__item {{activeIndex == index ? 'navbar__item_on' : ''}}\" bindtap=\"navTabClick\"&gt; &lt;view class=\"navbar__title\"&gt;{{item.name}}&lt;/view&gt; &lt;/view&gt; &lt;/block&gt; &lt;view class=\"navbar__slider\" style=\"width: {{sliderWidth}}px; transform: translateX({{sliderOffset}}px); -webkit-transform: translateX({{sliderOffset}}px);\"&gt;&lt;/view&gt; &lt;/view&gt; &lt;view style=\"position: absolute;top: 68rpx;width: 100%;height:{{contentHeight}}px\"&gt; &lt;swiper current=\"{{activeIndex}}\" duration=\"300\" bindchange=\"bindChange\"&gt; &lt;swiper-item&gt; &lt;view&gt;热门视频&lt;/view&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;view&gt;比赛集锦&lt;/view&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;view&gt;你懂专栏&lt;/view&gt; &lt;/swiper-item&gt; &lt;swiper-item&gt; &lt;view&gt;天下足球&lt;/view&gt; &lt;/swiper-item&gt; &lt;/swiper&gt; &lt;/view&gt;&lt;/view&gt; 布局样式代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960view , page { padding: 0px; margin: 0px;}.page { height: 100%;}.navbar { display: flex; position: absolute; z-index: 500; top: 0; width: 100%;}.navbar__item { position: relative; display: block; flex: 1; padding: 10rpx 0; text-align: center; font-size: 0; height: 48rpx; line-height: 48rpx; &lt;!-- NavBar的总高度为：height + padding-top + padding-bottom = 68rpx --&gt;}.navbar__item_on { color: #16B13A;}.navbar__slider { position: absolute; display: block; content: \" \"; left: 0; bottom: 0; height: 3px; background-color: #16B13A; transition: transform .3s;}.navbar__title{ display: inline-block; font-size: 15px; max-width: 8em; text-align: center;}swiper { height: 100%;}swiper-item{ width: 100%; padding-top: 20rpx; text-align: center;} js代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var tabs = [ { name: \"热门视频\" }, { name: \"比赛集锦\" }, { name: \"你懂专栏\" }, { name: \"天下足球\" }];Page({ /** * 页面的初始数据 */ data: { tabs: tabs, //展示的数据 slideOffset: 0,//指示器每次移动的距离 activeIndex: 0,//当前展示的Tab项索引 sliderWidth: 96,//指示器的宽度,计算得到 contentHeight: 0//页面除去头部Tabbar后，内容区的总高度，计算得到 }, /** * 生命周期函数--监听页面加载 */ onLoad: function (options) { var that = this; wx.getSystemInfo({ success: function (res) { that.setData({ //计算相关宽度 sliderWidth: res.windowWidth / that.data.tabs.length, sliderOffset: res.windowWidth / that.data.tabs.length * that.data.activeIndex, contentHeight: res.windowHeight - res.windowWidth / 750 * 68//计算内容区高度，rpx -&gt; px计算 }); } }); }, bindChange: function (e) { var current = e.detail.current; this.setData({ activeIndex: current, sliderOffset: this.data.sliderWidth * current }); console.log(\"bindChange:\" + current); }, navTabClick: function (e) { this.setData({ sliderOffset: e.currentTarget.offsetLeft, activeIndex: e.currentTarget.id }); console.log(\"navTabClick:\" + e.currentTarget.id); }}) 总结上面的布局代码和js代码其实写起来都不难，关键在于css样式的编写，对于不熟悉CSS的人来说调样式太痛苦了。这个效果也是我调了好半天，参考了好多代码之后写出来的，真o(╯□╰)o，看来想写好小程序还得好好学学CSS样式。 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/weixin-xcx-tabbar-switch.html"},{"title":"在线视频播放App的实现","text":"前一段时间在公司项目上做了一个视频播放的功能，当时时间紧，做完之后感觉有些地方处理的不好，所以就基于当时实现的思路进行了一些改进，加上自己平时喜欢看新闻客户端里面的一些短视频，所以就用网易等客户端的视频数据完成了一个独立的视频播放APP，顺便巩固下其他的技术。 主要使用的开源库Mosby(一个MVP框架)、RxJava、Retrofit2、ButterKnife、Glide、Systembartint、TigerDB、Material Design相关控件 主要功能 列表中播放视频 列表滑动时如果正在播放视频，则列表中播放的视频自动切换为小窗口浮动播放 列表播放切换到全屏播放模式 视频播放时也添加了完整的暂停、播放等控制操作，也添加了视频播放进度，视频缓冲进度等显示功能 视频全屏播放时支持左右滑动实现视频的快进和后退，支持右边上下滑动调整播放音量，左边上下滑动调整播放器的亮度等手势控制操作 播放器 播放器采用Android中自带的TextureView + MediaPlayer实现，同时视频播放过程中因为涉及到列表、小窗口、全屏续播等问题，所以整个视频播放过程中，播放器采用的是全局单例模式实现，这样就可以达到无缝切换续播的问题 切换到全屏播放时，是直接重新开启一个横向的Activity来实现全屏播放 APP实现效果图 github地址猛戳这里 感兴趣的朋友欢迎去我的github上star和fork 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/在线视频播放App的实现.html"},{"title":"基于openfire+smack开发Android即时聊天应用[一]—openfire安装部署","text":"Java领域的即时通信解决方案可以考虑基于xmpp协议的openfire+smack+spark来实现，都是开源的。最近一直在研究这个，也做了一个简单的Android即时聊天客户端，支持文本、图片、语音消息。 Demo地址请见此系列文章最后一篇 XMPP协议大家自行到百度google上去补脑吧。 openfire、smack、spark openfire是基于XMPP 协议的即时通信的服务器端的一个实现，如果你要实现一个简单的点对点通信或是简单的群聊，你完全可以使用该服务openfire本身提供的服务而不需要编写一行服务端的代码，非常方便。同时openfire还支持插件的扩展，如果你需要丰富增加服务端的功能，你可以基于openfire进行插件二次开发，或者直接修改openfire的源码实现。 smack是XMPP传输协议的Java实现，提供了一套API接口(类似于JDK中的HttpUrlConnection提供Http连接请求)，它是连接openfire服务、发送通信信息的桥梁。 spark是基于smack实现的一个XMPP即时通信客户端(PC端的)，spark貌似也是可以进行插件扩展的。官网：http://www.igniterealtime.org/，我目前用的都是最新版本的openfire3.10.2，smack4.1.4在smack4.1版本之前，smack本身是不支持Android平台的，不过当时有一个替代品asmack，github地址：https://github.com/flowdalic/asmack，在smack4.1之前我们可以通过asmack来配合openfire来实现Android端的即时通信应用，asmack和smack貌似api都差不多(我没看过asmack)。smack4.1之后就开始支持Android平台了，所以现在可以放弃asmack了。Windows下的Openfire安装部署去官网上下载最新的Openfire安装包，我下载的是不包含JDK的压缩包(Does not include Java JRE)，解压就可以用了，前提是你已经装了JDK了，而且JDK版本必须是1.7或以上的版本，Openfire不支持JDK6，解压之后在Openfire的根目录bin目录下执行openfire.exe即可，启动之后如下图 在启动服务配置之前，先在你的数据库中创建一个名为openfire的数据库(支持多种数据库)，点击图中的Launch Admin即会在浏览器上打开Openfire的配置界面，如下图： 上图中选择简体中文，然后继续： 上图中配置域，最好配置为你的服务器ip地址或者是域名，其他的默认不管，然后继续： 上图中选择标准数据库连接，继续： 上图中选择你的数据库类型，然后在数据库URL中填写正确的连接字符串，再填上你的数据库用户名和密码，然后继续 上图中直接默认选择初始设置，然后继续： 上图中填上管理员账户admin的邮件地址，然后填上该管理员账户的密码，然后继续： 到上图即表示你的Openfire服务安装配置完成，然后点击登录后进入到管理员登录界面： Openfire默认的管理员账户为admin，秘密即为上面你设置的密码，登录成功之后，你可以通过这个Openfire管理平台管理该服务商所有的账户信息，服务器信息等。 Linux环境下Openfire的安装部署在官网上下载最新的源码安装包(如： openfire_3_10_2.tar.gz )，我选择的也是不包含jdk的源码安装包，将该包上传至服务器某个目录下，在该目录下执行命令 tar -zxvf openfire_3_10_2.tar.gz，解压完成后切换到Openfire/bin目录下执行命令： ./openfire start 启动Openfire服务，然后在你自己的pc机浏览器上打开http://服务器ip:9090,即会进入Openfire的配置界面，前提是必须准备好一个数据库，配置过程与Windows下的配置过程一样，请参考上面的操作步骤。 OK，Openfire服务的安装配置就介绍完了，下面一篇我就开始介绍smack的用法。 write by laohu 2015-10-30 15:59:54 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/基于openfire-smack开发Android即时聊天应用-一-—openfire安装部署.html"},{"title":"基于openfire+smack开发Android即时聊天应用[三]-账号信息、添加好友、JID理解等","text":"这一篇文章主要介绍账号的属性及几个重要属性的理解，同时介绍如何添加好友，获取好友列表信息，最后介绍我对JID这个属性字段的几种理解。 1.账号信息获取账号的所有额外属性信息 1234567891011121314 /** * 获取账户所有属性信息 * @return */ public Set getAccountAttributes() { if(isConnected()) { try { return AccountManager.getInstance(connection).getAccountAttributes(); } catch (Exception e) {throw new RuntimeException(e); } } throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); } 上面取出的属性集合里主要包含如下几个属性值： 上述几个属性中的name属性即为用户的昵称属性，另外用户账号名、密码是不在这些属性当中的，账号名可以理解为是JID，可以通过RosterEntry.getUser这个方法获取，关于JID的理解请看下面的介绍 2.获取当前登录用户的所有好友信息12345678910/** * 获取当前登录用户的所有好友信息 * @return */ public Set getAllFriends() { if(isConnected()) { return Roster.getInstanceFor(connection).getEntries(); } throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); } 3.获取指定账号好友信息1234567891011/** * 获取指定账号的好友信息 * @param user 账号 * @return */ public RosterEntry getFriend(String user) { if(isConnected()) { return Roster.getInstanceFor(connection).getEntry(user); } throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); } 4.添加好友12345678910111213141516171819 /** * 添加好友 * @param user 用户账号 * @param nickName 用户昵称 * @param groupName 所属组名 * @return */ public boolean addFriend(String user, String nickName, String groupName) { if(isConnected()) { try { Roster.getInstanceFor(connection).createEntry(user, nickName, new String[]{groupName}); return true;} catch (NotLoggedInException | NoResponseException | XMPPErrorException | NotConnectedException e) { return false;} } throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); } 5.关于对JID的理解我对JID的理解主要是根据我在基于smack开发即时通信聊天应用时遇到的几种情况做的一个归纳，我碰到的JID的介绍主要有三种： 每个用户的好友列表中有一个JID，这个可以根据Openfire后台管理系统可以看出来，如下图：Smack_JID上面图中可以清晰的看到每个好友都对应有一个JID，而在我通过addFriend(String user, String nickName, String groupName)这个方法添加好友的时候，参数用户账号user最终就变成了上面的JID，是没有包含@符号和后面的服务器名的，我称这种JID为好友JID，如管理员账号的JID为：admin。这个JID通过官方提供的接口RosterEntry.getUser是可以获取到的。 好友之间聊天时有一个JID，在我创建聊天窗口对象Chat时(怎么创建请看我下一篇文章)，所传的参数也是JID，但是这个JID和上面的JID的值却又不是一样的，不然会创建失败，我们来看看官方API： 官方API中很明显的指出了参数为JID，但是我如果真的出好友列表中的JID的话创建聊天对象失败，必须这样传好友JID@ServiceName ，这是第二种JID，我称为聊天JID,比如和管理员聊天时的JID为：`admin@192.168.0.108` 好友之间传输文件时又有一个JID，在创建文件传输对象时也需要传递一个参数为JID，我们也来看看官方API： 官方API中也显示了在获取文件传输对象时需要传递参数为JID，但是这个JID我给的是聊天JID的时候，根本创建不了文件传输对象，后来在网上查了半天，看到别人都在后面加了个Smack，我也试了下，结果竟然成功了，坑爹啊，反正我还没搞清楚这是为什么，格式是这样的：好友JID@ServiceNam/Smack，我称这种JID为文件传输JID，比如聊天时给管理员传文件时的JID为：`admin@192.168.0.108/Smack` 这就是我碰到的JID的三种使用情况 write by laohu 2015-10-30 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/基于openfire-smack开发Android即时聊天应用-三-账号信息、添加好友、JID理解等.html"},{"title":"基于openfire+smack开发Android即时聊天应用[二]-用户注册、登陆、修改密码、注销等","text":"1. 开发准备在官网上下载最新的Smack开发包，我下载的是smack4.1.4版本的，导入相应的jar包即可开始开发工作 2. Openfire服务连接(连接服务器)1234567891011121314151617181920212223242526/** * 连接服务器 * @return */private XMPPTCPConnection connect() { try { XMPPTCPConnectionConfiguration config = XMPPTCPConnectionConfiguration.builder() .setHost(SERVER_IP)//服务器IP地址 //服务器端口 .setPort(PORT) //服务器名称 .setServiceName(SERVER_NAME) //是否开启安全模式 .setSecurityMode(XMPPTCPConnectionConfiguration.SecurityMode.disabled) //是否开启压缩 .setCompressionEnabled(false) //开启调试模式 .setDebuggerEnabled(true).build(); XMPPTCPConnection connection = new XMPPTCPConnection(config); connection.connect(); return connection; } catch (Exception e) { return null; }} 3.登陆Openfire服务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 /** * 是否连接成功 * @return */ private boolean isConnected() { if(connection == null) { return false; } if(!connection.isConnected()) { try { connection.connect(); return true; } catch (SmackException | IOException | XMPPException e) { return false; } } return true; } /** * 登陆 * @param user 用户账号 * @param password 用户密码 * @return * @throws Exception */ public boolean login(String user, String password) throws Exception { if(!isConnected()) { return false; } try { connection.login(user, password); return true; } catch (Exception e) { throw e; } }``` ### 4.用户注册 该功能会在服务器上创建一个新的账号信息```java /** * 注册用户信息 * @param user 账号，是用来登陆用的，不是用户昵称 * @param password 账号密码 * @param attributes 账号其他属性，参考AccountManager.getAccountAttributes()的属性介绍 * @return */ public boolean registerUser(String user, String password, Map&lt;String, String&gt; attributes) { if(!isConnected()) { return false; } try { AccountManager.getInstance(connection).createAccount(user, password, attributes); return true; } catch (NoResponseException | XMPPErrorException | NotConnectedException e) { Log.e(TAG, \"注册失败\", e); return false; } } 5.修改账号密码1234567891011121314151617 /** * 修改密码 * @param newpassword 新密码 * @return */ public boolean changePassword(String newpassword) { if(!isConnected()) { return false; }try { AccountManager.getInstance(connection).changePassword(newpassword); return true;} catch (NoResponseException | XMPPErrorException | NotConnectedException e) { Log.e(TAG, \"密码修改失败\", e); return false;} } 6.注销(断开连接)12345678910111213141516/** * 注销 * @return */ public boolean logout() { if(!isConnected()) { return false; } try { connection.instantShutdown(); return true; } catch (Exception e) { e.printStackTrace(); return false; } } 7.删除账号/** * 删除当前登录的用户信息(从服务器上删除当前用户账号) * @return */ public boolean deleteUser() { if(!isConnected()) { return false; } try { AccountManager.getInstance(connection).deleteAccount();//删除该账号 return true; } catch (NoResponseException | XMPPErrorException | NotConnectedException e) { return false; } } 代码都非常简单，smack的api调用很方便。 write by laohu 2015-10-30 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/基于openfire-smack开发Android即时聊天应用-二-用户注册、登陆、修改密码、注销等.html"},{"title":"基于openfire+smack开发Android即时聊天应用[五]-简易IM客户端效果图","text":"经过几天时间对Openfire+Smack的研究，写了一个简单的Android端的IM客户端，给大家看看我的客户端的效果图，支持发送文本、图片、语音三种消息，群聊功能暂时没有集成上去。整个应用做的比较粗糙。 Demo代码地址请戳：https://github.com/huyongli/TigerIM 1.登陆界面 2.好友列表 3.聊天界面的几种效果图： 聊天界面是仿着QQ的聊天界面做的。 write by laohu 2015-10-30 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/基于openfire-smack开发Android即时聊天应用-五-简易IM客户端效果图.html"},{"title":"简单实用的Android ORM框架TigerDB","text":"TigerDB是一个简单的Android ORM框架，它能让你一句话实现数据库的增删改查，同时支持实体对象的持久化和自动映射，同时你也不必关心表结构的变化，因为它会自动检测新增字段来更新你的表结构。 该库主要包括如下几个要点： 根据实体对象自动建表、新增字段(SQLite不支持删除字段列) 支持注解配置表名、字段名、字段默认值、主键是否自增长以及哪些字段不作为数据表中的映射字段 直接映射实体对象到SQLite数据库，实现一行代码对SQLite数据库增删改查 支持在SDCard中新建数据库db 解决在onCreate，onUpgrade中执行数据库其他操作时出现的异常(java.lang.IllegalStateException: getDatabase called recursively) 支持原生SQL语句操作数据库 该ORM库使用过程中的主要类说明： SQLiteDBConfig：主要用于设置数据库的名字、创建路径、版本号、数据创建更新时的监听 SQLiteDB：创建完数据库之后，主要通过此类来操作数据库的增删改查 SQLiteDBFactory：该类主要用于创建SQLite数据库，同时缓存当前创建的SQLiteDB对象 CursorUtil：查询数据库时，检测游标对象Cursor是否正常，解析Cursor数据为实体对象 IDBListener：数据库创建、升级时的监听类，提供了空实现SimpleDBListener Column：该注解用来设置字段名、字段默认值 PrimaryKey：该注解用来设置主键、主键字段名、以及主键是否为自增长 Table：该注解用来设置表名，不设置的话默认类名为表名 NotDBColumn：该注解用来设置哪些实体属性不映射到数据表中 主要用法如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//新建实体，可以通过注解@Table设置表名,如果不设置默认以类名User作为表名public class User { //设置主键id为自增长，也可以通过注解@Column设置字段名或字段默认值 @PrimaryKey(isAutoGenerate=true) private long id; private String name; //设置age字段默认值为1 @Column(defaultValue=\"1\") private int age; //该字段不作为数据表中的字段 @NotDBColumn private String bz; //必须实现无参构造 public User() { } public User(String name) { super(); this.name = name; } public long getId() { return id; } public void setId(long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"{id=\" + id + \",name=\" + name + \"}\"; }} //SQLite相关配置，包括数据库名字、创建路径、版本号、数据创建和升级时的监听SQLiteDBConfig config = new SQLiteDBConfig(this);//设置数据库创建更新时的监听，有提供空实现：SimpleDBListenerconfig.setDbListener(new IDBListener() { @Override public void onUpgradeHandler(SQLiteDatabase db, int oldVersion, int newVersion) { } @Override public void onDbCreateHandler(SQLiteDatabase db) { showLongToast(\"数据库创建成功\"); } }); //创建db，在创建数据库的时候，不需要在onDbCreateHandler手动去创建相关的数据表，在对实体对象进行数据操作的时候，会自动判断表是否存在，不存在的话会自动创建，同时如果有新增的字段也会自动更新表结构 SQLiteDB db = SQLiteDBFactory.createSQLiteDB(config); //保存单个实体对象User user = new User(\"添加单个对象\");int rtn = db.save(user) //保存集合对象List list = new ArrayList();int rtn = db.save(list) //查询User表中的所有数据List list = db.queryAll(User.class); //根据实体id(主键)查询UserUser user = db.query(User.class, \"1\"); //查询User表中的数据总数long total = db.queryTotal(User.class); //删除指定实体对象db.delete(user); //更新实体对象db.update(user); //分页查询db.queryPage(claxx, curPage, pageSize); //根据SQL查询Cursor cursor = db.query(sql, bindArgs)； 源码及Demo地址：https://github.com/huyongli/TigerDB，大家可以自行下载查看 如果大家有什么疑问和建议，欢迎提出 write by laohu 2015年9月28日 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/简单实用的Android-ORM框架TigerDB.html"},{"title":"红米Note调用系统相机拍照后应用崩溃问题分析解决","text":"这几天突然发现红米Note手机只要调用系统相机进行拍照时，我的应用必定会崩溃。这个问题折腾了好久才解决，现在记录下问题跟踪解决的过程和方法。(红米Note手机的系统太坑爹了%&gt;_&lt;%) ####解决办法请直接从第7条开始看，1~5条为我的问题处理过程，第6条为问题原因分析。 ####问题原因分析 问题刚出现的时候，当然是想调试，在调用系统相机拍照的前后代码出打好断点准备调试，结果发现这段代码没有任何异常(其实想想也是正常的，因为其他手机都是好的，唯独红米Note有问题，要是这段代码有问题，其他手机应该也有问题，这一步真是多余) 既然暂时找不到系统崩溃时代码的出错行，那只有去查看系统崩溃日志了(这里提一下，应用开发时一定要通过UncaughtExceptionHandler捕获系统未处理的系统，并在uncaughtException(Thread thread, Throwable ex)方法中记录异常日志，不然应用运行中崩溃了完全无法快速准确的定位错误信息)。 当我打开日志文件一看，傻眼了，这日志记录完全无法定位错误信息(日志记录不完全，也没有准确记录，没有记录出错的代码行以及相关的方法运行栈信息)。没办法，我只能想办法重新改写记录日志的方式，下面是我记录异常信息日志的方法，可以准确的定位到出错的代码行和方法，以及其运行前后的方法栈信息： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void uncaughtException(Thread thread, Throwable ex) { String logdir = logPath ; File file = new File(logdir); boolean mkSuccess; if (!file.isDirectory()) { mkSuccess = file.mkdirs(); if (!mkSuccess) { mkSuccess = file.mkdirs(); } } StringBuffer sb = new StringBuffer(); DateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\"); Writer writer = new StringWriter(); PrintWriter printWriter = new PrintWriter(writer); ex.printStackTrace(printWriter); Throwable cause = ex.getCause(); while (cause != null) { cause.printStackTrace(printWriter); cause = cause.getCause(); } printWriter.close(); String result = writer.toString(); sb.append(result); try { String time = formatter.format(new Date()); String logFile = logdir + File.separator + time + \".log\"; FileOutputStream fos = new FileOutputStream(logFile); fos.write(sb.toString().getBytes()); fos.close(); } catch (Exception e) { Log.e(TAG, \"an error occured while writing file...\", e); } if (!handleException(ex) &amp;&amp; mDefaultHandler != null) { mDefaultHandler.uncaughtException(thread, ex); } else { try { Thread.sleep(1000); } catch (InterruptedException e) { Log.e(TAG, \"Error : \", e); } } android.os.Process.killProcess(android.os.Process.myPid()); System.exit(10);} 重新运行了几次，发现每次出错的地方竟然还不一样(但每次出错都是空指针异常引起的)，有时候是调用系统相机的那个Activity的onCreate方法调用的时候出现空指针，有时候是调用系统相机的前面一个Activity的onCreate方法中出现空指针(假设界面A跳到界面B，在B中调用系统相机，出错的时候A和B中的onCreate方法里都有空指针异常信息)，知道出现错误的代码行数这救你好办了，赶紧打好断点准备调试，结果竟然发现不管怎么操作，代码就是不进断点。 代码不进断点，就没法找到问题根源，只能分析代码寻求解决办法了，我在出现空指针错误的地方加上非空判断，重新运行发现这几个地方虽然不出错了，但是又在其他的地方出现空指针异常了，经过分析发现所有出现空指针的地方都是我的自定义Application里面的某几个static引用型变量为空了。分析到这里，在加上前面的代码不进断点以及空指针出现onCreate方法中，猜测是不是应用直接被系统回收了。 调用系统相机的时候，应用被系统回收(Application、处于后台和前台的Activity都被销毁，静态变量全部消失)，此时拍照完成之后重新恢复创建Activity(重新创建的时候，手机与编辑器的调试状态肯定就断掉了，因此通过onCreate重新创建Activity时无法进到断点)，重新调用onCreate时，因为该方法中有用到自定义Application里的static变量(此时已被销毁)，所以会出现空指针异常。至于为什么界面A和B对应的onCreate方法中都会出现空指针，那是因为B调用系统相机完成之后会重新创建，创建失败之后按照Activity的栈顺序会接着创建界面A，而A中的onCreate方法里也用到了自定义Application里的static变量，所以也出现了空指针。 既然知道了问题原因，那就来寻求解决办法，我在onSaveInstanceState(Bundle outState)方法中保存当前Activity里操作过的所有变量信息，然后在重新创建该Activity时通过onRestoreInstanceState(Bundle savedInstanceState)方法来恢复这些数据信息(这两个方法的执行机制请参考我的另外一篇文章：Android基础篇之：Activity生命周期)，同时在onCreate中用到自定义Application里的static变量的地方进行非空判断(为空的时候进行重新初始化)，进过这一系列的代码处理之后，再次运行正常，完美解决问题。 不过在步骤7中解决问题时发现，在处理应用被回收重新创建时要注意如下几点： Activity里用户操作的所有数据全部需要保存 Activity中第一次初始化时获取到的变量也需要保存 用户登陆后所有拥有的相关权限也需要进行处理保存 数据恢复时要考虑当前Activity引用的其他Activity或Application里面的变量的再次初始化 所有自定义对象都最好能被序列化，否则无法进行状态保存 尽量少用static类型的变量 有些服务能不在Application中初始化，最好不要在Application中初始化。 在Application中定义的变量最后都在Application中进行初始化创建，不要部分在Application进行初始化，部分在其他的Activity里进行初始化 应用开发时要考虑到应用被回收的情况，以便真正被回收后能方便的解决(虽然应用被回收的几率很低，但是不排除某些坑爹的手机很容易被回收，就像红米Note一样)。 write by laohu 2015年10月22日 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/红米Note调用系统相机拍照后应用崩溃问题分析解决.html"},{"title":"阿里云服务器安装Apache","text":"使用阿里云自带的安装命令：yun install httpd安装完成之后运行命令：chkconfig --levels 235 httpd on上面的命令可以让Apache开机自动启动。运行命令：/etc/init.d/httpd start 让Apache立刻启动 启动过程中如果出现Could not reliably determine the server's fully qualified domain name, using 10.161.94.31 for ServerName提示，则将Apache安装目录/etc/httpd/conf/下的httpd.conf文件中的#ServerName localhost:80注释去掉即可，或是添加一行ServerName localhost:80 阿里云上Apache安装路径为/etc/httpd/ 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/阿里云服务器安装Apache.html"},{"title":"阿里云服务器安装MySQL","text":"运行命令：yun install mysql 安装MySQL客户端 紧接着运行命令：yun install mysql-server 安装MySQL服务 运行命令：chkconfig –levels 235 mysqld on 让MySQL服务可以自动启动 运行命令：/etc/init.d/mysqld start 立刻启动MySQL服务 设置MySQL的root密码，运行命令/usr/bin/mysqladmin -u root password ‘new-password’，其中’new-password’是新设的密码，如123456 安装完成之后，MySQL的安装路径为：/usr/share/mysql/ 其主配置文件在： /etc/my.cnf 如果要MySQL支持中文，还需要进行相关字符配置，即在主配置文件/etc/my.cnf中添加如下两行配置：12character_set_server = utf8default-character-set=utf8 如果想通过自己机器上的客户端远程连接MySQL(阿里云默认是不允许远程连接的)，还需要做相关配置： 在服务器上本地登陆MySQL：mysql -u root -p … 切换到系统数据库：use mysql 将user表中的host设置为%表示任何ip都能连接mysql12update user set host=’%’ where user=’root’ and host=’localhost’;flush privileges; #刷新权限表，使配置生效 如果想关掉远程连接，按照上面的方式将host设置为localhost就可以了 update user set host=’localhost’ where user=’root’; 可以参考阿里云的官方bbs: 阿里云服务器新手入门 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/阿里云服务器安装MySQL.html"},{"title":"阿里云服务器安装vsftpd","text":"运行命令：yun install vsftpd 安装vsftpd 将vsftpd设置为开机启动：chkconfig vsftpd on 启动vsftpd服务： service vsftpd start 管理vsftpd相关服务： 停止：service vsftpd stop 重启：service vsftpd restart 为vsftpd添加用户，用户名为ftpuser，设置其主目录为/home/ftp： 运行命令：useradd -d /home/ftp -g ftp -s /sbin/nologin ftpuser 设置该用户的密码：passwd ftpuser 配置vsftpd服务，只允许刚刚新添加的用户ftpuser登陆ftp服务，其默认主配置文件在：/etc/vsftpd/vsftpd.conf userlist_enable=YES # 是否启用vsftpd.user_list文件 userlist_deny=NO # 决定vsftpd.user_list文件中的用户是否能够访问FTP服务器。若设置为YES，则vsftpd.user_list文件中的用户不允许访问FTP，若设置为NO，则只有vsftpd.user_list文件中的用户才能访问FTP 将 /etc/vsftpd/user_list文件中的所有用户全部注释掉，添加刚刚添加的用户ftpuser，如下： 123456789101112131415161718192021# vsftpd userlist # If userlist_deny=NO, only allow users in this file# If userlist_deny=YES (default), never allow users in this file, and # do not even prompt for a password. # Note that the default vsftpd pam config also checks /etc/vsftpd/ftpusers # for users that are denied.#root #bin#daemon #adm#lp #sync #shutdown #halt #mail #news #uucp #operator #games #nobody ftpuser 配置到这里，就可以远程用FTP客户端登录并上传文件，文件会保存在ftpuser的主目录，也就是/home/ftp 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/阿里云服务器安装vsftpd.html"},{"title":"Android基础之Activity生命周期","text":"之前一直对Activity的生命周期不是很清楚，感觉很模糊。前两天也看了下任玉刚书里对Activity生命周期的讲解，今天特意写了个程序验证了下Activity的生命周期内各个回调的执行情况，为了避免多段时日又忘了，干脆对这次的理解总结下，俗话说好记性不如烂笔头，没事的时候可以回过头来再看看。 我们先来看一张非常经典的Activity生命周期流程图： Activity的生命周期大致有如下几个成果： 启动Activity：系统会先调用onCreate，然后调用onStart，最后调用onResume，此时Activity进入前台处于运行状态。如图： 当前Activity被其他Activity覆盖，且覆盖的这个Activity是为透明：系统只会调用onPause，此时Activity处于后台可见暂停运行状态。如图： 当前Activity被其他Activity覆盖，且覆盖的这个Activity为非透明：系统处理过程与步骤4中的过程是一样的。如图： 手机锁屏或按下了Home键：系统会先调用onPause，最后调用onStop，此时Activity处于后台非可见暂停运行状态。如图： 如果在步骤2时，用户后退回到了此Activity：系统会调用onResume，此时Activity回到前台继续运行。如图： 如果在步骤3和4时，用户后退或解锁回到了此Activity：系统会调用onRestart，然后调用onStart，最后调用onResume，然后此Activity回到前台继续运行。如图： 当Activity处于被覆盖或后台不可见时(即步骤3和4)，系统内存不足时会杀死该Activity(系统杀死Activity时，步骤3与4的Activity的被杀优先级会比步骤2高)，这时如果用户后退回到该Activity，系统会重新执行onCreate，onStart，onResume进入运行状态。此过程不好验证，不提供图片了。 用户退出Activity时：系统会先执行onPause，然后执行onStop，最后执行onDestory方法结束此Activity的运行。如图： 系统内存不足杀死Activity结束运行时的生命周期函数执行情况我目前无法验证，暂时不是很清楚。 从上面的生命周期过程来看，主要涉及到了7个生命周期函数，下面是我对于每个生命周期主要作用的理解： onCreate：用于Activity的初始化，例如设置布局，初始化相关布局控件等。 onStart：设置Activity窗口可见 onResume：让Activity窗口处于系统前台 onRestart：在Activity由不可见回到可见时，需要通过此方法唤起onStart的执行 onPause：让Activity窗口退出系统前台(参照上面的过程2理解)，与onResume方法刚好是一对 onStop：让Activity窗口不可见(参照上面的过程3和过程4理解)，与onStart方法刚好是一对 onDestory：结束Activity，销毁相关资源 光说了这些理论的东西是不够，只有亲自测试验证过了记忆才够深刻，下面是我测试验证的主要代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class LifeCycle_A_Activity extends Activity { private final String TAG = getClass().getSimpleName(); private Button btn1; private Button btn2; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_lifecycle_a_layout); btn1 = (Button) findViewById(R.id.btn_lifecycle); btn2 = (Button) findViewById(R.id.btn_lifecycle2); btn1.setText(\"跳转到LifeCycle_B_Activity(透明)\"); btn2.setText(\"跳转到LifeCycle_C_Activity(非透明)\"); btn1.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { toAnotherActivity(LifeCycle_B_Activity.class); } }); btn2.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { toAnotherActivity(LifeCycle_C_Activity.class); } }); Log.i(TAG, \"LifeCycle----onCreate\"); } public void toAnotherActivity(Class&lt;?&gt; claxx) { startActivity(new Intent(LifeCycle_A_Activity.this, claxx)); } @Override protected void onStart() { super.onStart(); Log.i(TAG, \"LifeCycle----onStart\"); } @Override protected void onRestart() { super.onRestart(); Log.i(TAG, \"LifeCycle----onRestart\"); } @Override protected void onResume() { super.onResume(); Log.i(TAG, \"LifeCycle----onResume\"); } @Override protected void onStop() { super.onStop(); Log.i(TAG, \"LifeCycle----onStop\"); } @Override protected void onPause() { super.onPause(); Log.i(TAG, \"LifeCycle----onPause\"); } @Override protected void onDestroy() { super.onDestroy(); Log.i(TAG, \"LifeCycle----onDestroy\"); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); outState.putInt(\"stateParam\", 1); Log.i(TAG, \"LifeCycle----onSaveInstanceState,save value is:\" + 1); } @Override protected void onRestoreInstanceState(Bundle savedInstanceState) { super.onRestoreInstanceState(savedInstanceState); int value = savedInstanceState.getInt(\"stateParam\"); Log.i(TAG, \"LifeCycle----onRestoreInstanceState,restore value is:\" + value); } @Override public void onWindowFocusChanged(boolean hasFocus) { super.onWindowFocusChanged(hasFocus); Log.i(TAG, \"LifeCycle----onWindowFocusChanged, focus is:\" + hasFocus); }} 该Activity对应的布局文件代码如下：123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center_horizontal\" android:orientation=\"vertical\" &gt; &lt;Button android:id=\"@+id/btn_lifecycle\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; &lt;Button android:id=\"@+id/btn_lifecycle2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; &lt;/LinearLayout&gt; Activity跳转后覆盖的透明与非透明的Activity代码及布局文件如下： 1234567891011121314151617181920212223242526//透明的Activity，在注册Activity时需要添加theme属性//android:theme=\"@android:style/Theme.Translucent\"public class LifeCycle_B_Activity extends Activity { private Button btn; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_lifecycle_b_layout); btn = (Button) findViewById(R.id.btn_lifecycle); btn.setText(\"当前为LifeCycle_B_Activity(透明)\"); }} //非透明的Activitypublic class LifeCycle_C_Activity extends Activity { private Button btn; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_lifecycle_b_layout); btn = (Button) findViewById(R.id.btn_lifecycle); btn.setText(\"当前为LifeCycle_C_Activity(非透明)\"); }} 12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:orientation=\"vertical\" &gt; &lt;Button android:id=\"@+id/btn_lifecycle\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; &lt;/LinearLayout&gt; 很明显，上面的验证代码中我多写了三个方法onWindowFocusChanged，onSaveInstanceState，onRestoreInstanceState，这三个方法都不属于Activity生命周期函数，只是这三个函数在Activity生命周期变化时，对于我们的应用开发还是紧密相关的，所以我给加进来一起看下他们的执行时机。 onWindowFocusChanged：看名字就可以知道，这个函数是Activity窗体焦点发生变化时的回调，比如Activity在前台显示，被覆盖，手机截屏，按下Home键等等，都会触发该方法。再结合我上面生命周期过程验证结果，其实更容易理解，该函数只会在Activity是否前台显示发生变化时触发，也就是在onResume或onPause调用后触发该函数。当我们想在Activity初始化时获取某个特定组件的大小时，在onCreate中是无法获取的，因为这个时候Window对象还没有创建完成，这个时候，我们可以通过onWindowFocusChanged函数来获取指定组件的大小。 onSaveInstanceState：` 当系统资源不足杀死Activity时会调用该函数。 当屏幕方向发生变化时也会调用该函数。 当Activity被覆盖或锁屏或按下Home键时都会调用该函数。该方法主要用于保存当前窗体各个视图组件View的状态信息，当然我们也可以手动保存一些临时变量以避免资源不足Activity被杀死或屏幕发生变化后无法恢复到之前状态。根据上面的生命周期过程验证发现onSaveInstanceState是在Activity由前台显示变为不显示时触发，也就是在onPause调用后触发该函数。这个也很容易理解，当Activity由前台显示变为后台显示时，只有先将当前的窗体各个视图组件状态保存起来，系统后续恢复起来才有依据才知道恢复到什么样子。 onRestoreInstanceState：该函数与onSaveInstanceState相对的，它主要用于恢复用户保存的一些临时数据以及系统之前通过onSaveInstanceState保存的各个组件的状态信息。此方法目前经过验证只在屏幕方向发生变化时才会调用。系统资源不足杀死Activity后重新恢复创建Activity这种情况无法验证，这种情况是否执行待验证。 屏幕方向发生变化时验证如下结果如下图(在手机设置中先设置为自动旋转屏幕，在AndroidMainfest.xml中注册Activity时不要设置android:screenOrientation属性)： 上面日志中清晰的记载了Activity销毁之前保存的临时变量通过onRestoreInstanceState可用获取得到。 write by laohu 2015年10月8日21:56:06 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Android基础之Activity生命周期.html"},{"title":"自定义Behavior实现快速返回效果","text":"Behavior是Android Design包中出现的一个概念，Android Design包中很多控件的动画效果都是使用Behavior实现的，所以想要更好的实现Material Design风格的应用就有必要弄清楚Behavior。这篇文章从简单开始，介绍如何自定义Behavior以实现快速返回的效果。 还是先看下最终实现的效果 介绍先看官方介绍https://developer.android.google.cn/reference/android/support/design/widget/CoordinatorLayout.Behavior.html Interaction behavior plugin for child views of CoordinatorLayout. A Behavior implements one or more interactions that a user can take on a child view. These interactions may include drags, swipes, flings, or any other gestures. 上面的介绍说Behavior是CoordinatorLayout子视图的一个交互插件，它可以为子视图实现一个或多个交互，这些交互包括拖拽，滑动或其他的手势操作。 通过上面的介绍我们知道Behavior是作用于CoordinatorLayout子视图的，而CoordinatorLayout我们可以把它看做一个FrameLayout。 根据我的理解来说Behavior其实就是一系列手势操作行为的回调，通过这些回调来处理CoordinatorLayout子视图的手势操作。 使用用过Android Design库中AppBarLayout与NestedScrollView这两个类的同学应该知道，这两个类一起使用会产生很漂亮的滑动效果，这也是Android库中对Behavior的一个很典型的应用。而对于Behavior的使用，也可以参考这两个类的两种使用方式： 为CoordinatorLayout的直接子View设置app:layout_behavior=“behavior完全类名” 为CoordinatorLayout的某个子View设置默认Behavior，设置方式是在该View的类声明上添加注解`@CoordinatorLayout.DefaultBehavior(Behavior类.class)` Behavior相关方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class BackTopBehavior extends CoordinatorLayout.Behavior { public MyBehavior(Context context, AttributeSet attrs) { super(context, attrs); //必须实现此构造方法，因为CoordinatorLayout中初始化Behavior时是通过反射调用此构造来进行初始化的 } @Override public boolean layoutDependsOn(CoordinatorLayout parent, View child, View dependency) { return super.layoutDependsOn(parent, child, dependency); //判断视图child进行layout布局时是否依赖于某个特定的View dependency //child是指应用此Behavior的View，dependency是触发执行此Behavior的视图并与child进行相关交互，也就是上面所说的是child的依赖 //此方法在CoordinatorLayout进行request layout时至少会调用一次 //如果返回true，CoordinatorLayout会总是在依赖视图dependency layout完成之后对child视图进行layout布局 //同时如果依赖视图dependency的layout或position发生变化，CoordinatorLayout会调用onDependentViewChanged } @Override public boolean onDependentViewChanged(CoordinatorLayout parent, View child, View dependency) { return super.onDependentViewChanged(parent, child, dependency); //此方法的调用时机参考上面的方法layoutDependsOn的说明 //当child的依赖视图dependency发生layout变化后，如果想对child布局(child's size or position)做出相应变化则返回true否则返回false，具体对child如何update则需要在onLayoutChild中进行实现 } @Override public void onDependentViewRemoved(CoordinatorLayout parent, View child, View dependency) { super.onDependentViewRemoved(parent, child, dependency); //当child的依赖视图dependency从其parent中remove掉后会调用此方法 } @Override public boolean onMeasureChild(CoordinatorLayout parent, View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) { return super.onMeasureChild(parent, child, parentWidthMeasureSpec, widthUsed, parentHeightMeasureSpec, heightUsed); //当测量CoordinatorLayout的子视图child时调用此方法 } @Override public boolean onLayoutChild(CoordinatorLayout parent, View child, int layoutDirection) { return super.onLayoutChild(parent, child, layoutDirection); //当对CoordinatorLayout的子视图child进行layout布局时会调用此方法 //当child的依赖视图layout结束之后，会调用此方法对child进行layout布局 //如果onDependentViewChanged中返回了true，则需要在此方法中对child视图进行update } @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, int nestedScrollAxes) { return super.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes); //滑动开始调用，返回true表示此Behavior接收此滑动，才会有后续的滑动处理 } @Override public void onStopNestedScroll(CoordinatorLayout coordinatorLayout, View child, View target) { super.onStopNestedScroll(coordinatorLayout, child, target); //滑动结束调用 } @Override public void onNestedScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) { super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); //滑动过程中调用 } @Override public void onNestedPreScroll(CoordinatorLayout coordinatorLayout, View child, View target, int dx, int dy, int[] consumed) { super.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed); //滑动过程中，在child自身消费掉此次滑动的distance之前调用此方法 //onNestedPreScroll is called each time the nested scroll is updated by the nested scrolling child // before the nested scrolling child has consumed the scroll distance itself } @Override public boolean onNestedFling(CoordinatorLayout coordinatorLayout, View child, View target, float velocityX, float velocityY, boolean consumed) { return super.onNestedFling(coordinatorLayout, child, target, velocityX, velocityY, consumed); //快速滑动时调用此方法 }} 上面就是Behavior中比较常用比较重要的一些方法。 自定义Behavior我要实现的是在在列表上滑时，显示快速返回按钮，列表下滑时隐藏快速返回按钮，当快速返回按钮显示时，点击该按钮，列表会自动滑动到顶部。 快速返回按钮我用的是Android Design中的FloatingActionButton,其实在FloatingActionButton中设置了默认的Behavior，但是这个默认的Behavior是与SnackBar结合使用的，因此我可以直接继承FloatingActionButton.Behavior复写其中的相关方法实现我们所要的效果，这样可以减少很多工作 123456789101112131415161718192021222324252627282930313233343536public class BackTopBehavior extends FloatingActionButton.Behavior { private static final String TAG = \"BackTopBehavior\"; public BackTopBehavior(Context context, AttributeSet attrs) { super(); } @Override public boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View directTargetChild, View target, int nestedScrollAxes) { return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL;//垂直方向滑动 } @Override public void onNestedScroll(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) { if (dyConsumed &gt; 0 &amp;&amp; dyUnconsumed == 0) { Log.d(TAG, \"上滑中。。。\"); } if (dyConsumed == 0 &amp;&amp; dyUnconsumed &gt; 0) { Log.d(TAG, \"到边界了还在上滑。。。\"); } if (dyConsumed &lt; 0 &amp;&amp; dyUnconsumed == 0) { Log.d(TAG, \"下滑中。。。\"); } if (dyConsumed == 0 &amp;&amp; dyUnconsumed &lt; 0) { Log.d(TAG, \"到边界了，还在下滑。。。\"); } if((dyConsumed &gt; 0 &amp;&amp; dyUnconsumed == 0) || (dyConsumed == 0 &amp;&amp; dyUnconsumed &gt; 0) &amp;&amp; child.getVisibility() != View.VISIBLE) { child.show();//上滑的时候显示按钮 } else if((dyConsumed &lt; 0 &amp;&amp; dyUnconsumed == 0) || (dyConsumed == 0 &amp;&amp; dyUnconsumed &lt; 0) &amp;&amp; child.getVisibility() != View.GONE) { child.hide();//下滑的时候因此按钮 } }} 这样实现起来是不是感觉很简单，如果不用Behavior的话，需要自己自定义View，并对滑动事件进行处理，实现起来肯定比Behavior方式要费劲。 剩下的布局和Activity代码如下：123456789101112131415161718192021222324252627282930313233343536public class BackTopBehaviorActivity extends AppCompatActivity { CommonRecyclerView mRecyclerView; LinearLayoutManager mLayoutManager; FloatingActionButton mFloatingActionButton; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_backtop_behavior); mFloatingActionButton = (FloatingActionButton) findViewById(R.id.floatingActionButton); mFloatingActionButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { mLayoutManager.smoothScrollToPosition(mRecyclerView, null , 0); } }); initRecyclerView(); } private void initRecyclerView() { mRecyclerView = (CommonRecyclerView) findViewById(R.id.recyclerView); mLayoutManager = new LinearLayoutManager(this); mRecyclerView.setLayoutManager(mLayoutManager); mRecyclerView.addItemDecoration(new SpacesItemDecoration(5)); List&lt;String&gt; data = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 30; i ++) { data.add(\"数据\" + (i + 1)); } StringListAdapter mAdapter = new StringListAdapter(this, data); mRecyclerView.setAdapter(mAdapter); }} 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" app:title=\"@string/app_name\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" app:titleTextColor=\"@android:color/white\"/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;cn.ittiger.demo.ui.CommonRecyclerView android:id=\"@+id/recyclerView\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" app:layout_collapseMode=\"pin\"/&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/floatingActionButton\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:layout_margin=\"@dimen/d_15\" android:src=\"@android:drawable/stat_sys_upload_done\" app:layout_behavior=\"cn.ittiger.demo.behavior.BackTopBehavior\" app:layout_scrollFlags=\"scroll|enterAlways|snap\" android:visibility=\"gone\"/&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; Demo的完整代码戳这里 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Custom-Behavior-to-fast-back.html"},{"title":"Hashtable、HashMap、TreeMap","text":"Hashtable、HashMap、TreeMap都是比较常见的一些Map实现，它们都是key-value键值对的形式存储和操作数据的容器类，同时他们的元素中不能有重复的key,一个key也只能映射一个value值。 下面我从不同的维度来分别说说这三个集合，文章中涉及到的源码版本是JDK8 底层数据结构 Hashtable和HashMap底层都是采用数组存储数据 TreeMap底层是采用红黑树存储数据 元素特性HashtableHashtable中存储的key和value都不能为null，这个从它的源码实现是可以看出来的123456789101112public synchronized V put(K key, V value) { // Make sure the value is not null if (value == null) { throw new NullPointerException(); } // Makes sure the key is not already in the hashtable. Entry&lt;?,?&gt; tab[] = table; int hash = key.hashCode(); ...//省略部分 return null;} 这是Hashtable添加元素的源码实现，从开头的if判断就可以发现它的value值是不允许为null的，而它的key虽然没有显式判断，但是在执行int hash = key.hashCode();这句代码时，如果key为null的话，代码执行到这里程序就崩了，所以从侧面也反应出key也不能为null HashMapHashMap中存储的key和value都允许为null，这个依然是从源码中看出来的。123456789101112131415161718192021222324252627282930//HashMap的put方法具体实现比较复杂代码比较多，这里我只贴出添加元素时涉及到key和value的相关代码static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) { return new Node&lt;&gt;(hash, key, value, next);}TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) { return new TreeNode&lt;&gt;(hash, key, value, next);}static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } ...}//TreeNode最终还是继承自Node，所以这里就不贴出TreeNode的构造函数了 从上面的几段代码中可以看到在将key-value添加到HashMap中时没有任何地方会使用它们，因此key和value都是可以为null的 但是一个HashMap中只能有一个key为null，但是可以有多个value为null TreeMapTreeMap中如果用户未实现Comparator接口，则key不能为null，如果实现了Comparator接口，那么key能否为null则需要根据Comparator接口的具体实现有关。value则是可以为null。至于原因，我们依然通过源码来寻求答案1234567891011121314151617181920212223242526272829303132public V put(K key, V value) { ... Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) { do { parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } else { if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do { parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); } while (t != null); } ... return null;} 通过上面的代码可以很明显的看到当成员变量comparator为空时(Comparator接口未实现)，有明显的key的非空判断，而当实现了该接口后，这会通过Comparator接口的compare方法比较当前key与TreeMap中已存在的key是否相等，所以这个时候key能否为nul就跟Comparator接口的compare方法具体实现有关了。 注意这段代码1234567cmp = k.compareTo(t.key);if (cmp &lt; 0) t = t.left;else if (cmp &gt; 0) t = t.right;else return t.setValue(value); 从上面的代码中我们还可以看出TreeMap的key是有序的，而且当前节点的key比其左子树节点的key要大，而比右子树节点的key要小。 有序性 Hashtable和HashMap都是无序的 TreeMap的key是有序的，有序的原因在前面分析其put源码的时候已经说过了。要注意的是这里是key是有序的，而不是其value是有序的，而且其默认是升序排序方式(深度优先搜索)，对于其排序方式，可以自定义实现Comparator接口来自定义排序规则 初始化和扩容方式Hashtable 默认初始化容量为11个 容量阈值默认为当前容量的0.75倍，当集合数据大于等于阈值时就会进行扩容 不要求底层数组的容量一定为2的幂次方 扩容时会将容量变为原来的2倍加1 在初始化时就会创建底层数组 扩容时会创建一个扩容后的新数组，然后将原来数组的数据拷贝到新数组中1234567891011121314151617181920212223242526272829303132333435363738private void addEntry(int hash, K key, V value, int index) { ... if (count &gt;= threshold) {//数据个数大于等于阈值时进行扩容 rehash(); ... } ...}//扩容函数protected void rehash() { int oldCapacity = table.length; Entry&lt;?,?&gt;[] oldMap = table; //此处将oldCapacity左移一位，即将其扩大一倍 int newCapacity = (oldCapacity &lt;&lt; 1) + 1; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) { if (oldCapacity == MAX_ARRAY_SIZE) return; newCapacity = MAX_ARRAY_SIZE; } Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity]; modCount++; //重新计算容量阈值 threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); table = newMap; //拷贝数据 for (int i = oldCapacity ; i-- &gt; 0 ;) { for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) { Entry&lt;K,V&gt; e = old; old = old.next; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = (Entry&lt;K,V&gt;)newMap[index]; newMap[index] = e; } }} HashMap 默认初始化容量为16个 容量阈值默认为当前容量的0.75倍，当集合数据大于等于阈值时就会进行扩容 底层数据的容量要求一定是2的幂次方 扩容时会将容量变为原来的2倍 初始化时不会创建底层数组，而是在调用put方法添加数据时再创建底层数据 扩容时会创建一个扩容后的新数组，然后将原来数组的数据拷贝到新数组中1234567891011121314151617181920212223242526272829303132333435363738394041final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length;//初始化创建底层数组 ... if (++size &gt; threshold)//元素个数大于等于阈值则进行扩容 resize(); afterNodeInsertion(evict); return null;}//初始化或扩容函数final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) { if (oldCap &gt;= MAXIMUM_CAPACITY) {//MAXIMUM_CAPACITY=2^30 threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)//此处的newCap = oldCap &lt;&lt; 1则是进行数组扩容一倍 newThr = oldThr &lt;&lt; 1; // double threshold } else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);//重新计算新的阈值 } threshold = newThr; .... return newTab;} TreeMap 因为TreeMap是树结构，所以不存在容量和扩容的问题 初始化时不会创建其根节点，而是在调用put方法添加数据时才会创建其根节点 线程安全性Hashtable其方法都采用了synchronized修饰，因此是线程安全的，不会出现两个线程同时对数据进行操作的情况，它保证了线程安全性。但也因为这样导致其在多线程环境下使用此集合效率低下，因为一个线程访问其同步方法时，其他访问Hashtable的线程都会处于阻塞状态，现在已不推荐使用此集合。 HashMapHashMap的方法没有采用synchronized修饰，所以是非线程安全的，在程序中任一时刻可能会存在多个线程同时修改其数据，从而导致数据不一致。 在多线程环境下，我们可以使用下面两种方式使用HashMap 使用Collections.synchronizedMap()方法将HashMap转换为线程安全的SynchronizedMap包装类,其内部也是使用synchronized来达到同步效果，只不过此时锁住的是一个Object类型的成员变量,和锁住HashMap对象本身效果是一样，效率也比较低下，仅仅适合用在并发度不高的情景。 使用ConcurrentHashMap集合，相较于Hashtable锁住的是对象整体， ConcurrentHashMap基于lock实现锁分段技术。首先将Map存放的数据分成一段一段的存储方式，然后给每一段数据分配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。ConcurrentHashMap不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升 TreeMapHashMap的方法没有采用synchronized修饰，所以TreeMap也是非线程安全的。 在多线程环境下建议使用ConcurrentSkipListMap代替 HashMap的哈希冲突HashMap采用链地址法来解决哈希冲突，对哈希冲突或链地址法不了解的同学请参考我的另外一篇文章Hash冲突解决方法 但是在HashMap中对链地址法采用了一点点变化，对于哈希冲突导致出现同义词元素显示采用单链表存放，当这个链表大小超过一个阈值(TREEIFY_THRESHOLD=8)且HashMap的大小大于等于另一个容量阈值(MIN_TREEIFY_CAPACITY = 64),就会把这个单链表该造为树形结构。 1234567891011121314151617181920212223242526272829303132333435363738394041final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //此处判断链表的大小是否超过阈值 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } ... } } ... } ... return null;}final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) { int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) { //HashMap的元素大小大于等于MIN_TREEIFY_CAPACITY则将该单链表改造成红黑树 //树改造逻辑 }} 为什么要改造呢，我的理解是这样的： 因为单链表适合数据的插入和删除，而对于查询来说其效率要低一点，在单链表数据量小的时候，查询遍历的效率可能影响不太大，而当单链表数据量变大之后，其查询带来的性能影响就没法忽略了，所以这里就对单链表改造为红黑树，这样其key是有序的，查询的时候性能就要提高很多。 还有一种说法是因为安全性。因为构造哈希冲突的数据难度不大，会有人利用恶意代码产生大量这种数据与服务器交互，导致服务器CPU资源被大量占用，这样就会导致哈希碰撞拒绝服务器攻击。 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Java-HashMap-Hashtable-TreeMap.html"},{"title":"Android中用Kotlin Coroutine(协程)和Retrofit进行网络请求和取消请求","text":"Kotlin Coroutine(协程)系列：1. Kotlin Coroutine(协程) 简介2. Kotlin Coroutine(协程) 基本知识3. Android中用Kotlin Coroutine(协程)和Retrofit进行网络请求和取消请求 前面两篇文章介绍了协程的一些基本概念和基本知识，这篇则介绍在Android中如何使用协程配合Retrofit发起网络请求，同时介绍在使用协程时如何优雅的取消已经发起的网络请求。此篇文章的Demo地址：https://github.com/huyongli/AndroidKotlinCoroutine 创建CoroutineScope在前面的文章中我写到CoroutineScope.launch方法是一个很常用的协程构建器。因此使用协程必须先得创建一个CoroutineScope对象，代码如下：1CoroutineScope(Dispatchers.Main + Job()) 上面的代码创建了一个CoroutineScope对象，为其协程指定了在主线程中执行，同时分配了一个Job 在demo中我使用的是MVP模式写的，所以我将CoroutineScope的创建放到了BasePresenter中，代码如下：12345678910111213141516171819202122232425interface MvpViewinterface MvpPresenter&lt;V: MvpView&gt; { @UiThread fun attachView(view: V) @UiThread fun detachView()}open class BasePresenter&lt;V: MvpView&gt; : MvpPresenter&lt;V&gt; { lateinit var view: V val presenterScope: CoroutineScope by lazy { CoroutineScope(Dispatchers.Main + Job()) } override fun attachView(view: V) { this.view = view } override fun detachView() { presenterScope.cancel() }} 使用CoroutineScope.cancel()取消协程大家应该可以看到上面BasePresenter.detachView中调用了presenterScope.cancel()，那这个方法有什么作用呢，作用就是取消掉presenterScope创建的所有协程和其子协程。 前面的文章我也介绍过使用launch创建协程时会返回一个Job对象，通过Job对象的cancel方法也可以取消该任务对应的协程，那我这里为什么不使用这种方式呢？ 很明显，如果使用Job.cancel()方式取消协程，那我创建每个协程的时候都必须保存返回的Job对象，然后再去取消，显然要更复杂点，而使用CoroutineScope.cancel()则可以一次性取消该协程上下文创建的所有协程和子协程，该代码也可以很方便的提取到基类中，这样后面在写业务代码时也就不用关心协程与View的生命周期的问题。 其实大家看源码的话也可以发现CoroutineScope.cancel()最终使用的也是Job.cancel()取消协程 扩展Retrofit.Call适配协程1234567891011121314151617interface ApiService { @GET(\"data/iOS/2/1\") fun getIOSGank(): Call&lt;GankResult&gt; @GET(\"data/Android/2/1\") fun getAndroidGank(): Call&lt;GankResult&gt;}class ApiSource { companion object { @JvmField val instance = Retrofit.Builder() .baseUrl(\"http://gank.io/api/\") .addConverterFactory(GsonConverterFactory.create()) .build().create(ApiService::class.java) }} 大家可以看到上面的api接口定义应该很熟悉，我们可以通过下面的代码发起异步网络请求123456789ApiSource.instance.getAndroidGank().enqueue(object : Callback&lt;T&gt; { override fun onFailure(call: Call&lt;T&gt;, t: Throwable) { } override fun onResponse(call: Call&lt;T&gt;, response: Response&lt;T&gt;) { }}) 前面的文章介绍过协程可以让异步代码像写同步代码那样方便，那上面这段异步代码能不能使用协程改造成类似写同步代码块那样呢？很显然是可以的，具体改造代码如下：123456789101112131415161718192021//扩展Retrofit.Call类，为其扩展一个await方法，并标识为挂起函数suspend fun &lt;T&gt; Call&lt;T&gt;.await(): T { return suspendCoroutine { enqueue(object : Callback&lt;T&gt; { override fun onFailure(call: Call&lt;T&gt;, t: Throwable) { //请求失败，抛出异常，手动结束当前协程 it.resumeWithException(t) } override fun onResponse(call: Call&lt;T&gt;, response: Response&lt;T&gt;) { if(response.isSuccessful) { //请求成功，将请求结果拿到并手动恢复所在协程 it.resume(response.body()!!) } else{ //请求状态异常，抛出异常，手动结束当前协程 it.resumeWithException(Throwable(response.toString())) } } }) }} 上面的代码扩展了一个挂起函数await，执行该方法时，会执行Retrofit.Call的异步请求同时在协程中挂起该函数，直到异步请求成功或者出错再重新恢复所在协程。 suspendCoroutine全局函数，此函数可以获取当前方法所在协程上下文，并将当前协程挂起，直到某个时机再重新恢复协程执行，但是这个时机其实是由开发者自己控制的，就像上面代码中的it.resume和it.resumeWithException。 发起请求，写法一1234567891011121314151617181920212223242526272829303132333435//使用CoroutineScope.launch创建一个协程，此协程在主线程中执行presenterScope.launch { val time = System.currentTimeMillis() view.showLoadingView() try { val ganks = queryGanks() view.showLoadingSuccessView(ganks) } catch (e: Throwable) { view.showLoadingErrorView() } finally { Log.d(TAG, \"耗时：${System.currentTimeMillis() - time}\") }}suspend fun queryGanks(): List&lt;Gank&gt; { //此方法执行线程和调用者保持一致，因此也是在主线程中执行 return try { //先查询Android列表，同时当前协程执行流程挂起在此处 val androidResult = ApiSource.instance.getAndroidGank().await() //Android列表查询完成之后恢复当前协程，接着查询IOS列表，同时将当前协程执行流程挂起在此处 val iosResult = ApiSource.instance.getIOSGank().await() //Android列表和IOS列表都查询结束后，恢复协程，将两者结果合并，查询结束 val result = mutableListOf&lt;Gank&gt;().apply { addAll(iosResult.results) addAll(androidResult.results) } result } catch (e: Throwable) { //处理协程中的异常，否则程序会崩掉 e.printStackTrace() throw e }} 从上面的代码大家可以发现，协程中对异常的处理使用的是try-catch的方式，初学，我也暂时只想到了这种方式。所以在使用协程时，最好在业务的适当地方使用try-catch捕获异常，否则一旦协程执行出现异常，程序就崩掉了。 另外上面的代码的写法还有一个问题，因为挂起函数执行时会挂起当前协程，所以上述两个请求是依次顺序执行，因此上面的queryGanks()方法其实是耗费了两次网络请求的时间，因为请求Android列表和请求ios列表两个请求不是并行的，所以这种写法肯定不是最优解。 发起请求，写法二下面我们再换另外一种写法。1234567891011121314151617181920212223242526272829303132333435suspend fun queryGanks(): List&lt;Gank&gt; { /** * 此方法执行线程和调用者保持一致，因此也在主线程中执行 * 因为网络请求本身是异步请求，同时async必须在协程上下文中执行，所以此方法实现中采用withContext切换执行线程到主线程，获取协程上下文对象 */ return withContext(Dispatchers.Main) { try { //在当前协程中创建一个新的协程发起Android列表请求，但是不会挂起当前协程 val androidDeferred = async { val androidResult = ApiSource.instance.getAndroidGank().await() androidResult } //发起Android列表请求后，立刻又在当前协程中创建了另外一个子协程发起ios列表请求，也不会挂起当前协程 val iosDeferred = async { val iosResult = ApiSource.instance.getIOSGank().await() iosResult } val androidResult = androidDeferred.await().results val iosResult = iosDeferred.await().results //两个列表请求并行执行，等待两个请求结束之后，将请求结果进行合并 //此时当前方法的执行时间实际上两个请求中耗时时间最长的那个，而不是两个请求所耗时间的总和，因此此写法优于上面一种写法 val result = mutableListOf&lt;Gank&gt;().apply { addAll(iosResult) addAll(androidResult) } result } catch (e: Throwable) { e.printStackTrace() throw e } }} 这种写法与前一种写法的区别是采用async构建器创建了两个子协程分别去请求Android列表和IOS列表，同时因为async构建器执行的时候不会挂起当前协程，所以两个请求是并行执行的，因此效率较上一个写法要高很多。 发起请求，写法三第三个写法就是在Retorfit的CallAdapter上做文章，通过自定义实现CallAdapterFactory，将api定义时的结果Call直接转换成Deferred,这样就可以同时发起Android列表请求和IOS列表请求，然后通过Deferred.await获取请求结果，这种写法是写法一写法二的结合。 这种写法JakeWharton大神早已为我们实现了，地址在这https://github.com/JakeWharton/retrofit2-kotlin-coroutines-adapter 这里我就不说这种方案的具体实现了，感兴趣的同学可以去看其源码。 写法三的具体代码如下：12345678910111213141516171819202122232425262728val instance = Retrofit.Builder() .baseUrl(\"http://gank.io/api/\") .addCallAdapterFactory(CoroutineCallAdapterFactory()) .addConverterFactory(GsonConverterFactory.create()) .build().create(CallAdapterApiService::class.java) suspend fun queryGanks(): List&lt;Gank&gt; { return withContext(Dispatchers.Main) { try { val androidDeferred = ApiSource.callAdapterInstance.getAndroidGank() val iosDeferred = ApiSource.callAdapterInstance.getIOSGank() val androidResult = androidDeferred.await().results val iosResult = iosDeferred.await().results val result = mutableListOf&lt;Gank&gt;().apply { addAll(iosResult) addAll(androidResult) } result } catch (e: Throwable) { e.printStackTrace() throw e } }} 上面的第三种写法看起来更简洁，也是并行请求，耗时为请求时间最长的那个请求的时间，和第二种差不多。 具体实现demo的地址见文章开头，有兴趣的可以看看。 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Kotlin-Coroutine-For-Android-Network.html"},{"title":"Lucene近实时搜索应用总结","text":"最近因工作需要，用到了Lucene，在需求中，需要对生成的索引文件不断的更新、新增、删除等操作，同时还要实时的看到索引改动后的数据，在使用过程中碰到了Lucene里几个比较常见的问题，特来总结记录下。 我使用的是Lucene4.3，本来是想使用最高的版本Lucene4.9的(不知道现在又有么有新的版本出现)，但是因为公司项目的JDK都是JDK6的，而Lucene4.9的支持的最低JDK版本是7+的，所以最后选择了这个版本。第一次碰这个东东，也是在网上搜罗各种资料，当然官网是少不了的，还有一个网址，这个里面的版本更全面，包含了Lucene所有的版本，有需要的可以去下载自己想要的版本。 OK，进入正题。 在读取索引文件内容时，索引文件的打开操作 new IndexSearcher(DirectoryReader.open(FSDirectory.open(new File(indexPath)))) 是个非常耗时耗资源的操作，所以在搜索索引数据时把IndexSearcher对象给缓存起来可以提高搜索性能，这个地方可以将索引目录对应的IndexSearcher对象做成一个单例模式进行获取。 在问题1的操作基础上，我对索引进行了更新操作，紧接着我就发现了一个问题，索引更新后我查询出来的结果和我更新后的结果对不上号。再网上查了半天没找到原因，后来在一个群里请教之后，才知道更新完索引之后，索引文件需要重新打开，否则搜索得到的还是原来索引的数据，Lucene里面的这个原理非常重要。 因为当时对Lucene了解的不是很多，所以为了每次更新后能搜索到正确的数据，我的做法是每次更新完索引就将我之前缓存的IndexSearcher对象和Reader对象给移除掉，下次搜索时重新打开索引，这样来保证搜索结果的正确性。 索引的更新代码大致如下：123456789101112131415161718//获取索引的写对象 public static IndexWriter getIndexWriter(String indexPath) throws Exception { Directory dir = FSDirectory.open(new File(indexPath)); if(IndexWriter.isLocked(dir)) { IndexWriter.unlock(dir); } IndexWriterConfig iwriterConfig = new IndexWriterConfig(Version.LUCENE_43, new ComplexAnalyzer()); IndexWriter indexWriter=new IndexWriter(dir, iwriterConfig); return indexWriter; } //索引更新操作，索引中的更新逻辑是将旧的文档删除，再将新的文档新增进去 public static void updateLucene(String indexPath，要更新的数据参数) { IndexSearcher indexSearcher = getIndexSearcher(indexPath); Document oldDoc = ....//根据IndexSearcher查询得到被更新的旧文档--1处 Document newDoc = ....//根据旧文档和要更新的具体数据得到要更新的新文档 indexWriter.updateDocument(doc);//更新操作--3处 removeReader(indexPath);//移除IndexSearcher缓存对象--2处} 问题3中的这个跟新操作写完之后实际应用的时候，出了好几个问题，都是Lucene里面比较常见，容易犯错的问题。异常1：org.apache.lucene.store.AlreadyClosedException: this IndexReader is closed经过分析之后发现是因为多并发情况下时，同一个索引文件对应的Reader对象别多个线程持有，在我这个代码里存在线程1刚好执行完2处代码将Reader缓存清理掉(同时关掉了该Reader对象)，而刚好，线程2在执行代码1处的查询操作，这个时候就会出现这个异常。在我这个代码里的更新操作总共分3部，首先查询出旧的文档，紧接着构造新文档并执行更新操作，第三步是移除缓存，所以这三步应该归结为一个原子操作，所以我很自然的就想到了同步锁synchronized，在该方法上添加Class级的同步锁，由于我的代码里有多个这种更新索引的方法，所以每个方法都加一个同步锁，后来证明这种方式也不行仍然出现了该异常，具体代码的问题出在哪我现在真记不起来了，而且这种多个静态方法都加Class级的同步锁性能注定不怎么样，后续的解决办法下面问题中继续说。异常2：LockObtainFailedException经过查询资料知道这是因为在IndexWriter的构造函数在试图获取另外一个IndexWriter已经加锁的索引目录时抛出的错误，这是因为在Lucene中只能允许一个线程去进行写操作，当该线程获取到这个写对象后，会在索引目录中生成一个write.lock文件，所以在这个线程没有释放该索引目录的锁对象前，其他线程无法获取该目录的写对象，根据这个write.lock文件，我们可以很方便的判断当前索引目录有没有被写对象占用，改造后的代码如下： 12345678910111213141516171819202122232425262728private Object synchronized_w = new Object(); private IndexWriter getIndexWriter() { synchronized (synchronized_w) { try { Directory dir = null; while (true) { dir = FSDirectory.open(new File(indexPath)); if(!IndexWriter.isLocked(dir)) { if(indexWriter == null) { indexWriter = new IndexWriter(dir, new IndexWriterConfig(Version.LUCENE_43, LuceneManager.getAnalyzer())); } break; } else { try { dir.close(); Thread.sleep(100); Thread.yield(); } catch (InterruptedException e) { logger.error(\"获取索引\" + indexPath + \"写对象IndexWriter失败\", e); } } } } catch (Exception e) { logger.error(\"获取索引\" + indexPath + \"写对象IndexWriter失败\", e); } } return indexWriter; } 获取索引写对象的代码经过如此改造之后，成功运行，没有出现问题。 继续问题4中的第一个异常，分析之后觉得问题出现的最终原因还是在第三步移除缓存时关闭Reader对象这里，所以如果Lucene能不需要手动关闭Reader对象就可以解决这个问题，带着这个问题我重新去查看了Lucene4.3的API文档，看了之后发现了两个个比较重要的API，DirectoryReader.openIfChanged(dirReader)和DirectoryReader.isCurrent()，前者是个静态方法，可以判断当前Reader对象的索引有没有被修改过，如果索引文件被更新过则重新加载该索引目录，但是这个时候的重新加载则比单纯的open(indexPath)要高效很多，它只是重新加载被更新过的文档，而单纯的open则是加载全部的文档，重新加载后我们查询的时候就可以查询到最新的数据结果了。而第二个API是个实例方法，用来判断当前Reader对象所代表的索引文件是不是最开始那个，即判断当前索引文件有没有被更新过，有更新则返回false，否则返回true，则两个API结合在一起刚好可以解决我之前的Reader关闭问题。有了这种重新加载机制，我就不需要每次更新索引之后清除缓存关掉旧的Reader对象并打开新的对象。改造的代码如下： 123456789101112131415161718public IndexSearcher getIndexSearcher() { synchronized (lock_r) { try { if(indexSearcher == null &amp;&amp; dirReader == null) { dirReader = DirectoryReader.open(FSDirectory.open(new File(indexPath))); indexSearcher = new IndexSearcher(dirReader); } else if(indexSearcher != null &amp;&amp; dirReader != null &amp;&amp; !dirReader.isCurrent()) { //判断有没有更新过，有更新则重新加载更新过的文档 DirectoryReader newDirReader = DirectoryReader.openIfChanged(dirReader); indexSearcher = new IndexSearcher(newDirReader); dirReader = newDirReader; } } catch (IOException e) { logger.error(\"获取索引\" + indexPath + \"搜索对象IndexSearcher失败\", e); } } return indexSearcher; } 这个代码里面有个问题就是旧的Reader对象没有关闭掉，如果加上这reader.close()这句话又会出现那个异常，不加的话运行没有问题，但是我总觉得不关掉不太好，感觉占着资源。然后继续查看API文档，发现了SearcherManager这个类，这个是Lucene里面提供的工具类，主要是用来了管理IndexSearcher对象的，仔细阅读了该类的说明及其源代码后觉得用这个工具类更靠谱，所以最后毫不犹豫的重新写了一个IndexSearcher对象的获取方式，代码如下： 1234567891011121314151617private IndexSearcher getIndexSearcher() throws IOException { IndexSearcher indexSearcher = null; synchronized (synchronized_r) { if(searcherManager == null) { searcherManager = new SearcherManager(FSDirectory.open(new File(indexPath)), new SearcherFactory()); } searcherManager.maybeRefresh();//这个方法同DirectoryReader.openIfChanged(dirReader)效果一样，其实底层还是调用的该方法实现的 indexSearcher = searcherManager.acquire();//借用一个IndexSearcher对象的引用，记住该对象用完之后要归还的，有借有还再借不难 } return indexSearcher;}private void closeIndexSearcher(IndexSearcher indexSearcher) throws IOException { if(indexSearcher != null) { searcherManager.release(indexSearcher);//归还从SearcherManager处借来的IndexSearcher对象 } indexSearcher = null;} 如此实现之后，就不需要我们自己管理这个旧的Reader对象，而是交由Lucene本身自己去进行管理，而且此种实现方式更简洁明了，也完美解决了我的问题。 实现了索引更新后的数据的读取实时性就可以实现一个简单的实时搜索功能。 最后为了保证项目中Lucene使用的稳定性，我对索引文件的更新和查询都添加了读写锁ReentrantReadWriteLock来进行控制，更新的时候添加写锁，查询的时候添加读锁，这样更加的保证了Lucene使用的安全性。 简单介绍下读写锁ReentrantReadWriteLock的机制(多线程并发的时候很有用)： 在某个线程获取到读锁时，其他线程不能获取写锁，但是可以获取读锁 在某个线程获取到写锁时，其他线程既不能获取写锁也不能获取读锁 给个示例代码：1234567891011121314private ReentrantReadWriteLock w_lock = new ReentrantReadWriteLock();//读写锁 public void updateDocument(Term term, Document doc) throws Exception { try { w_lock.writeLock().lock();//获得写锁 getIndexWriter(); indexWriter.updateDocument(term, doc); indexWriter.commit(); } catch (IOException e) { throw new Exception(e); } finally { closeIndexWriter(); w_lock.writeLock().unlock();释放写锁 } } OK，到这里我的问题基本上就写完了，有时间再去研究研究Lucene的其他的特性。 write by laohu2014年12月11日19:12:55 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Lucene近实时搜索应用总结.html"},{"title":"关于媒体浏览器服务(MediaBrowserService)","text":"今天说的这个主题与媒体播放有关，尤其是音乐播放，说到音乐播放大家应该都用过音乐App。通常一个音乐App的实现主要涉及如下几点： 从服务器获取音乐数据 播放音乐时播放器的各种播放状态以及不同状态下的UI展示 播放过程中通过UI界面控制播放器的各种状态 UI控制如何与播放服务进行关联并进行状态同步 如何保证后台播放过程中播放服务不被杀死 对于上面的这几点，其实Android已经为我们提供了一套完整的解决方案，它已经很好的将这些操作进行了封装，我们只需要关注数据的获取和歌曲的播放即可。Android提供的这套API在support-v4中提供了兼容版本，因此在使用的过程中最好使用该版本以兼容低版本系统。 关键类主要有如下几个： MediaBrowserServiceCompat 媒体浏览器服务 MediaBrowserCompat 媒体浏览器 MediaControllerCompat 媒体控制器 MediaSessionCompat 媒体会话我们一个个来说。 MediaBrowserServiceCompat该类有两个作用： 音乐播放后台服务 客户端中获取音乐数据的服务，所有的音乐数据都通过该服务与服务端进行交互获取(或者直接获取手机中的本地音乐数据) 既然知道该类是Service的子类实现，所以说它是音乐播放的后台服务也好理解，但是该类作为一个后台播放服务却不是通过其自身直接实现的，而是通过MediaSessionCompat媒体会话这个类来实现的。在使用过程中媒体会话会与该服务关联起来，所有的播放操作都交由MediaSessionCompat实现。 而对于获取数据，则是通过MediaBrowserServiceCompat的如下两个方法来进行控制：123456789101112131415161718192021222324252627282930313233343536@Overridepublic BrowserRoot onGetRoot(@NonNull String clientPackageName, int clientUid, Bundle rootHints) { /** * 在返回数据之前，可以进行黑白名单控制，以控制不同客户端浏览不同的媒体资源 * */ if(!PackageUtil.isCallerAllowed(this, clientPackageName, clientUid)) { return new BrowserRoot(null, null); } //此方法只在服务连接的时候调用 //返回一个rootId不为空的BrowserRoot则表示客户端可以连接服务，也可以浏览其媒体资源 //如果返回null则表示客户端不能流量媒体资源 return new BrowserRoot(BrowserRootId.MEDIA_ID_ROOT, null);}@Overridepublic void onLoadChildren(@NonNull String parentId, @NonNull Result&lt;List&lt;MediaItem&gt;&gt; result) { /*** * 此方法中的parentId与上面的方法onGetRoot中返回的RootId没有关系 * 客户端连接后，它可以通过重复调用MediaBrowserCompat.subscribe() 方法来发起数据获取请求。 * 而每次调用subscribe() 方法都会发送一个onLoadChildren（）回调到该service中，然后返回一个MediaBrowser.MediaItem(音乐数据) 对象列表 * * 每个MediaItem 都有唯一的ID字符串，它其实是一个隐式的token。 * 当客户想打开子菜单或播放一个item时，它就将ID传入。 */ if(BrowserRootId.MEDIA_ID_MUSIC_LIST_REFRESH.equals(parentId)) { //在当前方法执行结束返回之前必须要调用result.detach(),否则无法发起请求 result.detach(); MusicProvider.getInstance().requestMusic(result); //如果想要通过http请求来获取数据，则必须按照上面说的必须要先调用result.detach();方法，否则会出现异常。http请求结束之后则通过调用result.sendResult(mMetadataCompatList);将数据返回,返回的数据在注册的接口MediaBrowserCompat.SubscriptionCallback中通过回调拿到在界面上进行展示 //而且此处返回的数据类型必须是MediaBrowser.MediaItem } else { result.detach(); }} MediaBrowserCompat前面说过MediaBrowserServiceCompat(媒体浏览服务)是作为数据请求服务来获取数据的，因此相应的会有一个媒体浏览客户端来发起媒体数据的获取请求，该类就是这个客户端。前面已经介绍过通过调用MediaBrowserCompat.subscribe()方法来发起数据请求，而在调用此方法之前，必须保证MediaBrowserCompat连接上媒体浏览服务，连接方式如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//通过如下代码连接MediaBrowserServiceCompat，连接成功后获取媒体会话token//通过媒体会话token创建MediaControllerCompat //这时就将MediaControllerCompat与媒体会话MediaSessionCompat关联起来了MediaBrowserCompat mediaBrowser = new MediaBrowserCompat(this, new ComponentName(this, MusicService.class), mConnectionCallback, null);//连接媒体浏览服务成功后的回调接口final MediaBrowserCompat.ConnectionCallback mConnectionCallback = new MediaBrowserCompat.ConnectionCallback() { @Override public void onConnected() { try { //获取与MediaBrowserServiceCompat关联的媒体会话token MediaSessionCompat.Token token = mMediaBrowser.getSessionToken(); //通过媒体会话token创建媒体控制器并与之关联 //关联之后媒体控制器就可以控制播放器的各种播放状态了 MediaControllerCompat mediaController = new MediaControllerCompat(this, token); //将媒体控制器与当前上下文Context进行关联 //此处关联之后，我们在界面上操作某些UI的时候就可以通过当前上下文Context来获取当前的MediaControllerCompat //MediaControllerCompat controller = MediaControllerCompat.getMediaController((Activity) context); MediaControllerCompat.setMediaController(this, mediaController); //为媒体控制器注册回调接口 mediaController.registerCallback(mMediaControllerCallback); } catch (RemoteException e) { onMediaControllerConnectedFailed(); } } };//媒体控制器控制播放过程中的回调接口final MediaControllerCompat.Callback mMediaControllerCallback = new MediaControllerCompat.Callback() { @Override public void onPlaybackStateChanged(@NonNull PlaybackStateCompat state) { //播放状态发生改变时的回调 onMediaPlayStateChanged(state); } @Override public void onMetadataChanged(MediaMetadataCompat metadata) { if(metadata == null) { return; } //播放的媒体数据发生变化时的回调 onPlayMetadataChanged(metadata); } };//发起数据请求 //先解除订阅 mediaBrowser.unsubscribe(BrowserRootId.MEDIA_ID_MUSIC_LIST_REFRESH); //重新对BrowserRootId进行订阅 //调用此方法后，会接着执行MusicService中的onGetRoot方法和onLoadChildren方法 //onGetRoot方法(只会调用一次)决定是否允许当前客户端连接服务和获取媒体数据 //如果允许连接服务同时也允许获取媒体数据，则会接着调用onLoadChildren方法开始获取数据 //数据获取成功后会调用订阅的回调接口将数据返回回来 mediaBrowser.subscribe(BrowserRootId.MEDIA_ID_MUSIC_LIST_REFRESH, mSubscriptionCallback);//向媒体流量服务发起媒体浏览请求的回调接口final MediaBrowserCompat.SubscriptionCallback mSubscriptionCallback = new MediaBrowserCompat.SubscriptionCallback() { @Override public void onChildrenLoaded(@NonNull String parentId, @NonNull List&lt;MediaBrowserCompat.MediaItem&gt; children) { //数据获取成功后的回调 } @Override public void onError(@NonNull String id) { //数据获取失败的回调 } }; MediaSessionCompat前面说过MediaBrowserServiceCompat的媒体播放其实是通过关联的MediaSessionCompat来实现的，而其关联方式也很简单：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455MediaSessionCompat mSession = new MediaSessionCompat(this, \"MusicService\");setSessionToken(mSession.getSessionToken());mSession.setCallback(new MediaSessionCompat.Callback());mSession.setFlags(MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS | MediaSessionCompat.FLAG_HANDLES_TRANSPORT_CONTROLS);//MediaSessionCompat的播放控制则又全部是通过接口MediaSessionCompat.Callback来实现的@Override public void onPlay() {//点击播放按钮时触发//通过MediaControllerCompat .getTransportControls().play();触发 } @Override public void onSkipToQueueItem(long queueId) { //播放指定对列媒体时触发 //通过MediaControllerCompat .getTransportControls().onSkipToQueueItem(queueId);触发 } @Override public void onSeekTo(long position) { //设置到指定进度时触发 //MediaControllerCompat.getTransportControls().seekTo(position); } @Override public void onPlayFromMediaId(String mediaId, Bundle extras) {//播放指定媒体数据时触发//MediaControllerCompat.getTransportControls().playFromMediaId(mediaItem.getMediaId(), null); } @Override public void onPause() {//暂停时触发//MediaControllerCompat.getTransportControls().pause(); } @Override public void onStop() {//停止播放时触发//MediaControllerCompat.getTransportControls().stop(); } @Override public void onSkipToNext() {//跳到下一首时触发//MediaControllerCompat.getTransportControls().skipToNext(); } @Override public void onSkipToPrevious() {//跳到上一首时触发//MediaControllerCompat.getTransportControls().skipToPrevious(); }//当然还有很多回调函数，大家可以自行查看} MediaControllerCompat媒体控制器在上面已经介绍了其创建和关联方式，而它控制播放器状态的方式在上面的代码注释中已经说明了，基本上都是通过MediaControllerCompat.getTransportControls()来进行控制的。 到这里媒体服务的相关使用和注意点已经介绍完了，使用这套api来实现音乐APP还是很方便很快捷的，而且我们可以很方便的切换播放器，如MediaPlayer,ExoPlayer等，如有建议和问题欢迎在博客关于页中扫码加QQ群交流。 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/MediaBrowserService.html"},{"title":"Android基础之9-Patch(9.PNG)与padding","text":"在上一篇文章记一次9.png的填坑之旅最后，我留了两个个问题： 为什么使用9.PNG设置背景之后会改变控件的padding属性值 在我所遇到的问题中9.PNG明明改变的是padding值为什么却产生了margin的效果 这篇文章就来解答这两个问题以及9.PNG使用过程中需要注意的地方。 各位同学如果没看过记一次9.png的填坑之旅这篇文章可以先去看看，因为我下面所讲的内容都是根据这篇文章中的问题来讲的。 问题9-Patch图还是先来看下我所使用的9.PNG的图从图中可以看出中间那一片白色区域是内容区，而内容区到底部的黑边线之间还一段透明的区域，这段区域是不会显示内容的。 结论猜想看到这个透明区域联想到我上面遇到的问题 明明改变的是padding却产生了margin的效果 大家是不是会出现一个猜想，难道上篇文章中padding改变却出现margin效果是因为这个透明的区域导致的？ 恭喜你，答对了，我前面遇到的问题中padding改变却产生margin效果就是因为这个透明区域导致的。 你可能又要接着问了，这是为什么呢？ 不要走开，下面我就来说说其中的原因。 一探setBackgroundResource我们来看看布局设置背景图片的方法setBackgroundResource(int resid)是如何实现的1234567891011 public void setBackgroundResource(int resid) { if (resid != 0 &amp;&amp; resid == mBackgroundResource) { return; } Drawable d = null; if (resid != 0) { d = mContext.getDrawable(resid); } setBackground(d); mBackgroundResource = resid;} 上面的代码可以看到调用了setBackground(Drawable drawable)这个方法，我们接着看123public void setBackground(Drawable background) { setBackgroundDrawable(background);} 我们接着看setBackgroundDrawable(Drawable drawable)这个方法的实现123456789101112131415161718192021222324252627282930313233public void setBackgroundDrawable(Drawable background) { ... if (background != null) { Rect padding = sThreadLocal.get(); if (padding == null) { padding = new Rect(); sThreadLocal.set(padding); } resetResolvedDrawables(); background.setLayoutDirection(getLayoutDirection()); if (background.getPadding(padding)) { resetResolvedPadding(); switch (background.getLayoutDirection()) { case LAYOUT_DIRECTION_RTL: mUserPaddingLeftInitial = padding.right; mUserPaddingRightInitial = padding.left; internalSetPadding(padding.right, padding.top, padding.left, padding.bottom); break; case LAYOUT_DIRECTION_LTR: default: mUserPaddingLeftInitial = padding.left; mUserPaddingRightInitial = padding.right; internalSetPadding(padding.left, padding.top, padding.right, padding.bottom); } mLeftPaddingDefined = false; mRightPaddingDefined = false; } ... } else { ... } ...} 上面的代码很明显可以看到当background.getPadding(padding)返回true的时候当前布局视图会通过internalSetPadding(padding.left, padding.top, padding.right, padding.bottom)给当前视图设置相应的padding值 NinePatchDrawable因为我们使用的是9-Patch，所以生成的Drawable对象是NinePatchDrawable实例，我们接着上面的源码流程继续查看NinePatchDrawable.getPadding(Rect padding)方法：12345678910111213public boolean getPadding(Rect padding) { final Rect scaledPadding = mPadding; if (scaledPadding != null) { if (needsMirroring()) { padding.set(scaledPadding.right, scaledPadding.top, scaledPadding.left, scaledPadding.bottom); } else { padding.set(scaledPadding); } return (padding.left | padding.top | padding.right | padding.bottom) != 0; } return false;} 上面的方法很明显可以看出，如果当前9-Patch图存在Padding值的话，它会将该值设置到参数Rect中，而在前面setBackgroundDrawable(Drawable drawable)方法实现中方法internalSetPadding(padding.left, padding.top, padding.right, padding.bottom)里所传的参数padding就是这个地方的Rect参数实例。 结论总结成一句话就是如果我们使用的9-Patch图生成的NinePatchDrawable对象存在Padding值，那么这些Padding值将会同时设置给使用该9-Patch作为背景图的View的Padding属性上 看了上面的结论，大家可能又会有一个疑问？？？ 我们使用的9-Patch图时，系统为我们生成NinePatchDrawable对象时产生的Padding是根据什么依据得来的呢？ 9-Patch官方定义OK，我们来看看Google官方对9-Patch图的定义和介绍https://developer.android.com/guide/topics/graphics/2d-graphics.html#nine-patch The border is used to define the stretchable and static areas of the image. You indicate a stretchable section by drawing one (or more) 1-pixel-wide black line(s) in the left and top part of the border (the other border pixels should be fully transparent or white). You can have as many stretchable sections as you want: their relative size stays the same, so the largest sections always remain the largest. You can also define an optional drawable section of the image (effectively, the padding lines) by drawing a line on the right and bottom lines. If a View object sets the NinePatch as its background and then specifies the View’s text, it will stretch itself so that all the text fits inside only the area designated by the right and bottom lines (if included). If the padding lines are not included, Android uses the left and top lines to define this drawable area. To clarify the difference between the different lines, the left and top lines define which pixels of the image are allowed to be replicated in order to stretch the image. The bottom and right lines define the relative area within the image that the contents of the View are allowed to lie within This NinePatch defines one stretchable area with the left and top lines and the drawable area with the bottom and right lines. In the top image, the dotted grey lines identify the regions of the image that will be replicated in order to stretch the image. The pink rectangle in the bottom image identifies the region in which the contents of the View are allowed. If the contents don’t fit in this region, then the image will be stretched so that they do. 上面这段几段文字是我引用的Android官方的介绍说明，里面介绍了9-Patch图的使用方式和要点。 9-Patch图Padding的由来大家注意看段落中我标红的那一句话，这句话就是说：如果你使用9-Patch图给某个View设置background之后，这个View的所有内容仅仅适配显示在内容区域里，而内容区域范围是由9-Patch图right and bottom lines决定的。而9-Patch图内容区以外的部分是不可能无故消失的，所以就作为其Padding了，因此在我们使用9-Patch图作为背景图时，系统为我们生成的NinePatchDrawable对象的Padding值就是根据这得来的。 回归问题知道上面的结论之后，我们再回过头来看我所遇到的问题，我们再看一遍我所使用的9-Patch图根据上面的结论可以发现这个图底部有一块透明的非内容区，因此我所使用的这个9-Patch图会产生一个paddingBottom值，而刚好这块区域又是透明，所以在使用的时候这块区域在视图上其实也是透明的，因此这块透明区域看到的效果其实是其父容器视图的内容，所以就造成了margin的效果。 讲到这里，我所遇到的那个问题就得到了完美的解答。 另外大家在使用9-Patch图的时候一定要注意其内容区域，如果9-Patch图制作不合适会产生一些莫名其妙的布局问题。 write by laohu2016年11月18日 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Nine-Patch-Affect-Padding-Principle.html"},{"title":"RecyclerView下拉刷新上拉加载","text":"背景作为ListView和GridView的替代者， RecyclerView以它的灵活性著称，而且有着更好更完善的缓存处理机制。但是在使用RecyclerVew的过程中有个很明显的问题：RecyclerView没有为开发者提供addHeadView和addFooterView两个接口，这就为RecyclerView的下拉刷新和上拉加载实现增加了难度，本文就为大家介绍RecyclerView的下拉刷新和上拉加载的实现方式。 下拉刷新其实RecyclerView的下拉刷新使用SwipeRefreshLayout组件实现还是非常简单的。 SwipeRefreshLayout也是Android SDK中为我们提供的一个布局容器类，它作为容器可以为它的子元素提供下拉刷新接口，而且使用方式也非常简单，我就直接上代码了123456789101112&lt;android.support.v4.widget.SwipeRefreshLayout android:id=\"@+id/swipeRefreshLayout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recyclerView\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt; 这就是RecyclerView结合SwipeRefreshLayout实现下拉刷新的布局方式，非常简单吧，写完布局文件之后，当然还要处理刷新的逻辑123456mSwipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() { @Override public void onRefresh() { //在此处实现刷新获取数据，然后更新RecyclerView的数据源即可 }}); 写完这两段代码之后，RecyclerView的下拉刷新就实现完成了，是不是很简单。不过还有个小小的问题需要注意下，那就是在刷新获取数据处理逻辑结束之后需要调用1mSwipeRefreshLayout.setRefreshing(false); 这个接口就是告诉SwipRefreshLayout刷新动作已经结束，刷新进度条可以不用再显示了，否则的话视图顶部的刷新进度条会一直存在，当然如果你手动调用1mSwipeRefreshLayout.setRefreshing(true); 这个接口的话，刷新进度条就会显示出来。 上拉加载由于RecyclerView中没有提供addFooterView接口，所以我们没有办法像ListView中那样直接添加一个FooterView作为上拉加载的视图。但是RecyclerView.Adapter中也提供了public int getItemViewType(int position)接口，我们可以为RecyclerView.Adapter指定两种ViewType，一个作为普通的ItemViewType用来显示普通数据视图，一个作为FooterViewType用来显示上拉加载视图，这样的话我们就需要在展示数据的基础上为RecyclerView.Adapter额外增加一条数据用来显示添加的FooterView，这个特定Adapter的实现逻辑如下： 定义两个ViewType分表用来区分普通是数据视图和上拉加载视图 12private static final int VIEW_TYPE_FOOTER = 0;private static final int VIEW_TYPE_ITEM = 1; 重写getItemCount()方法，在原有数据的基础上增加一条数据用来显示FooterView 12345@Overridepublic int getItemCount() { return mList.size() + 1;//在原有数据的基础增加一个数据用来显示FooterView} 重写getItemViewType(int position)方法，用来判断当前加载显示何种视图 12345678@Overridepublic int getItemViewType(int position) { if(position + 1 == getItemCount()) {//最后一条数据显示FooterView return VIEW_TYPE_FOOTER; } return VIEW_TYPE_ITEM;} 在onCreateViewHolder方法中根据viewType初始化对应的视图 12345678910@Overridepublic RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if(viewType == VIEW_TYPE_FOOTER) { return onCreateFooterViewHolder(parent, viewType); } else if(viewType == VIEW_TYPE_ITEM) { return onCreateItemViewHolder(parent, viewType); } return null;} 在onBindViewHolder方法中根据viewType绑定显示对应的视图数据 1234567891011121314@Overridepublic void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case VIEW_TYPE_ITEM: onBindItemViewHolder(holder, position); break; case VIEW_TYPE_FOOTER: onBindFooterViewHolder(holder, position, mLoadStatus); break; default: break; }} 整个Adapter完整的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146public class DemoAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; { private LoadStatus mLoadStatus = LoadStatus.CLICK_LOAD_MORE;//上拉加载的状态 private static final int VIEW_TYPE_FOOTER = 0; private static final int VIEW_TYPE_ITEM = 1; private List&lt;String&gt; mList; private Context mContext; public DemoAdapter(Context context, List&lt;String&gt; list) { mContext = context; mList = list; } @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if(viewType == VIEW_TYPE_FOOTER) { return onCreateFooterViewHolder(parent, viewType); } else if(viewType == VIEW_TYPE_ITEM) { return onCreateItemViewHolder(parent, viewType); } return null; } @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) { switch (getItemViewType(position)) { case VIEW_TYPE_ITEM: onBindItemViewHolder(holder, position); break; case VIEW_TYPE_FOOTER: onBindFooterViewHolder(holder, position, mLoadStatus); break; default: break; } } public RecyclerView.ViewHolder onCreateFooterViewHolder(ViewGroup parent, int viewType) { View view = View.inflate(mContext, R.layout.footer_layout, null); return new FooterViewHolder(view); } public RecyclerView.ViewHolder onCreateItemViewHolder(ViewGroup parent, int viewType) { View view = View.inflate(mContext, R.layout.item_layout, null); return new ItemViewHolder(view); } public void onBindFooterViewHolder(RecyclerView.ViewHolder holder, int position, LoadStatus loadStatus) { FooterViewHolder viewHolder = (FooterViewHolder) holder; switch (loadStatus) { case CLICK_LOAD_MORE: viewHolder.mLoadingLayout.setVisibility(View.GONE); viewHolder.mClickLoad.setVisibility(View.VISIBLE); break; case LOADING_MORE: viewHolder.mLoadingLayout.setVisibility(View.VISIBLE); viewHolder.mClickLoad.setVisibility(View.GONE); break; } } public void onBindItemViewHolder(RecyclerView.ViewHolder holder, int position) { ItemViewHolder viewHolder = (ItemViewHolder) holder; viewHolder.mTextView.setText(getItem(position)); } @Override public int getItemCount() { return mList.size() + 1; } public String getItem(int position) { return mList.get(position); } public void addAll(List&lt;String&gt; list) { this.mList.addAll(list); notifyDataSetChanged(); } @Override public int getItemViewType(int position) { if(position + 1 == getItemCount()) {//最后一条为FooterView return VIEW_TYPE_FOOTER; } return VIEW_TYPE_ITEM; } public void reSetData(List&lt;String&gt; list) { this.mList = list; notifyDataSetChanged(); } public void setLoadStatus(LoadStatus loadStatus) { this.mLoadStatus = loadStatus; }}public class ItemViewHolder extends RecyclerView.ViewHolder { public TextView mTextView; public ItemViewHolder(View itemView) { super(itemView); mTextView = (TextView) itemView.findViewById(R.id.textView); }}public class FooterViewHolder extends RecyclerView.ViewHolder { public LinearLayout mLoadingLayout; public TextView mClickLoad; public FooterViewHolder(View itemView) { super(itemView); mLoadingLayout = (LinearLayout) itemView.findViewById(R.id.loading); mClickLoad = (TextView) itemView.findViewById(R.id.click_load_txt); mClickLoad.setOnClickListener(new View.OnClickListener() {//添加点击加载更多监听 @Override public void onClick(View v) { loadMore(); } }); }}public enum LoadStatus { CLICK_LOAD_MORE,//点击加载更多 LOADING_MORE//正在加载更多} FooterView的布局如下：1234567891011121314151617181920212223242526272829303132&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"40dp\" android:gravity=\"center_horizontal\" android:orientation=\"horizontal\"&gt; &lt;LinearLayout android:id=\"@+id/loading\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt; &lt;ProgressBar android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:gravity=\"center_vertical\" android:text=\"正在加载...\"/&gt; &lt;/LinearLayout&gt; &lt;TextView android:id=\"@+id/click_load_txt\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:paddingTop=\"5dp\" android:paddingBottom=\"5dp\" android:text=\"点击加载更多\" android:visibility=\"gone\"/&gt;&lt;/RelativeLayout&gt; 写完Adapter的FooterView视图适配之后，我们还有一个重要的步骤需要做，在哪里实现加载更多的逻辑处理 其实RecyclerView也为我们提供了mRecyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() )接口，这样我们就看一看通过这个接口来判断什么时候调用加载更多的实现接口，关键代码如下：12345678910111213141516171819mRecyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() { @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) { super.onScrollStateChanged(recyclerView, newState); if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; mLastVisibleItemPosition + 1 == mAdapter.getItemCount()) { loadMore(); } } @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { super.onScrolled(recyclerView, dx, dy); mLastVisibleItemPosition = mLayoutManager.findLastVisibleItemPosition(); }}); 整个Demo的Activity的实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class MainActivity extends AppCompatActivity { private RecyclerView mRecyclerView; private SwipeRefreshLayout mSwipeRefreshLayout; private DemoAdapter mAdapter; private int mLastVisibleItemPosition = 0; private LinearLayoutManager mLayoutManager; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mRecyclerView = (RecyclerView) findViewById(R.id.recyclerView); mSwipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.swipeRefreshLayout);mLayoutManager = new LinearLayoutManager(this); mRecyclerView.setLayoutManager(mLayoutManager); mRecyclerView.setItemAnimator(new DefaultItemAnimator()); mAdapter = new DemoAdapter(this, getData(\"init\")); mRecyclerView.setAdapter(mAdapter); mSwipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() { @Override public void onRefresh() { new Thread() { @Override public void run() { try { Thread.sleep(3000); final List&lt;String&gt; list = getData(\"refresh\"); runOnUiThread(new Runnable() { @Override public void run() { mAdapter.reSetData(list); mSwipeRefreshLayout.setRefreshing(false); } }); } catch (InterruptedException e) { e.printStackTrace(); } } }.start(); } }); mRecyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() { @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) { super.onScrollStateChanged(recyclerView, newState); if (newState == RecyclerView.SCROLL_STATE_IDLE &amp;&amp; mLastVisibleItemPosition + 1 == mAdapter.getItemCount()) { loadMore(); } } @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { super.onScrolled(recyclerView, dx, dy); mLastVisibleItemPosition = mLayoutManager.findLastVisibleItemPosition(); } }); } public void loadMore() { mAdapter.setLoadStatus(LoadStatus.LOADING_MORE); new Thread() { @Override public void run() { try { Thread.sleep(3000); final List&lt;String&gt; list = getData(\"load more\"); runOnUiThread(new Runnable() { @Override public void run() { mAdapter.addAll(list); mAdapter.setLoadStatus(LoadStatus.CLICK_LOAD_MORE); } }); } catch (InterruptedException e) { e.printStackTrace(); } } }.start(); } public List&lt;String&gt; getData(String flag) { int idx = 1; if(mAdapter != null) { idx = mAdapter.getItemCount(); } List&lt;String&gt; list = new ArrayList&lt;&gt;(10); for(int i = 0; i &lt; 10; i++) { list.add(flag + \":\" + (idx + i)); } return list; }} 以上就是我针对RecyclerView的下拉刷新上拉加载的实现方式。 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/RecyclerView下拉刷新上拉加载.html"},{"title":"RxJava学习之基本使用","text":"RxJava现在在Android开发中越来越流行，作为一个Android开发者我也必须紧跟步伐学习学习RxJava，这篇文章就记录了RxJava中我认为比较常用的一些场景。 也给大伙推荐篇比较好的RxJava文章 给 Android 开发者的 RxJava 详解 RxJava基础大家都知道JDK中提供了观察者模式的实现，它主要两个重要元素： 被观察者 Observable 观察者 Observer 至于Java中观察者模式的使用，大家可以自行Google下。 而RxJava中也有两个重要的元素： 被观察者(事件源) Observable 观察者(事件订阅者) Subscriber 因此RxJava的设计看起来也有点类似JDK中的观察者模式，都有被观察者和观察者。JDK观察者模式中当有操作需要时是由被观察者通知观察者来进行更新操作RxJava中是由被观察者Observable发出事件给观察者Subscriber接收，然后观察者Subscriber调用noNext()进行处理，直到调用onComplete)()或onError()结束 Gradle依赖12compile 'io.reactivex:rxjava:1.0.1'compile 'io.reactivex:rxandroid:1.0.1' 基础方式创建Observable和Subscriber123456789101112131415161718192021222324252627//使用Observable.create()方式创建一个Observable事件源Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() { @Override public void call(Subscriber&lt;? super String&gt; subscriber) { subscriber.onNext(\"hello world\"); subscriber.onCompleted(); }});//创建一个观察者SubscriberSubscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() { @Override public void onCompleted() { Log.d(\"RxJava\" \"onComplete\"); } @Override public void onError(Throwable e) { Log.d(\"RxJava\" \"onError\"); } @Override public void onNext(String s) { Log.d(\"RxJava\" s); }};//观察者订阅事件源observable.subscribe(subscriber); 上面是RxJava的基础使用方式，这种方式使用起来和观察者模式还是比较像的，首先创建一个被观察者Observable，再创建一个观察者Subscriber，然后观察者订阅这个被观察者，一旦订阅之后Observable就会执行上面的call(Subscriber subscriber)方法(参数里面的Subscriber参数就是我们创建的观察者实例)，通过该方法我们手动调用Subscriber方法的onNext和onCompleted方法。这里有个要注意的就是我们必须自己手动调用onNext和onCompleted方法，否则不会自己执行。 简化创建Observable和Subscriber上面提到的Observable和Subscriber创建方式是RxJava中最基本的方式，但是上面的方式使用起来还是感觉有点繁琐，必须按部就班的来。 RxJava中也提供了简单的创建方式，比如：Observable.just()方式创建Observable，完整是示例如下：1234567891011//创建一个只发出一个事件就结束的对象Observable&lt;String&gt; observable = Observable.just(\"hello world\");//创建一个只关心onNext处理的subscriberAction1&lt;String&gt; onNextAction = new Action1&lt;String&gt;() { @Override public void call(String s) { Log.d(\"RxJava\" s); }};//此方法有重载版本，可以传递处理onError,onComplete的Actionobservable.subscribe(onNextAction); 上面的方法中使用Observable.just()方法可以快速的创建一个发送hello world事件的事件源，而如果我们只关心观察者对事件的处理，而不关心事件处理结束和事件发生错误时的处理，我们则可以创建Action1对象来替代Subscriber进行事件处理。 上面observable.subscribe(onNextAction)一旦订阅事件，就会自动的执行Action1中的call方法，该方法的作用等同于Subscriber中的onNext方法的作用，至于为什么一旦订阅就会自动执行call方法，而前面的一个例子中我们却需要手动调用Subscriber中的onNext方法，这个原因大家可以去源码实现中找答案，我就不介绍了。 当然如果你除了处理事件外，也需要对事件结束和事件错误时进行其他处理，则可以使用observable.subscribe(Action1)另一个重载方法observable.subscribe(Action1,Action1,Action1)分别接收对应onNext,onCompleted,onError. Action1中的call方法只能接收一个参数，RxJava中也提供了很多其他的几种Action，从Action0到Action9分表代表其call方法能接收0个参数到9个参数，另外还有一个ActionN其能接收N个参数。 RxJava其实是支持链式写法 的，所以上面的写法可以适用如下的方式实现：1234567Observable.just(\"hello world\") .subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { Log.d(\"RxJava\" s); } }); 上面介绍了RxJava的基本使用，下面接着介绍RxJava中一些比较常用的功能函数。 事件变换map这个map是干什么用的呢？我举个例子：比如说我们有一个Observable对象，这个对象发送的事件是一串用户密码字符串，但是Subscriber进行处理的时候需要的是一个包含加密后的密码串，这个时候我们就可以使用map操作符将一个Observable对象发送的事件修改成另一个事件，下面的代码里通过map将hello world转换成其hashCode值12345678910111213141516Observable.just(\"hello world\")//map操作将一个事件变换为另外一个事件，只会影响到当前的subscriber//此处将Observable的String事件转换成Integer事件，所以事件是可用改变的.map(new Func1&lt;String, Integer&gt;() { @Override public Integer call(String s) { return s.hashCode(); }}).subscribe(new Action1&lt;Integer&gt;() { @Override public void call(Integer hashCode) { //这里的值就是hello world的hash值 Log.d(\"RxJava\" s); }}); 例子中map(Func1&lt;source, target&gt;)操作符通过Func1&lt;source, target&gt;类将source事件转换修改成target事件 通过上面的介绍可以看出map是用来变换修改Observable所发出的事件 Observable变换flatMapmap是用来变换Observable所发出的事件，而flatMap就更强大，它可以将Observable转换成一个全新的Observable，依旧上例子代码1234567891011121314Observable.just(\"laohu\") //将一个事件数据变换为另一种事件输出的Observable .flatMap(new Func1&lt;String, Observable&lt;User&gt;&gt;() { @Override public Observable&lt;User&gt; call(String s) { return Observable.just(new User(s)); } }) .subscribe(new Action1&lt;User&gt;() { @Override public void call(User user) { Log.d(\"RxJava\" user.getName()); } }); 上面的例子中通过flatMap操作符将一个发送laohu事件的Observable转换成一个发送User对象的Observable，该变化是完全生成一个新的Observable Observable.from在我们开发过程中经常需要对一个数组或是一个集合数据进行处理，比如我通过班级编号可以查出这个班的所有学生，查询出来后需要打印出每个学生的名字，那么我们使用上面介绍的方式该怎么做呢？12345678910List&lt;Student&gt; students= ...Observable.just(students) .subscribe(new Action1&lt;List&lt;Student&gt;&gt;() { @Override public void call(List&lt;Student&gt; students) { for(User user : users) { Log.d(\"RxJava\" students.getName()); } } }); 上面的做法中，很明显我们是在Subscriber中对列表进行循环打印出每个学生的名字，这种方法是不是感觉很多余，我既然都拿到列表了我干嘛还要多次一举使用RxJava去进行循环处理。这时使用Observable.from就可以解决这个问题，该方法可以将集合或数组进行循环处理，每次发送一个事件元素给Subscriber进行处理，在Subscriber中只需要针对单个Student进行姓名打印就可以了，改进之后的写法如下：12345678List&lt;Student&gt; students= ...Observable.from(students) .subscribe(new Action1&lt;Student&gt;() { @Override public void call(Student student) { Log.d(\"RxJava\" student.getName()); } }); 改进之后的写法看着是不是很简单，from配合flatMap可以实现很多很复杂的操作，后面我们再举例 事件过滤filter12345678910111213141516171819202122232425262728293031323334353637public class User { private String name; private int age; public User(String name, int age) { this.name = name; this.age = age; } ...}String[] array = {\"张三\", \"李四\", \"王麻子\", \"赵六\"};Observable.from(array) //将一个事件数据变换为另一种事件输出的Observable .flatMap(new Func1&lt;String, Observable&lt;User&gt;&gt;() { @Override public Observable&lt;User&gt; call(String s) { int age = 20; if(s.length() &gt; 2) {//名字长度大于2的年龄设为10 age = 10; } return Observable.just(new User(s, age)); } }) //将age &lt;= 10的事件过滤掉 .filter(new Func1&lt;User, Boolean&gt;() { @Override public Boolean call(User user) { return user.getAge() &gt; 10; } }) .subscribe(new Action1&lt;User&gt;() { @Override public void call(User user) { Log.d(\"RxJava\" user.getName()); } }); 上面的例子中，会将年龄小于等于10的用户数据过滤掉不进行处理，因此在filter的call方法中进行判断，年龄小于等于10的数据返回false即可将该数据过滤掉。 选取指定数量数据take()上面的例子中如果我只想对符合条件的前两个数据进行处理该怎么做呢，这时我们可以使用take()操作符来实现12345678910111213141516171819202122232425262728String[] array = {\"张三\", \"李四\", \"王麻子\", \"赵六\"};Observable.from(array) //将一个事件数据变换为另一种事件输出的Observable .flatMap(new Func1&lt;String, Observable&lt;User&gt;&gt;() { @Override public Observable&lt;User&gt; call(String s) { int age = 20; if(s.length() &gt; 2) { age = 10; } return Observable.just(new User(s, age)); } }) //将age &lt;= 10的事件过滤掉 .filter(new Func1&lt;User, Boolean&gt;() { @Override public Boolean call(User user) { return user.getAge() &gt; 10; } }) //只取符合条件的前两个结果 .take(2) .subscribe(new Action1&lt;User&gt;() { @Override public void call(User user) { Log.d(\"RxJava\" user.getName()); } }); doOnNext上面的例子中如果我们取到前两个符合条件的数据进行处理之前，我们要先进行缓存处理，这个时候我们就可以使用doOnNext操作符进行处理，实现如下：1234567891011121314151617181920212223242526272829303132333435String[] array = {\"张三\", \"李四\", \"王麻子\", \"赵六\"};Observable.from(array) //将一个事件数据变换为另一种事件输出的Observable .flatMap(new Func1&lt;String, Observable&lt;User&gt;&gt;() { @Override public Observable&lt;User&gt; call(String s) { int age = 20; if(s.length() &gt; 2) { age = 10; } return Observable.just(new User(s, age)); } }) //将age &lt;= 10的事件过滤掉 .filter(new Func1&lt;User, Boolean&gt;() { @Override public Boolean call(User user) { return user.getAge() &gt; 10; } }) //只取符合条件的前两个结果 .take(2) //在subscribe执行之前进行额外的操作，比如将数据保存到磁盘上 .doOnNext(new Action1&lt;User&gt;() { @Override public void call(User user) { save(user); } }) .subscribe(new Action1&lt;User&gt;() { @Override public void call(User user) { Log.d(\"RxJava\" user.getName()); } }); 线程调度比如我们有一个同步请求网络数据的服务，在Android中使用RxJava进行处理该怎么做呢？我们可以使用subscribeOn()指定被观察者(事件)的运行线程，使用observeOn()指定观察者(订阅者)的运行线程。12345678910111213141516Observable.just(\"查询条件\") .subscribeOn(Schedulers.io())//在子线程中进行查询操作 .flatMap(new Func1&lt;String, Observable&lt;Result&gt;&gt;() { @Override public Observable&lt;Result&gt; call(String whereClause) { Result result = queryResult(whereClause); return Observable.just(result); } }) .observeOn(AndroidSchedulers.mainThread())//在UI线程中处理结果 .subscribe(new Action1&lt;Result&gt;() { @Override public void call(final Result result) { Log.d(\"RxJava\" result.toString()); } }); 上面这些是我目前使用RxJava用到的一些功能函数和操作符，后面学习了其他操作符之后，我会用另外的一篇博文记录下来。 write by 老胡 2016年10月30日 本文章发表在 独立博客 ittiger.cn 和 个人CSDN博客 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/RxJava-Basic-Use.html"},{"title":"Retrofit2文件上传下载及其进度显示","text":"序前面一篇文章介绍了Retrofit2的基本使用，这篇文章接着介绍使用Retrofit2实现文件上传和文件下载，以及上传下载过程中如何实现进度的显示。 文件上传定义接口123@Multipart@POST(\"fileService\")Call&lt;User&gt; uploadFile(@Part MultipartBody.Part file); 构造请求体上传12345File file = new File(filePath);RequestBody body = RequestBody.create(MediaType.parse(\"application/otcet-stream\"), file);MultipartBody.Part part = MultipartBody.Part.createFormData(\"file\", file.getName(), body);Call&lt;User&gt; call = getRetrofitService().uploadOneFile(part);call.enqueue(callback); 这样就可以将这个文件上传到服务器，但就这样上传操作不够友好，最好加上文件上传进度。而Retrofit本身是不支持文件上传进度显示的，所以就需要我们自己扩展OkHttp来实现文件上传进度。 我的做法是直接扩展一个RequestBody来实现进度显示，实现完成之后只需要将上面body进行包装转换即可 上传进度显示12345678910111213141516171819202122232425262728293031RetrofitCallback&lt;User&gt; callback = new RetrofitCallback&lt;User&gt;() { @Override public void onSuccess(Call&lt;User&gt; call, Response&lt;User&gt; response) { runOnUIThread(activity, response.body().toString()); //进度更新结束 } @Override public void onFailure(Call&lt;User&gt; call, Throwable t) { runOnUIThread(activity, t.getMessage()); //进度更新结束 } @Override public void onLoading(long total, long progress) { super.onLoading(total, progress); //此处进行进度更新 }};RequestBody body1 = RequestBody.create(MediaType.parse(\"application/otcet-stream\"), file);//通过该行代码将RequestBody转换成特定的FileRequestBodyFileRequestBody body = new FileRequestBody(body1, callback);MultipartBody.Part part = MultipartBody.Part.createFormData(\"file\", file.getName(), body);Call&lt;User&gt; call = getRetrofitService().uploadOneFile(part);call.enqueue(callback); 回调RetrofitCallback123456789101112131415161718public abstract class RetrofitCallback&lt;T&gt; implements Callback&lt;T&gt; { @Override public void onResponse(Call&lt;T&gt; call, Response&lt;T&gt; response) { if(response.isSuccessful()) { onSuccess(call, response); } else { onFailure(call, new Throwable(response.message())); } } public abstract void onSuccess(Call&lt;T&gt; call, Response&lt;T&gt; response); public void onLoading(long total, long progress) { }} FileRequestBody1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 扩展OkHttp的请求体，实现上传时的进度提示 * * @param &lt;T&gt; */public final class FileRequestBody&lt;T&gt; extends RequestBody { /** * 实际请求体 */ private RequestBody requestBody; /** * 上传回调接口 */ private RetrofitCallback&lt;T&gt; callback; /** * 包装完成的BufferedSink */ private BufferedSink bufferedSink; public FileRequestBody(RequestBody requestBody, RetrofitCallback&lt;T&gt; callback) { super(); this.requestBody = requestBody; this.callback = callback; } @Override public long contentLength() throws IOException { return requestBody.contentLength(); } @Override public MediaType contentType() { return requestBody.contentType(); } @Override public void writeTo(BufferedSink sink) throws IOException { if (bufferedSink == null) { //包装 bufferedSink = Okio.buffer(sink(sink)); } //写入 requestBody.writeTo(bufferedSink); //必须调用flush，否则最后一部分数据可能不会被写入 bufferedSink.flush(); } /** * 写入，回调进度接口 * @param sink Sink * @return Sink */ private Sink sink(Sink sink) { return new ForwardingSink(sink) { //当前写入字节数 long bytesWritten = 0L; //总字节长度，避免多次调用contentLength()方法 long contentLength = 0L; @Override public void write(Buffer source, long byteCount) throws IOException { super.write(source, byteCount); if (contentLength == 0) { //获得contentLength的值，后续不再调用 contentLength = contentLength(); } //增加当前写入的字节数 bytesWritten += byteCount; //回调 callback.onLoading(contentLength, bytesWritten); } }; }} 文件下载接口定义文件下载请求与普通的Get和Post请求是一样的，只是他们的返回值不一样而已，文件下载请求的返回值一般定义成ResponseBody1234//这里只举例POST方式进行文件下载@FormUrlEncoded@POST(\"fileService\")Call&lt;ResponseBody&gt; downloadFile(@Field(\"param\") String param); 发起请求123456789101112131415161718192021222324252627282930313233RetrofitCallback&lt;ResponseBody&gt; callback = new RetrofitCallback&lt;ResponseBody&gt;() { @Override public void onSuccess(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) { try { InputStream is = response.body().byteStream(); String path = Util.getSdCardPath(); File file = new File(path, \"download.jpg\"); FileOutputStream fos = new FileOutputStream(file); BufferedInputStream bis = new BufferedInputStream(is); byte[] buffer = new byte[1024]; int len; while ((len = bis.read(buffer)) != -1) { fos.write(buffer, 0, len); } fos.flush(); fos.close(); bis.close(); is.close(); } catch (IOException e) { e.printStackTrace(); } } @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) { runOnUIThread(activity, t.getMessage()); }}; Call&lt;ResponseBody&gt; call = getRetrofitService(callback).downloadFile(param);call.enqueue(callback); 下载进度显示下载进度显示有两种方式实现，一种是通过OkHttp设置拦截器将ResponseBody进行转换成我们扩展后的ResponseBody（稍后介绍），另外一种则是在上面的回调Callback中将ResponseBody的流写入到文件时进行进度处理，下面分别进行介绍。 扩展ResponseBody设置OkHttp拦截器12345678910111213141516171819202122private &lt;T&gt; RetrofitService getRetrofitService(final RetrofitCallback&lt;T&gt; callback) { OkHttpClient.Builder clientBuilder = new OkHttpClient.Builder(); clientBuilder.addInterceptor(new Interceptor() { @Override public okhttp3.Response intercept(Chain chain) throws IOException { okhttp3.Response response = chain.proceed(chain.request()); //将ResponseBody转换成我们需要的FileResponseBody return response.newBuilder().body(new FileResponseBody&lt;T&gt;(response.body(), callback)).build(); } }); Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .client(clientBuilder.build()) .addConverterFactory(GsonConverterFactory.create()) .build(); RetrofitService service = retrofit.create(RetrofitService.class); return service ;}//通过上面的设置后，我们需要在回调RetrofitCallback中实现onLoading方法来进行进度的更新操作，与上传文件的方法相同 FileResponseBody123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 扩展OkHttp的请求体，实现上传时的进度提示 * * @param &lt;T&gt; */public final class FileResponseBody&lt;T&gt; extends ResponseBody { /** * 实际请求体 */ private ResponseBody mResponseBody; /** * 下载回调接口 */ private RetrofitCallback&lt;T&gt; mCallback; /** * BufferedSource */ private BufferedSource mBufferedSource; public FileResponseBody(ResponseBody responseBody, RetrofitCallback&lt;T&gt; callback) { super(); this.mResponseBody = responseBody; this.mCallback = callback; } @Override public BufferedSource source() { if (mBufferedSource == null) { mBufferedSource = Okio.buffer(source(mResponseBody.source())); } return mBufferedSource; } @Override public long contentLength() { return mResponseBody.contentLength(); } @Override public MediaType contentType() { return mResponseBody.contentType(); } /** * 回调进度接口 * @param source * @return Source */ private Source source(Source source) { return new ForwardingSource(source) { long totalBytesRead = 0L; @Override public long read(Buffer sink, long byteCount) throws IOException { long bytesRead = super.read(sink, byteCount); totalBytesRead += bytesRead != -1 ? bytesRead : 0; mCallback.onLoading(mResponseBody.contentLength(), totalBytesRead); return bytesRead; } }; }} 直接在回调中进行进度更新上面介绍了通过扩展ResponseBody同时设置OkHttp拦截器来实现进度条更新显示，另外也可以直接在请求回调onSuccess中将流转换成文件时实现进度更新，下面给出大致实现12345678910111213141516171819202122232425262728293031323334353637RetrofitCallback&lt;ResponseBody&gt; callback = new RetrofitCallback&lt;ResponseBody&gt;() { @Override public void onSuccess(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) { try { InputStream is = response.body().byteStream(); //获取文件总长度 long totalLength = is.available(); String path = Util.getSdCardPath(); File file = new File(path, \"download.jpg\"); FileOutputStream fos = new FileOutputStream(file); BufferedInputStream bis = new BufferedInputStream(is); byte[] buffer = new byte[1024]; int len; while ((len = bis.read(buffer)) != -1) { fos.write(buffer, 0, len); //此处进行更新操作 //len即可理解为已下载的字节数 //onLoading(len, totalLength); } fos.flush(); fos.close(); bis.close(); is.close(); //此处就代表更新结束 } catch (IOException e) { e.printStackTrace(); } } @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) { runOnUIThread(activity, t.getMessage()); }}; 以上就是Retrofit中文件上传下载及其进度更新显示的实现，有疑问的可以加我微信和QQ与我联系，联系方式在这关于 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Retrofit2文件上传下载及其进度显示.html"},{"title":"TextView之SpannableStringBuilder使用总结","text":"最近项目中碰到一个TextView的显示问题，想了各种办法之后，最后还是用SpannableStringBuilder解决的。这篇文章就记录下我的问题的解决过程，同时总结下SpannableStringBuilder在TextView中的不同用法。 背景项目中GridView有两列，每个Item视图都有一个TextView(设置了最大显示行数)，项目业务要求每列的TextView展示高度相同，但是因为显示的文本你不知道有多少行，所以在布局的时候不能设置固定高度，而是设置为wrap_content，所以为了保证两列的TextView高度一致，只需要保证他们展示内容的行数一致就行。 而上面的问题只需要在内容行数达不到最大显示行数时，为其手动补齐行数即可。 这里有个问题就是如何计算当前要展示的文本在此TextView中能展示多少行，这个地方直接通过textView.getLineCount()是不行的，我是通过StaticLayout计算当前文本能显示的行数，对于StaticLayout的使用这篇文章就不介绍了，不会的同学可以去google下，后面的文章我会专门介绍StaticLayout的使用 有了上面的解决方法之后，我在行数不足时我手动添加了换行符\\n补齐行数，但是运行之后，发现达不到效果，因为虽然手动换行，但是通过换行符\\n换行之后的高度达不到实际文本行显示的高度，因此这种方式还是没法保证两边TextView高度一致。 既然单纯的换行无法达到我们想要的效果，那我就在换行之后再添加几个文字，有了这几个文字就可以让其真正达到多行文本的效果了。但是多的这几个字会显示在界面上，所以我们只需要让这几个文字不显示出来或者让这几个文字完全透明即可。 将TextView的部分文本设置为透明色，最后查询之后发现SpannableStringBuilder可以实现这样的效果，下面我就总结下SpannableStringBuilder结合TextView的使用方法。 SpannableStringBuilder使用总结我们来看下SpannableStringBuilder的官方介绍 This is the class for text whose content and markup can both be changed 通过上面的介绍可以看出SpannableStringBuilder是一个内容和标记都可以更改的类，它其实是CharSequence的子类。 SpannableStringBuilder使用效果 文本高亮使用ForegroundColorSpan为TextView的部分文本添加指定颜色，使这部分文本高亮显示123456SpannableStringBuilder builder = new SpannableStringBuilder(\"普通文本\");int start = builder.length();//高亮的开始位置builder.append(\"文本高亮\");int end = builder.length();//高亮的结束位置builder.setSpan(new ForegroundColorSpan(Color.RED), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mTextView.setText(builder); ForegroundColorSpan代表设置文本高亮的颜色 Spanned.SPAN_INCLUSIVE_EXCLUSIVE这个常量表示高亮开始位置但不包含结束位置的字符，还有几个类似的常量，这几个常量与Stirng.subString()方法的参数代表的意思是类似的。 上面我的解决办法中需要文本完全透明，只需要将高亮的颜色设置为100%透明即可 URL超链接效果使用URLSpan为TextView的部分文本添加超链接效果1234567891011121314SpannableStringBuilder builder = new SpannableStringBuilder(\"普通文本\");int start = builder.length();//URL文本开始位置builder.append(\"URL连接\");int end = builder.length();//URL文本结束位置builder.setSpan(new URLSpan(\"www.baidu.com\") { @Override public void onClick(View widget) { //URLSpan点击响应 UIUtil.showToast(context, \"URLSpan点击\"); } }, start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mTextView.setText(builder);//必须设置下面的方法，否则URLSpan点击事件无法响应mTextView.setMovementMethod(LinkMovementMethod.getInstance()); 使用URLSpan即可将TextView的部分文本设置为超链接显示样式，同时还可以实现点击响应，但是必须调用TextView.setMovementMethod(LinkMovementMethod.getInstance());点击响应才会有效 设置文本背景色使用BackgroundColorSpan为TextView的部分文本添加背景色123456SpannableStringBuilder builder = new SpannableStringBuilder(\"普通文本\");int start = builder.length();//设置背景色的开始位置builder.append(\"设置背景色\");int end = builder.length();//设置背景色的结束位置builder.setSpan(new BackgroundColorSpan(Color.BLUE), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mTextView.setText(builder); BackgroundColorSpan可以将TextView的部分文本添加背景色，与ForegroundColorSpan的使用方式相同，只需要设置颜色即可 添加文本下划线使用UnderlineSpan为TextView的部分文本添加下划线123456SpannableStringBuilder builder = new SpannableStringBuilder(\"普通文本\");int start = builder.length();//设置下划线的开始位置builder.append(\"下划线文本\");int end = builder.length();//设置下划线的结束位置builder.setSpan(new UnderlineSpan(), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mTextView.setText(builder); 文本添加删除线使用StrikethroughSpan为TextView的部分文本添加删除线123456SpannableStringBuilder builder = new SpannableStringBuilder(\"普通文本\");int start = builder.length();//设置删除线的开始位置builder.append(\"删除线文本\");int end = builder.length();//设置删除线的结束位置builder.setSpan(new StrikethroughSpan(), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mTextView.setText(builder); 图片替换文本使用ImageSpan为TextView的部分文本替换为图片12345678SpannableStringBuilder builder = new SpannableStringBuilder(\"普通文本\");int start = builder.length();//替换为图片的开始位置builder.append(\"图片替换文本\");int end = builder.length();//替换为图片的结束位置Drawable drawable = getResources().getDrawable(R.mipmap.ic_launcher);drawable.setBounds(0, 0, 50, 50);//设置图片为50px大小builder.setSpan(new ImageSpan(drawable, ImageSpan.ALIGN_BOTTOM), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mTextView.setText(builder); 设置部分粗体使用StyleSpan为TextView的部分文本设置为粗体123456SpannableStringBuilder builder = new SpannableStringBuilder(\"普通文本\");int start = builder.length();//设置粗体的开始位置builder.append(\"粗体文本\");int end = builder.length();//设置粗体的结束位置builder.setSpan(new StyleSpan(Typeface.BOLD), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mTextView.setText(builder); 为任意文本添加点击响应使用ClickableSpan为TextView的任意文本添加点击响应12345678910111213141516SpannableStringBuilder builder = new SpannableStringBuilder(\"普通文本\");int start = builder.length();//设置删除线的开始位置builder.append(\"单击响应文本\");int end = builder.length();//设置删除线的结束位置builder.setSpan(new ClickableSpan() {//将任意文本设置为可点击 @Override public void onClick(View widget) { UIUtil.showToast(StyleTextViewActivity.this, \"ClickableSpan\"); } @Override public void updateDrawState(TextPaint ds) { //此方法的默认实现会出现下划线效果，去掉其默认实现 } }, start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mTextView.setText(builder);mTextView.setMovementMethod(LinkMovementMethod.getInstance()); 组合使用各效果1234567SpannableStringBuilder builder = new SpannableStringBuilder(\"普通文本\");int start = builder.length();//设置组合使用的开始位置builder.append(\"组合使用\");int end = builder.length();//设置组合使用的结束位置builder.setSpan(new ForegroundColorSpan(Color.WHITE), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);builder.setSpan(new BackgroundColorSpan(Color.RED), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);mTextView.setText(builder); 上面这些就是SpannableStringBuilder结合TextView的一些使用方法，其实使用起来还是很简单的。 具体使用示例代码请参考：https://github.com/huyongli/AndroidDemo write by laohu2016年11月5日21:45:48 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/TextView-SpannableStringBuilder-usage-summary.html"},{"title":"UC浏览器首页滑动动画实现","text":"实现效果 UC浏览器首页效果我们先来看下UC浏览器首页的滑动动画和我最终实现的动画效果 使用方式123456789101112131415161718&lt;cn.ittiger.ucpage.view.UCIndexView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:ucindexview=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/ucindexview\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" ucindexview:pageHeadViewHeight=\"@dimen/dp_40\" ucindexview:isPageHeadViewFixed=\"false\" ucindexview:isContentHeadViewEnable=\"true\" ucindexview:isPullRestoreEnable=\"false\" ucindexview:contentHeadViewHeight=\"@dimen/dp_40\" ucindexview:pageNavigationViewHeight=\"@dimen/dp_200\" ucindexview:pageHeadViewLayoutId=\"@layout/page_head_view_layout\" ucindexview:pageNavigationViewLayoutId=\"@layout/page_navigation_view_layout\" ucindexview:contentHeadViewLayoutId=\"@layout/content_head_view_layout\" ucindexview:contentViewLayoutId=\"@layout/content_view_layout\"&gt; &lt;/cn.ittiger.ucpage.view.UCIndexView&gt; 使用方式只需要如此布局即可，没有其他的任何代码操作，非常简单。几个重要属性如下： isPageHeadViewFixed：设置PageHeadView是否固定显示(效果如上图2) isContentHeadViewEnable：设置ContentHeadView是否启用(效果如上图3) isPullRestoreEnable：设置是否可以通过下拉手势恢复到初始状态，UC首页下拉不能恢复初始状态 contentHeadViewHeight：设置contentHeadView视图的高度 pageNavigationViewHeight：设置PageNavigationView视图的高度 pageHeadViewLayoutId：设置PagetHeadView视图的内容布局，如图中的文字UC头条布局 pageNavigationViewLayoutId：设置PageNavigationView视图的内容布局，如图中的文字网址导航布局 contentHeadViewLayoutId：设置ContentHeadViev视图的内容布局，如图中的文字新闻头部导航布局 contentViewLayoutId：设置ContentView视图的内容布局，如图中的文字新闻内容区布局 github地址实现及Demo地址：https://github.com/huyongli/UCIndexAnimation 实现过程下面来讲讲我的实现过程： 首先来分析下UC首页这个动画中涉及到的元素和要点 向上滑动过程顶部的UC头条会慢慢的显示出来，我把这部分视图称为：PageHeadView(页面头部视图)，很明显其初始化时是在屏幕外部的 向上滑动过程中UC漫站上面会有个新闻Tab菜单头部慢慢的显示出来，我把这部分视图称为：ContentHeadView(新闻头部视图)，初始时是被ContentView遮盖，而后慢慢滑出，显然它的滑动速度是比ContentView快的 向上滑动过程中天气、搜索、网站导航会稍微往上滑动一段距离最终隐藏，我把这部分视图称为：PageNavigationView(页面导航视图)，随着不断的滑动，会慢慢的被其余三个视图共同遮盖掉 UC漫站整个新闻内容视图慢慢的向上滑动直至跟UC头条相接，我把这部分称为：ContentView(新闻内容视图) 根据动画效果来看，上面所说的四个不同的视图部分都是同时停止滑动，但是他们滑动的距离明显是不相同的 PageHeadView滑动的距离为其自身高度， ContentHeadView的滑动距离为其自身高度与ContentView滑动的距离之和，而其相对ContentView视图的滑动距离为其自身高度 ContentView滑动距离为其自身初始距离顶部的边距减去 PageHeadView和ContentHeadView两者的高度 PageNavigationView的滑动距离很小 上面的分析把UC首页整体划分成四个不同的View部分，另外其首页中只有ContentView、PageNavigationView两个视图会处理滑动事件实现技术点和细节根据上面的分析我们知道有三个视图是从被遮盖到显示或者是从显示到遮盖，剩下的ContentView一直是遮盖其他的视图。根据视图遮盖很容易联想到FrameLayout布局，多个FrameLayout布局叠加在一起就类似PS中的图层叠加，滑动可以看成是不同层级的FrameLayout的marginTop不断变化的过程。 实现类结构图我的实现中先要说明两点： 我把上滑称为展示状态或者叫Show状态 下滑称为恢复初始化状态或者叫Hide状态下图是我的实现类结构图： 主要类实现解析 UCIndexView：模仿UC首页的最终实现，使用时在布局文件中使用此类即可 PageHeadView、PageNavigationView、ContentView、ContentHeadView：这四个类的作用见我上面的分析 MoveView：页面四个视图的基类，主要包含滑动过程中的一些基本属性和方法 mNeedMoveHeight：视图需要滑动的距离(ContentHeadView的此属性设置为相对ContentView的滑动距离)，此属性主要用来计算各自视图在滑动过程中的步长 mShowStopMarginTop：视图进行Show操作时，当视图的marginTop值等于该值时，结束Show操作。此值用来确定上滑过程中，视图滑动结束时的位置。 mHideStopMarginTop：视图进行Hide操作时，当视图的marginTop值等于该值时，结束Hide操作。此值用来确定下滑过程中，视图滑动结束时的位置。通常此值为视图初始化成功后的marginTop值。 getMarginTop()：获取视图当前的marginTop值 updateMarginTop(flaot step)：根据当前的滑动步长更新视图的marginTop值 isHideFinish()：判断当前视图的Hide操作是否完成 isShowFinish()：判断当前视图的Show操作是否完成 getShowMoveStep(float step)：获取视图Show过程中的实际可滑动步长，有可能计算得到的滑动步长超过了视图的可滑动距离 getHideMoveStep(float step)：获取视图Hide过程中的实际可滑动步长，有可能计算得到的滑动步长超过了视图的可滑动距离 TouchMoveView：用来处理手指触摸事件从而滑动的视图基类滑动事件处理直接上代码：12345678910111213141516171819202122232425262728293031@Overridepublic void onTouchMoveEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: mLastTouchY = event.getRawY(); break; case MotionEvent.ACTION_MOVE: //手指滑动过程中的滑动步长 mDelY = event.getRawY() - mLastTouchY; viewMove(mDelY, mIsPullRestoreEnable); mLastTouchY = event.getRawY(); break; case MotionEvent.ACTION_UP: int offset = 0; if(mDelY &gt; 0) {//hide，下拉 if(!mIsPullRestoreEnable) {//当前不允许下拉恢复 return; } offset = mContentView.getHideOffset(); } else {//show， 上拉 offset = mContentView.getShowOffset(); } if(offset &lt;= mPageHeadView.getNeedMoveHeight() / 2) {//没有滑过二分之一高度 slip(-mDelY, mIsPullRestoreEnable); } else { slip(mDelY, mIsPullRestoreEnable); } break; }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 对所有视图进行滑动操作 * @param delY 当前的滑动步长 * @param isPullRestoreEnable 是否允许下拉恢复 */private void viewMove(float delY, boolean isPullRestoreEnable) { float step = Math.abs(delY); //根据滑动距离的比例计算PageHeadView的滑动步长 float pageHeadViewStep = step * mPageHeadView.getNeedMoveHeight() / mContentView.getNeedMoveHeight(); //手指滑动距离作为ContentView的滑动步长 float contentViewStep = step; //ContentHeadView初始不固定显示时，其实际滑动步长为ContentView的滑动步长加上其相对ContentView的滑动步长 float contentHeadViewStep = mIsContentHeadViewEnable ? step + step * mContentHeadView.getNeedMoveHeight() / mContentView.getNeedMoveHeight() : 0; float pageNavigationViewStep = step * mPageNavigationView.getNeedMoveHeight() / mContentView.getNeedMoveHeight(); if(delY &gt; 0) {//下滑 if(!isPullRestoreEnable) {//当前不允许下拉恢复 return; } if(!isHideFinish()) {//恢复状态是否已完成 if(mIsPageHeadViewFixed == false) { mPageHeadView.onHideAnimation(pageHeadViewStep); } mContentView.onHideAnimation(contentViewStep); if(mIsContentHeadViewEnable) { mContentHeadView.onHideAnimation(contentHeadViewStep); } mPageNavigationView.onHideAnimation(pageNavigationViewStep); } } else {//上滑 if(!isShowFinish()) {//展示状态是否已完成 if(mIsPageHeadViewFixed == false) {//PageHeadView没有被固定时才进行滑动 mPageHeadView.onShowAnimation(pageHeadViewStep); } mContentView.onShowAnimation(contentViewStep); if(mIsContentHeadViewEnable) {//ContentHeadView启用时才进行滑动 mContentHeadView.onShowAnimation(contentHeadViewStep); } mPageNavigationView.onShowAnimation(pageNavigationViewStep); } }}``` ```java/** * 手指松开屏幕后，视图自动滑动 * 每隔 mAutoSlipTimeStep 长时间滑动 mAutoSlipStep 距离 * @param delY 当前的滑动距离 * @param isPullRestoreEnable 是否允许下拉恢复 */private void slip(float delY, final boolean isPullRestoreEnable) { if(delY &gt; 0) {//当前滑动为向下滑动，即处于恢复状态 if(isHideFinish()) {//已经恢复结束 return; } postDelayed(new Runnable() { @Override public void run() { viewMove(mAutoSlipStep, isPullRestoreEnable); slip(mAutoSlipStep, isPullRestoreEnable);//准备下一次滑动 } }, mAutoSlipTimeStep); } else {//当前滑动为向上滑动，即处于展示状态 if(isShowFinish()) {//已经展示结束 return; } postDelayed(new Runnable() { @Override public void run() { viewMove(-mAutoSlipStep, isPullRestoreEnable); slip(-mAutoSlipStep, isPullRestoreEnable);//准备下一次滑动 } }, mAutoSlipTimeStep); }} 上面的代码中我把手指每次的滑动距离当做ContentView的滑动步长，再根据ContentView的滑动步长计算其他视图的当前滑动步长，计算具体方式可以看代码中的注释。 其实上面代码里的实现步骤还是比较清晰简单的，主要是如下几个步骤： 在MotionEvent.MOVE中先得到当前手指滑动的距离，此距离作为ContentView的此次滑动步长 根据ContentView的滑动步长计算其他三个视图的滑动步长 根据当前是上滑还是下滑，判断是否滑动结束，没有结束则按照计算得到的步长继续对View进行滑动处理 当手指松开后，在MotionEvent.UP中判断ContentView的滑动距离是否达到了PageHeadView高度的一半，从而决定是继续同方向滑动至结束还是恢复到原状态 手指松开后，最终调用slip方法开始自动循环滑动处理，直至滑动结束 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/UC浏览器首页滑动动画实现.html"},{"title":"基于OkHttp的封装库TigerOkHttp的使用","text":"在前面熟悉了OkHttp的用法之后，为了简化用法同时适用于我的项目，我针对OkHttp进行了更进一步的封装(源码及其Demo地址在https://github.com/huyongli/TigerOkHttp) TigerOKHttp特性封装之后其支持的功能特性包括如下： 一般的get同步阻塞请求和异步请求 一般的post同步阻塞请求和异步请求 实现了文件上传功能（包含文件上传进度回调显示） 实现了大文件下载功能，只需要指定文件下载路径即可，也包含了下载进度的回调显示 实现了请求结果的自动解析，用户也可以根据需求扩展自定义结果解析类 对所有请求都支持直接将结果解析转换为JavaBean对象或集合 支持对返回结果结构的自定义，例如设置返回结果结构为：{flag：1|0，error：错误信息，result：请求结果}，结果解析的时候会按照此结构进行结果解析 支持取消某个请求 如果还不知道如何使用OkHttp请参考我的上一篇文章 Android中OkHttp的使用 进行了解。 初始化配置所有的请求在使用之前，先在Application里执行TigerOkHttp.init(new TigerHttpConfig(getApplicationContext()));进行TigerOkHttp的初始化操作。 TigerHttpConfig中主要是设置请求的全局性配置： TigerHttpConfig.readTimeOut：设置全局请求的数据读取超时时间，默认为30s TigerHttpConfig.writeTimeOut：设置全局请求的数据写入超时时间，默认为15s TigerHttpConfig.connectTimeOut：设置全局请求的连接超时时间，默认为15s TigerHttpConfig.cacheSize：设置全局请求的缓存大小，默认为10M TigerHttpConfig.cacheDirectory：设置全局请求的缓存存储路径，默认为系统给应用分配的缓存路径 TigerHttpConfig.isWrapperResult：设置全局请求结果是否对结果进行了封装，默认为true TigerHttpConfig.wrapperJsonResult：设置全局请求结果的结构类型，在isWrapperResult为true时才起作用 WrapperJson主要自定义设置全局请求结果的结构类型： WrapperJson.code_name：设置请求成功与否的状态码字段，默认为：flag WrapperJson.result_name：设置请求成功后结果字段，默认为：result WrapperJson.error_name：设置请求失败后的错误信息字段(仅在请求失败时才有值)，默认为：error WrapperJson.code_error_value：设置请求失败的状态码值，当请求状态码与此值相等时代表请求失败 Get请求1234567891011121314151617181920212223242526272829303132333435363738/*-------------------- 以下为Get同步阻塞请求 -------------------------------*///根据请求URL构造请求对象，请求成功后直接返回结果为Model对象TigerJsonRequest&lt;Model&gt; request = new TigerJsonRequest&lt;Model&gt;(URL, Model.class);/* * 如果要同步请求返回Model集合的话，请求对象这样构造 * TigerJsonRequest&lt;List&lt;Model&gt;&gt; request = new TigerJsonRequest&lt;List&lt;Model&gt;&gt;(URL, Model.class); *///以下添加三个请求参数request.addParam(\"value\", \"同步get请求-返回Model\").addParam(\"isModel\", true).addParam(\"isList\", false);//同步阻塞请求，直接返回Model对象Model result = TigerOkHttp.getSync(request);//同步阻塞请求，直接返回Model集合//List&lt;Model&gt; result = TigerOkHttp.getSync(request);/*-------------------- 以下为Get异步请求 ------------------------------*///根据请求URL构造请求对象，请求成功直接返回结果为Model集合TigerJsonRequest&lt;List&lt;Model&gt;&gt; request = new TigerJsonRequest&lt;List&lt;Model&gt;&gt;(URL);//添加三个请求参数request.addParam(\"value\", \"异步get请求-返回List&lt;Model&gt;\").addParam(\"isModel\", true).addParam(\"isList\", true).setRequestCallback(new RequestCallback&lt;List&lt;Model&gt;&gt;() {//设置异步请求回调 @Override public void onSuccess(List&lt;Model&gt;result) { showResult(result.toString()); } @Override public void onFailure(TigerHttpException e) { showResult(e.getMessage()); }});//开始异步请求TigerOkHttp.getAsync(request); 上面即为一般Get同步阻塞请求和异步请求的方式，对这两个请求需要说明几点： 首先根据请求URL构造一个请求对象TigerJsonRequest，如果为同步阻塞请求必须调用具有两个参数的构造函数以设置请求地址和设置请求返回的结果类型，如果是异步请求则只需要调用一个参数的构造函数设置请求地址即可(异步请求的返回结果类型会自动根据泛型判断) 在请求对象添加此请求相关的请求参数 如果是异步请求，在请求对象中添加异步请求回调接口RequestCallback 根据是否为异步请求在TigerOkHttp中选择对应的请求方法开始请求操作 如果解析后返回Model对象话，服务端返回的结果必须是JSON字符串，如果解析后返回Model集合的话，服务端返回的结果必须是JSON数组字符串 Post请求这里的Post同步、异步请求和上面的Get的同步异步请求方式基本上一样，构造请求对象TigerJsonRequest的方式是一模一样的，唯一的区别只是在最后发起请求操作上更换了请求方法 post同步阻塞请求的发起方式为：T result = TigerOkHttp.postSync(request); post异步请求的发起方式为：TigerOkHttp.postAsync(request); 自定义结果解析器当TigerJsonRequest自带的默认解析器TigerJsonParser无法满足你的功能需求时，我们只需要简单的两步即可为某次请求实现自定义解析器： 继承TigerParser&lt;T&gt;(会自动根据设置的全局结果结构进行解析判断请求是否成功、拿到请求的真正结果数据)这个解析基类然后实现public abstract T parser(BufferedSource source) throws TigerHttpException;方法 通过TigerJsonRequest类中的方法setDataParser(TigerParser dataParser)设置此次请求的结果解析器 上传文件上传文件模块我是在TigerJsonRequest基础上扩展出了一个专门针对上传文件的请求对象TigerUploadRequest，具体的上传文件实现方式如下：1234567891011121314151617181920212223242526272829303132333435//根据上传请求地址和文件路径构造文件上传请求对象TigerUploadRequest&lt;String&gt; request = new TigerUploadRequest&lt;String&gt;(url, filePath);//设置上传回调监听 request.setRequestCallback( new RequestCallback&lt;String&gt;() { @Override public void onPreExecute() { super.onPreExecute(); //此处可以初始化显示上传进度UI } @Override public void onSuccess(String result) { //文件上传成功 } @Override public void onLoading(long count, long current) { super.onLoading(count, current); //此处可以更新上传进度 } @Override public void onFailure(TigerHttpException e) { //文件上传失败 } @Override public void onAfterExecute() { super.onAfterExecute(); //此处可以隐藏上传进度条 } }); //发起上传操作 TigerOkHttp.postAsync(request); 下载文件下载文件功能需要用到另外一个请求对象TigerFileRequest123456789101112131415161718192021222324252627282930313233343536//根据下载请求地址和下载文件的保存路径构造请求对象TigerFileRequest request = new TigerFileRequest(URL, fileSavePath);//添加一个请求参数request.addParam(\"method\", \"download\")//设置下载过程中的回调接口.setRequestCallback(new RequestCallback&lt;File&gt;() { @Override public void onPreExecute() { super.onPreExecute(); //此处初始化显示下载进度条UI } @Override public void onSuccess(File result) { //下载成功，同时返回下载成功的文件 } @Override public void onLoading(long count, long current) { super.onLoading(count, current); //更新下载进度UI } @Override public void onFailure(TigerHttpException e) { //下载失败 } @Override public void onAfterExecute() { super.onAfterExecute(); //隐藏下载进度条UI }});//发起下载请求TigerOkHttp.getAsync(request); 取消某个请求取消某个请求只需要调用TigerOkHttp.cancel(request.getTag())即可，如果没有手动设置请求对象request的tag值，请求的时候会自动为这次请求生成一个唯一的tag 以上基本上就是TigerOkHttp框架的所有功能的使用方法，欢迎各位下载使用。 由于本人能力有限，此框架可能存在某些不足的地方，如果各位发现问题，欢迎提出，我会尽快解决，另外我会不断丰富完善此框架的功能。 write by laohu 2016-1-6 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/基于OkHttp的封装库TigerOkHttp的使用.html"},{"title":"基于openfire+smack开发Android即时聊天应用[四]-单人聊天、群聊、发送接收文件等","text":"这篇文章主要介绍如何实现点对点单人聊天、多人的群聊、以及如何给对方发送文件，如何发送图片消息和语音消息等功能。 1.单人聊天首先创建聊天对象123456789101112/** * 创建聊天窗口 * @param jid 好友的JID * @return */ public Chat createChat(String jid) { if(isConnected()) { ChatManager chatManager = ChatManager.getInstanceFor(connection); return chatManager.createChat(jid); } throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); } 创建聊天对象时，参数JID记得传聊天JID(解释请参考我的系列文章之基于openfire+smack开发Android即时聊天应用[三]-账号信息、添加好友、JID理解等)给好友发送文本消息1chat.sendMessage(message); 2.获取聊天对象管理器1234567891011/** * 获取聊天对象管理器 * @return */ public ChatManager getChatManager() { if(isConnected()) { ChatManager chatManager = ChatManager.getInstanceFor(connection); return chatManager; } throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); } 3.接收文本消息1234567891011121314//创建聊天对象管理器监听private ChatManagerListener chatManagerListener = new ChatManagerListener() { @Override public void chatCreated(Chat chat, boolean createdLocally) { chat.addMessageListener(new ChatMessageListener() { @Override public void processMessage(Chat chat, Message message) { //接收到消息Message之后进行消息展示处理，这个地方可以处理所有人的消息 } }); }};//设置聊天对象管理器处理监听getChatManager().addChatListener(chatManagerListener); 上述代码会在你创建聊天对象时对该聊天对象设置消息处理监听，当接收到消息之后，会自动调用processMessage方法进行处理，我们可以在该方法中对接收到的消息进行展示或其他处理，所有好友发送过来的消息都会通过该方法处理。所以该监听最好在登陆之后进行设置，同时在断开连接或是注销时移除该监听。 4.创建群聊聊天室123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 /** * 创建群聊聊天室 * @param roomName 聊天室名字 * @param nickName 创建者在聊天室中的昵称 * @param password 聊天室密码 * @return */ public MultiUserChat createChatRoom(String roomName, String nickName, String password) { if(!isConnected()) { throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); } MultiUserChat muc = null; try { // 创建一个MultiUserChat muc = MultiUserChatManager.getInstanceFor(connection).getMultiUserChat(roomName + \"@conference.\" + connection.getServiceName()); // 创建聊天室 boolean isCreated = muc.createOrJoin(nickName); if(isCreated) { // 获得聊天室的配置表单 Form form = muc.getConfigurationForm(); // 根据原始表单创建一个要提交的新表单。 Form submitForm = form.createAnswerForm(); // 向要提交的表单添加默认答复 List fields = form.getFields(); for(int i = 0; fields != null &amp;&amp; i &lt; fields.size(); i++) { if(FormField.Type.hidden != fields.get(i).getType() &amp;&amp; fields.get(i).getVariable() != null) { // 设置默认值作为答复 submitForm.setDefaultAnswer(fields.get(i).getVariable()); } } // 设置聊天室的新拥有者 List owners = new ArrayList(); owners.add(connection.getUser());// 用户JID submitForm.setAnswer(\"muc#roomconfig_roomowners\", owners); // 设置聊天室是持久聊天室，即将要被保存下来 submitForm.setAnswer(\"muc#roomconfig_persistentroom\", true); // 房间仅对成员开放 submitForm.setAnswer(\"muc#roomconfig_membersonly\", false); // 允许占有者邀请其他人 submitForm.setAnswer(\"muc#roomconfig_allowinvites\", true); if(password != null &amp;&amp; password.length() != 0) { // 进入是否需要密码 submitForm.setAnswer(\"muc#roomconfig_passwordprotectedroom\", true); // 设置进入密码 submitForm.setAnswer(\"muc#roomconfig_roomsecret\", password); } // 能够发现占有者真实 JID 的角色 // submitForm.setAnswer(\"muc#roomconfig_whois\", \"anyone\"); // 登录房间对话 submitForm.setAnswer(\"muc#roomconfig_enablelogging\", true); // 仅允许注册的昵称登录 submitForm.setAnswer(\"x-muc#roomconfig_reservednick\", true); // 允许使用者修改昵称 submitForm.setAnswer(\"x-muc#roomconfig_canchangenick\", false); // 允许用户注册房间 submitForm.setAnswer(\"x-muc#roomconfig_registration\", false); // 发送已完成的表单（有默认值）到服务器来配置聊天室 muc.sendConfigurationForm(submitForm); }} catch (XMPPException | SmackException e) { e.printStackTrace(); return null; } return muc; } 上面这段创建群聊聊天室设置表单属性的那段代码引用于网上的代码段。 5.加入群聊聊天室123456789101112131415161718192021222324252627/** * 加入一个群聊聊天室 * @param roomName 聊天室名字 * @param nickName 用户在聊天室中的昵称 * @param password 聊天室密码 * @return */ public MultiUserChat joinChatRoom(String roomName, String nickName, String password) { if(!isConnected()) { throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); } try { // 使用XMPPConnection创建一个MultiUserChat窗口 MultiUserChat muc = MultiUserChatManager.getInstanceFor(connection). getMultiUserChat(roomName + \"@conference.\" + connection.getServiceName()); // 聊天室服务将会决定要接受的历史记录数量 DiscussionHistory history = new DiscussionHistory(); history.setMaxChars(0); // history.setSince(new Date()); // 用户加入聊天室 muc.join(nickName, password); return muc; } catch (XMPPException | SmackException e) { e.printStackTrace(); return null; } } 在实现加入群聊聊天室的这段代码中有这么一段代码：1getMultiUserChat(roomName + \"@conference.\" + connection.getServiceName()); 在@与ServiceName中间必须加上conference这个字符串，我也不知道为什么，我最开始时不知道没有加，然后无论如何都加入失败，后来在网上查资料查了半天，有人说是要加上这个，然后我加上就成功了，暂时没搞明白为什么，先把程序跑通会用了再研究其他的原因。 6.群聊发送消息当你创建或是加入群聊聊天室后，即可获得群聊对象MultiUserChat，通过该对象即可发送群聊消息：1multiUserChat.sendMessage(msg);//发送群聊消息 7.接收群聊消息123456789//聊天室消息监听private MessageListener messageListener = new MessageListener() { @Override public void processMessage(Message message) { //与单聊接收处理消息类似，聊天室里所有人(包括发送人自己)发送的消息都会通过此方法进行回调处理 }};//设置聊天室消息监听multiUserChat.addMessageListener(messageListener); 群聊接收消息与单聊接收消息还是很像的，只是监听对象，监听方式稍稍有点区别，整个来说，消息接收还是很简单的。 8.获取文件传输对象123456789101112/** * 获取发送文件的发送器 * @param jid 一个完整的jid(如：laohu@192.168.0.108/Smack * 后面的Smack应该客户端类型，不加这个会出错) * @return */ public OutgoingFileTransfer getSendFileTransfer(String jid) { if(isConnected()) { return FileTransferManager.getInstanceFor(connection).createOutgoingFileTransfer(jid); } throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); } 获取文件传输对象时的参数JID记得为文件传输JID：解释请参考我的系列文章之基于openfire+smack开发Android即时聊天应用[三]-账号信息、添加好友、JID理解等 9.发送文件123456//获取文件传输对象OutgoingFileTransfer transfer = getSendFileTransfer(jid);//发送文件transfer.sendFile(File file, String description);//此处执行文件发送状态监听以上代码为发送文件file，参数description为对这次文件传输的描述 10.文件传输(包括文件发送与接收)过程监听(传输开始、完成、进度百分比)12345678910111213141516171819202122//文件传输过程中的状态监听分析if(transfer.getProgress() &lt; 1) {//开始传输//传输进度，值为0~1}while(!transfer.isDone()) {//判断传输是否完成，传输取消、传输完成、传输发生错误都会返回true try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); }}if(FileTransfer.Status.complete.equals(transfer.getStatus())) { //传输完成 } else if(FileTransfer.Status.cancelled.equals(transfer.getStatus())) { //传输取消} else if(FileTransfer.Status.error.equals(transfer.getStatus())) { //传输错误} else if(FileTransfer.Status.refused.equals(transfer.getStatus())) { //传输拒绝} 以上代码需在子线程执行，可以在文件传输(发送、接收)开始时设置进度条，传输完成时去掉进度条，同时可以通过getProgress()方法获得文件传输的具体进度百分比。 11.接收文件12345678910111213141516171819202122232425262728 /** * 添加文件接收的监听 * @param fileTransferListener */ public void addFileTransferListener(FileTransferListener fileTransferListener) { if(isConnected()) { FileTransferManager.getInstanceFor(connection).addFileTransferListener(fileTransferListener); return; } throw new NullPointerException(\"服务器连接失败，请先连接服务器\"); }addFileTransferListener(new FileTransferListener() { @Override public void fileTransferRequest(FileTransferRequest request) { // Accept it IncomingFileTransfer transfer = request.accept(); try { String description = request.getDescription(); //在目录fileDir目录下新建一个名字为request.getFileName()的文件 File file = new File(fileDir ,request.getFileName()); //开始接收文件(将传输过来的文件内容输出到file中) transfer.recieveFile(file); //此处执行文件传输监听 } catch (SmackException | IOException e) { e.printStackTrace(); } }}); 上面代码为设置文件接收监听 12.发送语音、图片消息我查看了半天的Smack的API，但是没有找到直接发送语音、图片消息的API，我说说我的实现思路。 其实图片、语音都是文件，我们可以把它们当做文件发送给好友。 在发送文件的同时，用描述字段进行标记传输过来的是图片还是语音。 然后在接收到该文件后通过描述字段进行区分当前接收的是图片文件还是语音文件，然后进行区分展示即可，这样就可以达到发送图片消息和语音消息。 但是我的这种实现方式还是有问题的，因为这种方式对于单聊还是可以实现的。但是如果是群聊的话，我就必须给每个人都发一个相同的文件，这样的话一条语音或图片消息，其实是要发送N次的，对于发送人来说流量就多消耗了N-1倍，所以这种方式对于实现群聊是行不通的。 对于群聊发送语音和图片消息，我的思路是这样的： 自己写一个上传文件的服务。 发送语音或图片消息时，将图片或语音通过上述上传服务上传到服务器上。 在上传完语音或图片后，再向聊天室里发送一个文本消息，发送内容为文件的类似下载地址这样的信息，同时还要告诉群成员这个文件是图片还是语音。 群成员接收到这样的特殊文本消息后去自动下载这个文件然后进行展示或是其他处理。 群聊天里发送图片或语音消息的这个实现方式我没有验证，但我觉得应该是可行的。至于单聊发送语音或图片消息的思路我是实现验证成功了的，是可行的。 write by laohu 2015-10-30 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/基于openfire-smack开发Android即时聊天应用-四-单人聊天、群聊、发送接收文件等.html"},{"title":"浅谈JSONP跨域请求","text":"第一次听说JSONP跨域请求还是去年刚入职实习的时候，也借那个机会在网上好好了解了下用法，但是对于其如何实现还是不太明白。昨天一同事问我当时对JSONP的使用情况，突然发现一年多没用，对于这个跨域请求技术又忘的差不多了，刚好不知道这个星期该写篇什么方面的文章，那就趁这个机会再把JSONP琢磨琢磨顺便把过程记录下来，免得下次不记得了又得到网上到处找资源查阅。 OK，进入正题！！！！ 先看JSONP定义 JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 server1.example.com的网页无法与不是 server1.example.com的服务器沟通，而 HTML 的&lt;script&gt; 元素是一个例外。利用 &lt;script&gt; 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。JSONP它是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。——来自百度 同源策略 同源策略是一种约定，也是浏览器本身最核心最基本的一个安全功能。所谓同源是指协议、域名、端口相同，也就是说同源策略不允许一个站点的某个文档或脚本加载请求另一个站点的文档或脚本，具体看下如下实验： 我新建一个站点作为本地站点，端口号为8080，如下：再建一个站点作为远程站点，端口号为8085，如下：我在本地站点中添加两个按钮，一个请求远程站点文档，一个请求本地站点文档，我们来看看效果如何请求代码如下：12345678910111213141516//请求远程站点文档function remoteBtnClick() { $.get(\"http://localhost:8085/Remote/jslib/jquery-1.7.2.js\", function(data){ console.log(data); } );}//请求本地站点文档function localBtnClick() { $.get(\"http://localhost:8080/Local/jslib/jquery-1.7.2.js\", function(data){ console.log(data); } );} 请求响应结果如下：正如前面说的，根据同源策略浏览器不允许本地站点直接通过Http请求读取另外一个远程站点的资源信息。 看到这，相信大家很快会想到一种情况———引入外部js类库&lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&quot;&gt;&lt;/script&gt;比如这个引入百度地图JS类库的代码，很明显，这个地图JS类库和我们自己的站点明显不是在同一个域内，对于这种情况我也写一个测试程序验证一下。我在本地站点8080的页面中添加这样一行代码&lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:8085/Remote/jslib/remote.js&quot;&gt;&lt;/script&gt;以希望在本地页面加载的时候同时加载远程站点8085里的remote.js文件，remote.js文件中的内容如下：运行代码之后的效果图如下：很显然，通过这种方式是完全可以读取远程站点的文档信息的，也就是说像这种src属性的加载方式是不受同源策略所约束可以访问任何站点的文档信息，另外像大家用的很多的图片加载标签，也经常通过其src属性加载网络图片。 实现基本的跨域请求 看了上面的例子和JSONP的定义相信大家已经明白了JSONP跨域请求的基本原理，利用script的这种加载方式我们就可以实现跨域请求。 我在本地站点中动态构造一个script标签，然后将其src的url指向远程站点的文档，最后将这个script标签添加到页面dom中，先写个例子看这种方式能不能行得通。1234//远程站点8085上remote.js中的内容依然和上面一样，不做任何改变function remoteBtnClick() { $(\"&lt;script&gt;&lt;//script&gt;\").attr(\"src\", \"http://localhost:8085/Remote/jslib/remote.js\").appendTo(\"body\")} 运行之后的结果和上面直接通过&lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:8085/Remote/jslib/remote.js&quot;&gt;&lt;/script&gt;加载的效果是一样，这里就不继续贴图，因为原理是一样，很显然结果必然相同，而且也没必要动态写这么麻烦，直接加载岂不是更直接。 接着我们来另外一个情况，既然JSONP定义中说了JSONP拿到的是JSON数据，那我们将远程站点请求文件remote.js换成一个JSON数据文件remote.json({&quot;data&quot;:&quot;来自远程站点的数据&quot;,&quot;time&quot;:&quot;2014-12-20&quot;})再试试。123function remoteBtnClick() { $(\"&lt;script&gt;&lt;//script&gt;\").attr(\"src\", \"http://localhost:8085/Remote/remote.json\").appendTo(\"body\")} 图1： 图2： 看图1中的请求响应结果，很明显，这个json数据已经从远程站点请求成功并且拿到了本地站点下。通过图2我们发现这里有个javascript的语法错误，因为我们是通过javascript标签的方式加载的，而这个标签是将文档加载完成后会立即把其当做js执行，而这个json数据很明显不是一个合法的js语句。既然这样，那我们就想办法让这个json数据变成一个合法的js语句，最简单的方法就是将这个json数据当做一个函数的参数给塞进去，例如：callbackHandler({&quot;data&quot;:&quot;来自远程站点的数据&quot;,&quot;time&quot;:&quot;2014-12-20&quot;})，如果本地站点中有一个callbackHandler函数，那么远程站点返回的这个数据就是一个合法的js函数，很显然这个时候单纯的通过js客户端来验证这个例子是无法实现的，因为在远程站点8085中无论是json文件还是js文件中都无法直接构造callbackHandler({&quot;data&quot;:&quot;来自远程站点的数据&quot;,&quot;time&quot;:&quot;2014-12-20&quot;})这么一段代码(语法不正确)给本地站点8080去远程调用。123function callbackHandler(json) { console.log(json)} 这个时候就需要远程站点的服务端进行配合，由于远程站点后端服务不知道本地客户端的回调函数名是callbackHandler，所以，我们需要在远程调用的时候告诉服务端本地的回调函数名是callbackHandler，此时的本地站点8080上的请求方式则换这样：12345$(\"&lt;script&gt;&lt;//script&gt;\").attr(\"src\", \"http://localhost:8085/Remote/JSONPServlet?callback=callbackHandler\").appendTo(\"body\")}function callbackHandler(data) { console.log(data);} 远程站点8085上服务端代码如下： 123456789public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String callback = request.getParameter(\"callback\"); response.setContentType(\"text/html\"); PrintWriter out = response.getWriter(); out.println(callback + \"({'data':'The data from remote','time':'2014-12-20'})\"); out.flush(); out.close();} 服务端通过参数解析知道本地站点客户端的回调函数名是callbackHandler，远程服务端构造一段callbackHandler({&quot;data&quot;:&quot;The data from remote&quot;,&quot;time&quot;:&quot;2014-12-20&quot;})返回即可，这样在script标签加载完成后会直接将取得的json数据当做参数传入该回调函数中执行，这样整个跨域请求(请求服务端)就完成了。JSONP的跨域请求差不多就这样实现了，但是运行效果如下：运行结果正如我们所想，通过script方式加载远程服务返回javascript tags可以顺利实现跨域访问，这里我也继续试验下直接通过ajax方式访问远程后端服务，将remoteBtnClick()实现改为如下方式：123456$.get(\"http://localhost:8085/Remote/JSONPServlet?callback=callbackHandler\", function(data){ console.log(data); } );} 请求结果如下：显然，请求的结果和前面的请求远程站点客户端文档信息是一样，因为同源策略而无法访问。 OK，JSONP的实现方式和相关验证基本上就爱完成了，现在也知道了JSONP的实现原理和实现方式，但是上面这种实现方式有点麻烦，既要自己添加script标签，同时还要自己定义一个回调函数，感觉略显麻烦，其实jQuery中已经直接提供类似的JSONP请求方式，我们只需要按照其定义好调用方式即可进行Http的跨域请求。现在我将remoteBtnClick()实现方式修改为如下，远程服务端代码不修改：1234567891011121314151617function remoteBtnClick() { $.ajax({ url: 'http://localhost:8085/Remote/JSONPServlet', dataType: \"jsonp\", jsonp: \"callback\", jsonpCallback: \"callbackHandler\", success: function (data) { console.log(data); console.log(\"success\"); } });}//客户端回调function callbackHandler(json) { console.log(json); console.log(\"callbackHandler\");} 请求结果如下： 可以看到，现在直接通过ajax请求远程站点服务也成功实现了跨域请求，这个是jQuery自己已经帮我们封装好的功能。对于ajax请求中的几个参数我简单说描述下作用： dataType:’jsonp’，这个是代表当前Http请求为jsonp的请求方式； jsonp：’callback’,这个代表的是远程服务端接收客户端回调函数名的参数名，即：String callback = request.getParameter(&quot;callback&quot;)这个参数，ajax请求中jsonp参数的默认值就是callback，这个也可以自己随便更换； jsonpCallback:’callbackHandler’,这个代表远程服务调用结束后的本地回调函数名，比如上面的代码中的那个客户端回调函数名，这个jsonpCallback的参数值也是可以自己随便定义的，也可以不给这个jsonpCallback参数，其实jQuery会自动为我们生成一个函数和函数名，从上面的结果图中我们可以看到，远程服务调用成功后，既执行了SUCCESS这个回调函数，也执行我们自己定义的callbackHandler这个回调函数，所以我们完全可以使用jQuery给我们生成的回调函数，在调用结束后在SUCCESS回调中做相应的处理即可，如下是不加该参数的调用方式：12345678$.ajax({ url: 'http://localhost:8085/Remote/JSONPServlet', dataType: \"jsonp\", jsonp: \"callback\", success: function (data) { console.log(data); } }); 上面结果图中的圈中部分就是jQuery为我们自动生成的回调函数名。 OK，JSONP的实现方式及实现原理基本上介绍演示完了，至于jQuery中对于JSONP的实现封装方式等我有时间研究下了再继续吧~~ write by laohu2015年3月20日 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/浅谈JSONP跨域请求.html"},{"title":"让RecyclerView更通用","text":"何为通用用过RecyclerView的都知道它没有为我们提供像ListView中类似addHeaderView，addFooterView，setOnItemClickListener，setOnItemLongClickListener的接口，另外还有底部自动加载更多，这些都是列表使用中很常见的功能，所以如果我们使用RecyclerView来实现列表的话就需要自己实现这些功能。本文主要介绍这些通用功能的实现方式，使得RecyclerView使用起来和ListView一样方便。 点击事件setOnItemClickListener，setOnItemLongClickListenerRecyclerView中虽然没有提供上面这两个接口，但是给我们提供了另外一个接口：OnItemTouchListener看这个接口的文档描述我们知道此接口可以对RecyclerView中的手势进行监听处理，因此我们可以采用OnItemTouchListener+GestureDetector来实现RecyclerView的OnItemClick和OnItemLongClick。实现方式也比较简单，还是上代码吧…12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private OnItemClickListener mOnItemClickListener;private OnItemLongClickListener mItemLongClickListener; mGestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() { @Override public void onLongPress(MotionEvent e) { super.onLongPress(e); if(mItemLongClickListener != null) { View childView = findChildViewUnder(e.getX(), e.getY()); if(childView != null) { int position = getChildLayoutPosition(childView); mItemLongClickListener.onItemLongClick(position, childView); } } } @Override public boolean onSingleTapUp(MotionEvent e) { if(mOnItemClickListener != null) { View childView = findChildViewUnder(e.getX(),e.getY()); if(childView != null){ int position = getChildLayoutPosition(childView); mOnItemClickListener.onItemClick(position, childView); return true; } } return super.onSingleTapUp(e); }}); addOnItemTouchListener(new SimpleOnItemTouchListener() { @Override public boolean onInterceptTouchEvent(RecyclerView rv, MotionEvent e) { if (mGestureDetector.onTouchEvent(e)) {//交由手势处理 return true; } return false; }});/** * Item项点击事件 */public interface OnItemClickListener { void onItemClick(int position, View itemView);} /** * Item项长按点击事件 */public interface OnItemLongClickListener { void onItemLongClick(int position, View itemView);} addHeaderView，addFooterView实现原理前面写过一篇文章RecyclerView下拉刷新上拉加载 介绍过RecyclerView的上拉加载的实现方式，里面的上拉加载进度条其实也是RecyclerView的一个FooterView，其实现方式就是为LoadMoreView设置了一个特殊的ItemViewType来进行区分展示，因此我这里的HeaderView和FooterView也是通过为它们设置不同的ItemViewType来进行区分展示。 我们知道ListView中的addHeaderView和addFooterView都是可以添加多个View的，也就是说RecyclerView中也会出现添加多个完全不同的HeaderView或FooterView，所以我们必须为添加的每个HeaderView和FooterView都设置一个ItemViewType从而达到添加多个不同的HeaderView或FooterView的目的(如果所有的HeaderView或FooterView都设置同一个ItemViewType的话只能显示一种View的HeaderView或FooterView)。 实现步骤知道了实现原理，我们再来理一下实现步骤： 因为每个HeaderView或FooterView都需要对应一个ItemViewType，所以我们需要分别为它们建立一个映射关系，我采用SparseArray实现映射 我们需要在添加HeaderView或FooterView的时候生成对应的ItemViewType值，也就是我们需要定义一个ItemViewType的生成规则，我采用了基准值+视图个数的方式生成ItemViewType 自定义一个Adapter继承自RecyclerView.Adapter，重写里面的几个方法：onCreateViewHolder，onBindViewHolder，getItemViewType，getItemCount getItemCount方法中返回的数据总数显然是：HeaderView总数+FooterView总数+List列表展示的数据总数 重写onBindViewHolder，getItemViewType这两个方法时，显然需要根据position判断当前位置是否为HeaderView或是FooterView，而根据展示顺序来看当0&lt;=position&lt;HeaderView总数 时是HeaderView，而当position&gt;=(HeaderView总数+List总数)时则是FooterView，其余位置则是List数据对应的View 而重写onCreateViewHolder方法时，则可用直接根据其方法参数viewType在SparseArray映射中查找是否存在该类型的HeaderView或是FooterView，有则返回，没有则返回List数据展示的View关键代码分析完实现的步骤开始撸代码，下面是我实现的关键代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153//HeaderView的ItemViewType的生成基准值，生成规则为基准值+当前HeaderView的个数private static final int TYPE_HEADER = 100000;//FooterView的ItemViewType的生成基准值，生成规则为基准值+当前的FooterView的个数private static final int TYPE_FOOTER = 200000; //存储HeaderView，key值作为对应HeaderView的ItemViewTypeprivate SparseArray&lt;View&gt; mHeaderViews = new SparseArray&lt;&gt;(0);//存储FooterView，key值作为对应HeaderView的ItemViewTypeprivate SparseArray&lt;View&gt; mFooterViews = new SparseArray&lt;&gt;(0); @Overridepublic final ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { if(isHeaderViewEnable() &amp;&amp; mHeaderViews.get(viewType) != null) { return new ViewHolder(mHeaderViews.get(viewType)); } else if(isFooterViewEnable() &amp;&amp; mFooterViews.get(viewType) != null) { return new ViewHolder(mFooterViews.get(viewType)); } return onCreateItemViewHolder(parent, viewType);} @Overridepublic final void onBindViewHolder(ViewHolder holder, int position) { if(isFooterView(position) || isHeaderView(position)) { return; } T item = getItem(position - getHeaderViewCount()); onBindItemViewHolder(holder, position, item);} @Overridepublic final int getItemViewType(int position) { if(isHeaderView(position)) {//FooterView return mHeaderViews.keyAt(position); } if(isFooterView(position)){//HeaderView return mFooterViews.keyAt(position - getHeaderViewCount() - getItemDataCount()); } return getItemViewTypeForData(position);} /*** 展示的总数据数(包括HeaderView和FooterView)** @return*/@Overridepublic final int getItemCount() { //从写此方法，数据总数需要包括HeaderView总数和FooterView总数 return getItemDataCount() + getHeaderViewCount() + getFooterViewCount();} /*** 要展示的有效数据数(不包括HeaderView和FooterView)** @return*/public int getItemDataCount() { return mList == null ? 0 : mList.size();} /*** 获取HeaderView的总数** @return*/public int getHeaderViewCount() { return isHeaderViewEnable() ? mHeaderViews.size() : 0;} /*** 获取FooterView的总数** @return*/public int getFooterViewCount() { return isFooterViewEnable() ? mFooterViews.size() : 0;}/*** 判断position位置是否为FooterView** @param position* @return*/public boolean isFooterView(int position) { return isFooterViewEnable() &amp;&amp; isFooterViewPosition(position);} /*** 判断position位置是否为HeaderView** @param position* @return*/public boolean isHeaderView(int position) { return isHeaderViewEnable() &amp;&amp; isHeaderViewPosition(position);} /*** 判断position位置是否为FooterView的索引** @param position* @return*/public boolean isFooterViewPosition(int position) { return position &gt;= getItemDataCount() + getHeaderViewCount();} /*** 判断position位置是否为HeaderView的索引** @param position* @return*/public boolean isHeaderViewPosition(int position) { return position &lt; getHeaderViewCount();} /** * 添加一个HeaderView * * @param headerView */public void addHeaderView(View headerView) { if(headerView == null) { throw new NullPointerException(\"headerView is null\"); } mHeaderViews.put(TYPE_HEADER + getHeaderViewCount(), headerView); notifyItemInserted(getHeaderViewCount() - 1);} /** * 添加一个FooterView * * @param footerView */public void addFooterView(View footerView) { if(footerView == null) { throw new NullPointerException(\"footerView is null\"); } mFooterViews.put(TYPE_FOOTER + getFooterViewCount(), footerView); notifyItemInserted(getHeaderViewCount() + getItemDataCount() + getFooterViewCount() - 1);} RecyclerView使用注意 这里需要注明一点RecyclerView使用中的坑，如果RecyclerView为LinearLayoutManager时在onCreatViewHolder中生成的View都必须关联上其parent，也就是关联到RecyclerView本身。我前面的一片文章记录了我遇到的这个问题RecyclerView子View宽度不充满父容器，所以在addHeaderView和addFooterView时也需要注意这个问题 如果你的RecyclerView的LayoutManager是GridLayoutManager或StaggeredGridLayoutManager时，如果就这样添加HeaderView或FooterView，会发现HeaderView或FooterView不会独立的占据一行。这是因为设置了SpanSize的缘故，所以我们需要针对这两种LayoutManager进行处理，处理方式如下： 1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic void onAttachedToRecyclerView(RecyclerView recyclerView) { super.onAttachedToRecyclerView(recyclerView); final RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager(); if(layoutManager instanceof GridLayoutManager) { ((GridLayoutManager) layoutManager).setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() { @Override public int getSpanSize(int position) { return getNewSpanSize(((GridLayoutManager) layoutManager).getSpanCount(), position); } }); }} @Overridepublic void onViewAttachedToWindow(ViewHolder holder) { super.onViewAttachedToWindow(holder); int position = holder.getLayoutPosition(); if(isHeaderView(position) || isFooterView(position)) { final ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams(); if(layoutParams != null &amp;&amp; layoutParams instanceof StaggeredGridLayoutManager.LayoutParams) { StaggeredGridLayoutManager.LayoutParams lp = (StaggeredGridLayoutManager.LayoutParams) layoutParams; lp.setFullSpan(true); } }} private int getNewSpanSize(int spanCount, int position) { if(isHeaderView(position) || isFooterView(position)) { return spanCount; } return 1;} 自动加载更多自动加载更多也是列表显示中比较常见的一个功能，我们可以为RecyclerView设置ScrollListener监听来进行实现，具体实现的关键代码如下；123456789101112131415161718192021222324252627super.setOnScrollListener(new OnScrollListener() { @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) { super.onScrollStateChanged(recyclerView, newState); if(newState == SCROLL_STATE_IDLE &amp;&amp; mIsAutoLoadMore &amp;&amp; mLoadMoreListener != null) { if(mLastVisiblePosition + 1 == getAdapter().getItemCount()) { mLoadMoreListener.onLoadMore(); } } if(mOnScrollListener != null) { mOnScrollListener.onScrollStateChanged(recyclerView, newState); } } @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { super.onScrolled(recyclerView, dx, dy); if(mIsAutoLoadMore &amp;&amp; mLoadMoreListener != null) { mLastVisiblePosition = getLastVisiblePosition(); } if(mOnScrollListener != null) { mOnScrollListener.onScrolled(recyclerView, dx, dy); } }}); 文章相关的完整代码和Demo：https://github.com/huyongli/AndroidDemo 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/让RecyclerView更通用.html"},{"title":"自定义实现微信通讯录效果View","text":"前言在使用App过程中，经常会有使用到联系人或城市列表的场景，其实这两种效果是一样的，都是右边有个索引列表，点击索引列表可跳转到指定字母开头的联系人或城市上去，同时向上滑动过程中头部会有个显示当前联系人首字母的界面固定不动。下面我以微信通讯录的效果作为例子，介绍我是如何实现一个这样效果自定义View的思路和过程。 实现效果下面是我实现的最终效果图(GIF录制的不太好)，想看源代码的同学戳这里https://github.com/huyongli/IndexStickyView 思路分析既然要高仿实现微信通讯录的效果，那我们来先看看微信通讯录的效果 微信通讯录效果分析通过对微信通讯的效果进行分析之后，得出如下几点： 通讯录展示分为两部分： 主体：联系人列表 索引条：右边字母索引条 主体联系人列表又分为三部分： 联系人姓名和头像展示 根据联系人姓名的首字母进行分组，每组开头都会显示组名称(首字母)，并按字母顺序排序 列表开头的四个菜单，可以看成是一个特殊组数据，但是无组名称展示 索引条中的内容与联系人列表中的所有组字母一样，同时点击索引条中的字母会将列表定位到当前字母所代表的联系人组，因此索引条的每个字母会与该字母所代表联系人组的位置有个一一对应关系 点击索引条中的↑会定位到列表头部的四个菜单上，因此可以将↑与四个菜单作为一组对应关系，只是该菜单组无组名称 点击索引条的某个字母时，列表中间会有该字母的提示显示 列表向上滑动时当前组的组名称固定在列表头部显示不动，直到下一组组名称滑动到顶部时，原来固定不动的组名称视图开始往上滑出，下一组组名称顶替上去 实现思路分析 既然要展示联系人列表，所以我采用RecyclerView 滑动过程中顶部会有个视图固定不动，而RecyclerView滑动时不可能有子视图固定不动，因此我采用一个独立的视图View来作为这个固定不动的顶部视图显示组名称，在滑动过程中控制该View的显示和隐藏及其内容的变化，显然这个时候就需要父视图将RecyclerView和这个头部视图View包装起来 索引条因为是一个字母索引列表，因此我采用自定义View来绘制这些字母，在绘制过程中每个字母在索引条中要水平居中，而当列表头部有固定显示某个组名称(字母)时，索引条中对应的字母会有一个红色的圆作为该字母的背景，同时字母在圆中居中显示 点击索引条的字母时，列表中间出现的字母提示也采用一个独立的View显示，并将该View放到与RecyclerView所处的同一父视图。 索引条中的每个字母都需要与列表中对应组所在的位置索引有个一一对应的关系 因为微信通讯录中顶部的四个菜单与其他联系人具有不同的行为和展示方式，因此最终实现的View需要支持自定义显示不同的头部视图及对应的索引字母 实现细节下面我介绍下我在实现过程中的一些要点 数据处理用户数据一般应用在实现过程中，拿到的只有具体的联系人数据，而没有联系人对应的首字母，如果说我们自定义的View需要开发者将联系人对应的首字母也传进来，那这个自定义View写的也太lower了，对开发者太不友好了。因此我们最终实现的View所需要的数据就是开发者能拿到的联系人数据即可，这样的话就需要我们在实现View的过程中将开发者传递过来的联系人数据进行处理，然后得到我们在RecyclerView中展示的实际数据(联系人+字母索引)。 既然要对联系人数据进行处理得到该联系人的首字母，所以我定义了一个实体接口，所有的联系人数据实体必须实现这个接口以便告知我们需要对那个数据字段进行处理得到其索引首字母，具体接口如下：1234567public interface BaseEntity { /** * 要索引的字段数据信息，例如联系人中对姓名进行索引，则此处返回姓名字段值 * @return */ String getIndexField();} 展示数据列表在展示过程中有两种类型数据，一种是联系人数据，一种是联系人所在组的组名称(索引值)，所以最终在RecyclerView中进行展示时使用用户数据实体BaseEntity是无法达到这种展示效果的，因此我定义了一个RecyclerView实际展示数据的实体类，如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class IndexStickyEntity&lt;T&gt; { /** * 当前数据项的类型，自动转换赋值 */ private int mItemType = ItemType.ITEM_TYPE_CONTENT; /** * 当前数据的索引值，自动转换赋值(索引条中显示的文字) */ private String mIndexValue; /** * 索引视图显示的索引名称（组名称） */ private String mIndexName; /** * 原始数据，用户实际展示的数据,用于视图的绑定 * 当次值为null时，则表示此实体代表一个Index数据 * T extends BaseEntity */ private T mOriginalData; /** * 当前数据项的拼音 */ private String mPinYin; ... setter &amp; getter}public class ItemType { /** * 列表中普通数据项类型，例如联系人列表中的：联系人信息项 */ public static final int ITEM_TYPE_CONTENT = 1000000; /** * 列表中索引项类型，例如联系人列表中的：A,B,C...等索引数据 */ public static final int ITEM_TYPE_INDEX = 2000000; /** * 列表中增加头部索引数据(如自定义的常用联系人) */ public static final int ITEM_TYPE_INDEX_HEADER = 3000000; /** * 列表中增加底部索引数据 */ public static final int ITEM_TYPE_INDEX_FOOTER = 4000000;} 用户数据 –&gt;展示数据在拿到用户的联系人数据后，进行转换处理得到真实展示数据，实现如下，代码中注释比较清晰，就不一一解释其实现逻辑了：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class ConvertHelper { /** * 转换过程中，如果待索引字段信息为非字母串，则将其索引值设为：# */ public static final String INDEX_SPECIAL = \"#\"; public static class ConvertResult&lt;T&gt; { //转换后得到的实际展示数据列表，包括联系人数据+组名称数据(索引名称) private List&lt;IndexStickyEntity&lt;T&gt;&gt; mIndexStickyEntities = new ArrayList&lt;&gt;(); //索引条中展示的数据列表 private List&lt;String&gt; mIndexValueList = new ArrayList&lt;&gt;(); //索引条中展示数据与对应组在列表中位置索引的一一映射 private Map&lt;String, Integer&gt; mIndexValuePositionMap = new HashMap&lt;&gt;(); public List&lt;IndexStickyEntity&lt;T&gt;&gt; getIndexStickyEntities() { return mIndexStickyEntities; } public List&lt;String&gt; getIndexValueList() { return mIndexValueList; } public Map&lt;String, Integer&gt; getIndexValuePositionMap() { return mIndexValuePositionMap; } } //拿到数据后调用此方法进行数据转换处理 public static &lt;T extends BaseEntity&gt; ConvertResult&lt;T&gt; transfer(List&lt;T&gt; list) { ConvertResult&lt;T&gt; convertResult = new ConvertResult&lt;T&gt;(); //使用TreeMap自动按照Key(字母索引值)进行排序 TreeMap&lt;String, List&lt;IndexStickyEntity&lt;T&gt;&gt;&gt; treeMap = new TreeMap&lt;&gt;(ComparatorFactory.indexValueComparator()); for(int i = 0; i &lt; list.size(); i++) { IndexStickyEntity&lt;T&gt; entity = originalEntityToIndexEntity(list.get(i)); if(treeMap.containsKey(entity.getIndexValue())) {//Map中已存在此索引值 treeMap.get(entity.getIndexValue()).add(entity); } else { List&lt;IndexStickyEntity&lt;T&gt;&gt; indexStickyEntities = new ArrayList&lt;&gt;(); indexStickyEntities.add(entity); treeMap.put(entity.getIndexValue(), indexStickyEntities); } } for(String indexValue : treeMap.keySet()) { //创建组名称展示数据实体 IndexStickyEntity&lt;T&gt; indexValueEntity = createIndexEntity(indexValue, indexValue); //将索引值添加到索引值列表中 convertResult.getIndexValueList().add(indexValue); //按顺序将索引实体添加到列表中 convertResult.getIndexStickyEntities().add(indexValueEntity); //将索引值与索引值在结果列表中的位置进行映射 convertResult.getIndexValuePositionMap().put(indexValue, convertResult.getIndexStickyEntities().size() - 1); //得到当前索引值下的索引数据实体 List&lt;IndexStickyEntity&lt;T&gt;&gt; indexStickyEntities = treeMap.get(indexValue); //对数据实体按自然进行排序 Collections.sort(indexStickyEntities, ComparatorFactory.&lt;T&gt;indexEntityComparator()); //将排序后的实体列表按顺序加入到结果列表中 convertResult.getIndexStickyEntities().addAll(indexStickyEntities); } return convertResult; } /** * 原始数据转换成展示的索引数据 * @param originalEntity * @param &lt;T&gt; * @return */ public static &lt;T extends BaseEntity&gt; IndexStickyEntity&lt;T&gt; originalEntityToIndexEntity(T originalEntity) { IndexStickyEntity&lt;T&gt; entity = new IndexStickyEntity&lt;&gt;(); T item = originalEntity; String indexFieldName = item.getIndexField(); String pinyin = PinYinHelper.getPingYin(indexFieldName); String indexValue; if(PinYinHelper.isLetter(pinyin)) {//首字符是否为字母 indexValue = pinyin.substring(0, 1).toUpperCase(); } else {//非字母以#代替 indexValue = INDEX_SPECIAL; } entity.setPinYin(pinyin); entity.setOriginalData(item); entity.setIndexValue(indexValue); entity.setIndexName(indexValue); return entity; } /** * 根据索引值创建索引实体对象 * @param indexValue * @param &lt;T&gt; * @return */ public static &lt;T extends BaseEntity&gt; IndexStickyEntity&lt;T&gt; createIndexEntity(String indexValue, String indexName) { //根据索引值创建索引实体对象 IndexStickyEntity&lt;T&gt; indexValueEntity = new IndexStickyEntity&lt;&gt;(); indexValueEntity.setIndexValue(indexValue); indexValueEntity.setPinYin(indexValue); indexValueEntity.setIndexName(indexName); indexValueEntity.setItemType(ItemType.ITEM_TYPE_INDEX); return indexValueEntity; }} SideBar实现SideBar绘制 初始化SideBar相关绘制参数 根据索引列表计算SideBar的实际高度，并得到SideBar的最终高度 根据SideBar高度计算其每项的高度 绘制所有的索引值到视图上，并根据选中情况绘制当前选项的圆形背景 关键代码如下：123456789101112131415161718192021222324252627282930313233343536373839@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int height = MeasureSpec.getSize(heightMeasureSpec); if (mValueList.size() &gt; 0) { //计算SideBar的实际高度 mCalViewHeight = (int) (((mValueList.size() - 1) * mTextPaint.getTextSize() + mFocusTextPaint.getTextSize()) + (mValueList.size() + 1) * mTextSpace); } if (mCalViewHeight &gt; height) {//实际高度超过可用高度 mCalViewHeight = height; } super.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(mCalViewHeight, MeasureSpec.EXACTLY));}@Overrideprotected void onDraw(Canvas canvas) { super.onDraw(canvas); if(mValueList.size() == 0) { return; } //计算每项的高度 mItemHeight = ((float) getHeight()) / mValueList.size(); float radius = Math.min(getWidth() / 2, mItemHeight / 2);//选中状态时圆形背景半径 for(int i = 0; i &lt; mValueList.size(); i++) { if(mSelectPosition == i) { //计算文本垂直居中的基准线 float baseline = mItemHeight / 2 + (mFocusTextPaint.getFontMetrics().descent - mFocusTextPaint.getFontMetrics().ascent) / 2 - mFocusTextPaint.getFontMetrics().descent; canvas.drawCircle(getWidth() / 2, mItemHeight / 2 + mItemHeight * i, radius, mFocusTextBgPaint); canvas.drawText(mValueList.get(i), getWidth() / 2, baseline + mItemHeight * i, mFocusTextPaint); } else { float baseline = mItemHeight / 2 + (mTextPaint.getFontMetrics().descent - mTextPaint.getFontMetrics().ascent) / 2 - mTextPaint.getFontMetrics().descent; canvas.drawText(mValueList.get(i), getWidth() / 2, baseline + mItemHeight * i, mTextPaint); } }} 点击SideBar选中SideBar绘制成功后，在使用过程中还有一个重要的场景需要实现，那就是我们点击SideBar的时候要知道我们当前点击的是SideBar中的哪个选项，具体实现思路是这样的：根据当前触摸的y坐标(其实是相对于视图坐标系)和每个选项的高度计算当前触摸点在哪个选项内，具体实现代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic boolean onTouch(View v, MotionEvent event) { int touchPosition = getPositionForPointY(event.getY()); if(touchPosition &lt; 0 || touchPosition &gt;= mValueList.size()) { return true; } if(mOnSideBarTouchListener != null) { //此接口监听主要用于列表跳转到对应的组 mOnSideBarTouchListener.onSideBarTouch(v, event, touchPosition); } switch (event.getAction()) { case MotionEvent.ACTION_DOWN: case MotionEvent.ACTION_MOVE: if(touchPosition != mSelectPosition) { setSelectPosition(touchPosition);//设置选中 } break; } return true;}/** * 根据点击的y坐标计算得到当前选中的是哪个选项 * @param pointY * @return 没选中则返回-1 */private int getPositionForPointY(float pointY) { if(mValueList.size() &lt;= 0) { return -1; } //根据手按下的纵坐标与每个选项的高度计算当前所在项的索引 int position = (int) (pointY / mItemHeight); if(position &lt; 0) { position = 0; } else if(position &gt; mValueList.size() - 1) { position = mValueList.size() - 1; } return position;} 点击SideBar某项时跳转列表到对应组1234567891011121314151617@Overridepublic void onSideBarTouch(View v, MotionEvent event, int touchPosition) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: case MotionEvent.ACTION_MOVE: if(touchPosition != mSideBar.getSelectPosition()) { if(touchPosition == 0) { mLinearLayoutManager.scrollToPosition(0); } else { int recyclerViewPosition = getScrollPositionBySideBarSelectPosition(touchPosition); mLinearLayoutManager.scrollToPositionWithOffset(recyclerViewPosition, 0); } } break; }} 固定头部视图处理头部显示逻辑 因为固定不动的头部视图(暂且叫做mStickyHeaderView其视图实现与组名称视图完全一样)是在RecyclerView的上面，所以当其显示时会遮盖掉RecyclerView的第一个可见项。——这个点很重要 获取RecyclerView的第一个可见项的实体数据IndexStickyEntity 如果当前数据的组名称为空，则不显示头部视图mStickyHeaderView，要注意的是前面我在转换数据的时候会给所有普通联系人实体对象都会设置组名称(如果存在) 如果当前数据的组名称不为空，则显示头部视图mStickyHeaderView并同时更新其显示内容 滚动过程中获取RecyclerView列表中的第二个可见项的实体数据IndexStickyEntity，比如叫做：secondVisibleEntity 如果secondVisibleEntity.getItemType() == ItemType.ITEM_TYPE_INDEX,即为组名称视图(索引视图)，此时说明第二组数据已经滚动上来了，需要将固定在头部的mStickyHeaderView视图随着滚动操作慢慢的滑出界面变成不可见，同时secondVisibleEntity则会慢慢滚动到mStickyHeaderView原来所在的位置，此时在界面上看着就像是第二组的组名称视图慢慢的替换了固定在顶部的mStickyHeaderView 如果secondVisibleEntity.getItemType() != ItemType.ITEM_TYPE_INDEX则需要将mStickyHeaderView恢复到初始位置。因为当secondVisibleEntity滚动到mStickyHeaderView原来所在的位置后，此时第一个可见项变成了secondVisibleEntity，而此时的第二个可见项则变成了普通的联系人视图比如叫mContactView，而此时列表还会继续往上滚动，随着滚动secondVisibleEntity会慢慢的变成不可见，而mStickyHeaderView已经滑出界面不可见了，所以当secondVisibleEntity.getItemType() != ItemType.ITEM_TYPE_INDEX则需要将mStickyHeaderView恢复到初始位置显示新的组名称。 列表滚动过程中还需要根据第一个可见项的索引值更新索引条SideBar的选中项 滚动时头部显示逻辑实现12345678910111213141516171819202122232425262728293031323334353637383940class RecyclerViewScrollListener extends RecyclerView.OnScrollListener { @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) { super.onScrolled(recyclerView, dx, dy); int firstVisiblePosition = mLinearLayoutManager.findFirstVisibleItemPosition(); if(firstVisiblePosition &lt; 0 || firstVisiblePosition &gt;= mAdapter.getItemCount()) { return; } IndexStickyEntity entity = mAdapter.getItem(firstVisiblePosition); mSideBar.setSelectPosition(mSideBar.getPosition(entity.getIndexValue())); if(TextUtils.isEmpty(entity.getIndexName()) &amp;&amp; mStickyHeaderView.itemView.getVisibility() == VISIBLE) { //如果当前第一个可见项的索引值为空，则当前项可能是普通视图，非索引视图，因此此时需要将mStickyHeaderView进行隐藏 mStickyIndexValue = null; mStickyHeaderView.itemView.setVisibility(INVISIBLE); } else {//第一个可见项为索引视图，则需要显示头部固定的索引提示视图 showStickyHeaderView(entity.getIndexName(), firstVisiblePosition); } if(firstVisiblePosition + 1 &gt;= mAdapter.getItemCount()) { return; } //获取第二个可见项实体对象 IndexStickyEntity secondVisibleEntity = mAdapter.getItem(firstVisiblePosition + 1); if(secondVisibleEntity.getItemType() == ItemType.ITEM_TYPE_INDEX) { //第二个可见项是索引值视图 View secondVisibleItemView = mLinearLayoutManager.findViewByPosition(firstVisiblePosition + 1); if(secondVisibleItemView.getTop() &lt;= mStickyHeaderView.itemView.getHeight() &amp;&amp; mStickyIndexValue != null) { //当secondVisibleItemView距顶部的距离 &lt;= mStickyHeaderView的高度时，mStickyHeaderView开始往上滑出 mStickyHeaderView.itemView.setTranslationY(secondVisibleItemView.getTop() - mStickyHeaderView.itemView.getHeight()); } } else { //第二个可见项不是索引值视图 if(mStickyHeaderView.itemView.getTranslationY() != 0) {//有偏移 mStickyHeaderView.itemView.setTranslationY(0); } } }} 以上是我在模仿微信通讯录实现过程中的实现思路和关键点代码，具体实现细节和使用方式请看码：https://github.com/huyongli/IndexStickyView 喜欢的同学欢迎Star和fork write by laohu2016年12月30日 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Imitate-WeiXin-contact-view.html"},{"title":"RecyclerView绘制原理","text":"RecyclerView基本使用12345678910//首先设置RecyclerView的布局管理模式mRecyclerView.setLayoutManager(new LinearLayoutManager(this));mAdapter = new MyAdapter(getData());//设置Item项的UI装饰器mRecyclerView.addItemDecoration(new RecyclerItemDecoration(LinearLayoutManager.VERTICAL));//设置Item项的不同操作的动画mRecyclerView.setItemAnimator(new DefaultItemAnimator());//设置数据开始装配mRecyclerView.setAdapter(mAdapter);RecyclerView原理分析 Adapter数据适配RecyclerView.Adapter类中有一个很重要的属性：123//Adapter中被观察对象Observale&lt;AdapterDataObserver&gt;private final AdapterDataObservable mObservable = new AdapterDataObservable(); RecyclerView中也有一个很重要的属性12//数据观察者, AdapterDataObserver实例private final RecyclerViewDataObserver mObserver = new RecyclerViewDataObserver(); 当使用recyclerView.setAdapter(data)设置数据时，会调用以下方法使得RecyclerView成为Adapter的观察者(间接)：1234567891011private void setAdapterInternal(Adapter adapter, boolean compatibleWithPrevious, boolean removeAndRecycleViews) { ...... if (adapter != null) { //通过此处添加观察者，此时RecyclerView就会对Adapter中的数据进行观察监听 adapter.registerAdapterDataObserver(mObserver); ...... } ......} 通常当我们改变Adapter中的数据源时，一般都会通过调用Adapter.notifyDataSetChanged()方法来刷新列表，我们来看看这个方法的实现，看看Adapter是如何通过这个方法来刷新列表的：123public final void notifyDataSetChanged() { mObservable.notifyChanged();} 我们接着看AdapterDataObservable.notifyChanged()方法实现：123456//mObservers是Observable中的属性，是一个ArrayList&lt;T&gt;public void notifyChanged() { for (int i = mObservers.size() - 1; i &gt;= 0; i--) { mObservers.get(i).onChanged(); }} 我们再来看RecyclerViewDataObserver.onChanged()方法：12345678@Overridepublic void onChanged() { ...... //Adapter目前没有待更新的数据 if (!mAdapterHelper.hasPendingUpdates()) { requestLayout(); }} 看到requestLayout()这个方法，我们就明白了，调用此方法后系统会重新measure, layout, draw，这样列表视图就会被更新。 RecyclerView.onMeasure()我们来看看RecyclerView的测量方法onMeasure：123456789101112131415161718192021222324@Overrideprotected void onMeasure(int widthSpec, int heightSpec) { ...... if (mLayout.mAutoMeasure) { final int widthMode = MeasureSpec.getMode(widthSpec); final int heightMode = MeasureSpec.getMode(heightSpec); final boolean skipMeasure = widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY; //委托给LayoutManager来进行测量 mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); if (skipMeasure || mAdapter == null) { return; } if (mState.mLayoutStep == State.STEP_START) { dispatchLayoutStep1(); } mLayout.setMeasureSpecs(widthSpec, heightSpec); mState.mIsMeasuring = true; dispatchLayoutStep2(); mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); ...... } } ......} 上面onMeasure方法中mLayout变量就是我们上面设置的LinearLayoutManager实例，而LinearLayoutManager的构造函数中给变量mAutoMeasure值设置为true，因此测量时就会执行上面的代码，通过上面的方法我们可以看到此处测量分为两种： 当RecyclerView的宽高设置为match_parent或具体值的时候，skipMeasure=true，此时会只需要测量其自身的宽高就可以知道RecyclerView的大小，这时是onMeasure方法测量结束。当RecyclerView的宽高设置为wrap_content时，skipMeasure=false，onMeasure会继续执行下面的dispatchLayoutStep2()，其实就是测量RecyclerView的子视图的大小最终确定RecyclerView的实际大小，这种情况真正的测量操作都是在方法dispatchLayoutStep2()里执行的:12345678private void dispatchLayoutStep2() { ...... mState.mItemCount = mAdapter.getItemCount(); // Step 2: Run layout mState.mInPreLayout = false; mLayout.onLayoutChildren(mRecycler, mState); ......} 从这里也可以看出RecyclerView真正的测量是委托给LayoutManager在处理，我们看看LinearLayoutManager的onLayoutChildren方法：12345678910111213141516@Overridepublic void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) { ...... if (mAnchorInfo.mLayoutFromEnd) { ... fill(recycler, mLayoutState, state, false); ...... } else { ...... fill(recycler, mLayoutState, state, false); ...... } ...... layoutForPredictiveAnimations(recycler, state, startOffset, endOffset); ......} 很明显可以看到，最终执行了fill()方法：12345678910int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, boolean stopOnFocusable) { ...... LayoutChunkResult layoutChunkResult = new LayoutChunkResult(); while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) { layoutChunkResult.resetInternal(); layoutChunk(recycler, state, layoutState, layoutChunkResult); ...... } ......} 上面的while判断条件中remainingSpace可以理解为当前列表中是否还有多余的位置可用于添加绘制child，而layoutState.hasMore(state)则是判断当前绘制的child索引位置是否在Adapter数据范围内123boolean hasMore(RecyclerView.State state) { return mCurrentPosition &gt;= 0 &amp;&amp; mCurrentPosition &lt; state.getItemCount();} 再来看上面的layoutChunk()方法：1234567891011121314151617181920212223242526void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutState layoutState, LayoutChunkResult result) { View view = layoutState.next(recycler); ...... LayoutParams params = (LayoutParams) view.getLayoutParams(); if (layoutState.mScrapList == null) { if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) { addView(view); } else { addView(view, 0); } } else { if (mShouldReverseLayout == (layoutState.mLayoutDirection == LayoutState.LAYOUT_START)) { addDisappearingView(view); } else { addDisappearingView(view, 0); } } measureChildWithMargins(view, 0, 0); ...... // To calculate correct layout position, we subtract margins. layoutDecorated(view, left + params.leftMargin, top + params.topMargin, right - params.rightMargin, bottom - params.bottomMargin); ......} 上面的方法中addView与addDisappearingView最终都是调用的RecyclerView的addView方法，也就是将子child添加到RecyclerView中。 我们再来看看View view = layoutState.next(recycler);这行代码的实现：1234567891011View next(RecyclerView.Recycler recycler) { if (mScrapList != null) { return nextViewFromScrapList(); } final View view = recycler.getViewForPosition(mCurrentPosition); //获取某个位置需要展示的View mCurrentPosition += mItemDirection; //将当前绘制的child的索引下移一位，配合while循环 return view;} 我们看看上面的获取position位置的view是如何获取的：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758View getViewForPosition(int position, boolean dryRun) { ...... ViewHolder holder = null; // 0) If there is a changed scrap, try to find from there if (mState.isPreLayout()) { holder = getChangedScrapViewForPosition(position); fromScrap = holder != null; } // 1) Find from scrap by position if (holder == null) { holder = getScrapViewForPosition(position, INVALID_TYPE, dryRun); ...... } if (holder == null) { final int offsetPosition = mAdapterHelper.findPositionOffset(position); ...... final int type = mAdapter.getItemViewType(offsetPosition); // 2) Find from scrap via stable ids, if exists if (mAdapter.hasStableIds()) { holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun); ...... } //mViewCacheExtension的缓存是由开发者自己实现来控制ViewHolder的缓存策略 if (holder == null &amp;&amp; mViewCacheExtension != null) { // We are NOT sending the offsetPosition because LayoutManager does not // know it. final View view = mViewCacheExtension.getViewForPositionAndType(this, position, type); if (view != null) { holder = getChildViewHolder(view); ...... } } if (holder == null) { // fallback to recycler ...... holder = getRecycledViewPool().getRecycledView(type); ...... } if (holder == null) { holder = mAdapter.createViewHolder(RecyclerView.this, type); ...... } } ...... boolean bound = false; if (mState.isPreLayout() &amp;&amp; holder.isBound()) { // do not update unless we absolutely have to. holder.mPreLayoutPosition = position; } else if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) { ...... holder.mOwnerRecyclerView = RecyclerView.this; //此处就是调用Adapter中bindViewHolder方法 mAdapter.bindViewHolder(holder, offsetPosition); ...... } ...... return holder.itemView;} 将指定位置的View获取得到之后添加到RecyclerView中，紧接着再来看后面执行的measureChildWithMargins方法：12345678910111213public void measureChildWithMargins(View child, int widthUsed, int heightUsed) { final LayoutParams lp = (LayoutParams) child.getLayoutParams(); //通过ItemDecorate获取offset final Rect insets = mRecyclerView.getItemDecorInsetsForChild(child); widthUsed += insets.left + insets.right; heightUsed += insets.top + insets.bottom; final int widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(), getPaddingLeft() + getPaddingRight() + lp.leftMargin + lp.rightMargin + widthUsed, lp.width, canScrollHorizontally()); final int heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(), getPaddingTop() + getPaddingBottom() + lp.topMargin + lp.bottomMargin + heightUsed, lp.height, canScrollVertically()); if (shouldMeasureChild(child, widthSpec, heightSpec, lp)) { child.measure(widthSpec, heightSpec); }} 该方法中调用mRecyclerView.getItemDecorInsetsForChild(child);获取child的offset，然后对child重新测量绘制：1234567891011121314Rect getItemDecorInsetsForChild(View child) { ...... final int decorCount = mItemDecorations.size(); for (int i = 0; i &lt; decorCount; i++) { mTempRect.set(0, 0, 0, 0); mItemDecorations.get(i).getItemOffsets(mTempRect, child, this, mState); insets.left += mTempRect.left; insets.top += mTempRect.top; insets.right += mTempRect.right; insets.bottom += mTempRect.bottom; } lp.mInsetsDirty = false; return insets;} 这个里面的mItemDecorations就是文章开头例子中我通过mRecyclerView.addItemDecoration(new RecyclerItemDecoration(LinearLayoutManager.VERTICAL));添加的Item装饰器1234public void layoutDecorated(View child, int left, int top, int right, int bottom) { final Rect insets = ((LayoutParams) child.getLayoutParams()).mDecorInsets; child.layout(left + insets.left, top + insets.top, right - insets.right, bottom - insets.bottom);} 可以看到layoutDecorated方法中直接调用了View的layout方法对child视图进行layout布局。 到此RecyclerView列表中Item项视图的measure和layout实际上已经完成。 RecyclerView.onLayout看完onMeasure方法，再来看看onLayout方法：123456789101112131415161718192021222324 @Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) { TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG); dispatchLayout(); TraceCompat.endSection(); mFirstLayoutComplete = true;}void dispatchLayout() { ...... mState.mIsMeasuring = false; if (mState.mLayoutStep == State.STEP_START) { ...... dispatchLayoutStep2(); } else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() || mLayout.getHeight() != getHeight()) { ...... dispatchLayoutStep2(); } else { // always make sure we sync them (to ensure mode is exact) mLayout.setExactMeasureSpecsFrom(this); } dispatchLayoutStep3();} 通过dispatchLayout方法可以看到onLayout中又执行了我们前面分析过的dispatchLayoutStep2()方法，在最后又执行了一个dispatchLayoutStep3()方法，我们再来看看这个：12345678910111213141516171819202122232425262728293031323334private void dispatchLayoutStep3() { ...... if (mState.mRunSimpleAnimations) { for (int i = mChildHelper.getChildCount() - 1; i &gt;= 0; i--) { ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i)); ...... final ItemHolderInfo animationInfo = mItemAnimator .recordPostLayoutInformation(mState, holder); ...... if (oldChangeViewHolder != null &amp;&amp; !oldChangeViewHolder.shouldIgnore()) { ...... if (oldDisappearing &amp;&amp; oldChangeViewHolder == holder) { //此处会执行动画 // run disappear animation instead of change mViewInfoStore.addToPostLayout(holder, animationInfo); } else { ...... if (preInfo == null) { handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder); } else { //此方法最终调用DefaultItemAnimate的相关动画 animateChange(oldChangeViewHolder, holder, preInfo, postInfo, oldDisappearing, newDisappearing); } } } else { mViewInfoStore.addToPostLayout(holder, animationInfo); } } // Step 4: Process view info lists and trigger animations mViewInfoStore.process(mViewInfoProcessCallback); } ......} 上面的方法中调用了ItemAnimation动画类的相关方法 RecyclerView.onDraw123456789 @Overridepublic void onDraw(Canvas c) { super.onDraw(c); final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) { mItemDecorations.get(i).onDraw(c, this, mState); }} 可以看到ItemDecoration的onDraw方法是在此处调用12345678910@Overridepublic void draw(Canvas c) { super.draw(c); final int count = mItemDecorations.size(); for (int i = 0; i &lt; count; i++) { mItemDecorations.get(i).onDrawOver(c, this, mState); } ......} 这个地方可以看到ItemDecoration的onDrawOver方法是在此处调用 到这里，RecyclerView使用过程中比较常用的几个类(LayoutManager, ItemDecoration, ItemAnimation)的主要作用及使用场景有了个大概的了解。 在RecyclerView中是没有为我们内置Item的单击和长按事件监听接口的，一般为Item设置单击和长按监听都是是直接在Adapter初始化Item视图时，为我们的Item视图直接设置单击监听和长按监听，这种方式与Adapter的耦合度比较高，而且频繁的为view设置监听对象，感觉不太好。其实RecyclerView中为我们提供了一个类OnItemTouchListener通过这个类再结合手势GestureDetector完全可以实现一个耦合度更低复用度更高的单击和长按监听。我们再来看看OnItemTouchListener的实现方式：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@Overridepublic boolean onTouchEvent(MotionEvent e) { ...... if (dispatchOnItemTouch(e)) { cancelTouch(); return true; } ......}private boolean dispatchOnItemTouch(MotionEvent e) { final int action = e.getAction(); if (mActiveOnItemTouchListener != null) { if (action == MotionEvent.ACTION_DOWN) { // Stale state from a previous gesture, we're starting a new one. Clear it. mActiveOnItemTouchListener = null; } else { //此处即调用OnItemTouchListener的方法 mActiveOnItemTouchListener.onTouchEvent(this, e); if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) { // Clean up for the next gesture. mActiveOnItemTouchListener = null; } return true; } } // Listeners will have already received the ACTION_DOWN via dispatchOnItemTouchIntercept // as called from onInterceptTouchEvent; skip it. if (action != MotionEvent.ACTION_DOWN) { final int listenerCount = mOnItemTouchListeners.size(); for (int i = 0; i &lt; listenerCount; i++) { final OnItemTouchListener listener = mOnItemTouchListeners.get(i); //此处即调用OnItemTouchListener的方法 if (listener.onInterceptTouchEvent(this, e)) { mActiveOnItemTouchListener = listener; return true; } } } return false;}@Overridepublic boolean onInterceptTouchEvent(MotionEvent e) { ...... if (dispatchOnItemTouchIntercept(e)) { cancelTouch(); return true; } ......}private boolean dispatchOnItemTouchIntercept(MotionEvent e) { final int action = e.getAction(); if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_DOWN) { mActiveOnItemTouchListener = null; } final int listenerCount = mOnItemTouchListeners.size(); for (int i = 0; i &lt; listenerCount; i++) { final OnItemTouchListener listener = mOnItemTouchListeners.get(i); if (listener.onInterceptTouchEvent(this, e) &amp;&amp; action != MotionEvent.ACTION_CANCEL) { mActiveOnItemTouchListener = listener; return true; } } return false;} 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/RecyclerView绘制原理.html"},{"title":"透过Retrofit使用看其源码设计模式","text":"前言这篇文章我将从Retrofit的基本用法出发，透过其使用步骤，一步步的探究Retrofit的实现原理及其源码的设计模式。这篇文章可能会将Retrofit中用到的设计模式和其实现原理穿插着写，所以各位同学也可以选择性的阅读。而对于Retrofit具体使用还不太清楚的同学可以去看的另一篇文章Retrofit2的使用介绍 Retrofit基本用法我以用户登录作为示例： 声明接口首先我们先定义一个登录服务接口LoginService，如下：12345public interface LoginService { @FormUrlEncoded @POST(\"login\") Call&lt;String&gt; login(@Field(\"username\") String name, @Field(\"password\") String password);} 创建Retrofit对象1234Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://ittiger.cn\") .addConverterFactory(GsonConverterFactory.create()) .build(); 发起请求123LoginService service = retrofit.create(LoginService.class);Call&lt;User&gt; call = service.login(\"user\", \"pwd\");call.execute()或call.enqueue() Retrofit关键类在讲Retrofit实现原理之前，我先说下Retrofit里面涉及到几个关键类都是干什么用的 Retorift： 负责配置请求过程中的基本参数，如：请求地址，结果转换器，自定义OKHttpClient等，同时还会生成请求接口对象 Call： 网络请求执行者(Retrofit.Call)，比如：上面示例中最后调用login方法得到的Call对象就是此接口的实例 OkHttpCall： 此类是Retrofit.Call接口的实现，示例中最后调用login方法得到的Call对象就是此类的实例。但是其底层网络请求执行都是通过OkHttp.Call接口间接执行的，也就是说OkHttpCall是对OkHttp.Call网络请求功能的封装。 Converter &amp; Converter.Factory： 分别负责网络请求结果转换以及生成Converter转换器 CallAdapter &amp; CallAdapter.Factory： 分别负责对Retrofit.Call实例(OkHttpCall)进行适配及生成CallAdapter适配器 Platform： 确定Retrofit当前运行平台，以及确定当前平台默认的的CallAdapter.Factory和Executor ExecutorCallAdapterFactory： Android平台下的默认CallAdapter.Factory实现 ServiceMethod： 解析接口服务所有注解、生成请求对象Request、解析请求结果Response ParameterHandler： 服务接口方法(login())参数解析处理器，配合ServiceMethod进行服务接口参数注解解析 RequestBuilder： 根据参数和URL构造请求需要的OkHttp.Request对象 以上就是Retrofit源码实现中比较关键的10个类及其相关作用 使用流程 &gt;&gt; 实现 &gt;&gt; 设计模式Builder模式创建RetrofitRetrofit场景1234Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"http://ittiger.cn\") .addConverterFactory(GsonConverterFactory.create()) .build(); 上面代码的对象创建方式看着是不是似曾相识，看着很眼熟，没错，Android里面的Dialog的创建就是使用的这种方式：Builder模式 Builder模式定义将一个复杂对象的构建与它的表示分离，使得同样的构建可以创建不同的表示 Builder模式使用场景 相同的方法不同的执行顺序产生不同的结果 多个部件都可以装配到一个对象中，但是产生的结果不同 Builder模式类图 Retrofit中的Builder模式 Retrofit中的Builder模式是简化版的Builder模式，省略了抽象建造者和指挥者 不同的配置会对Retrofit产生不同的影响，如果通过addCallAdapterFactory()配置CallAdapterFactory和不配置CallAdapterFactory会对Retrofit产生完全不同的影响。 如果Retrofit中使用构造方法的方式创建对象，则需要实现多个不同参数的构造方法，而使用构造方法创建对象时如果参数太多，很多时候参数代表的意思是不太理解的，总归来说就是创建过程不直观。 Builder模式优缺点 优点： 不需要知道产品内部的组成细节，产品与创建过程解耦 分步组装产品，使得产品的创建过程更精细更清晰 容易扩展，新产品只需要新建一个建造者即可 缺点： Builder模式创建的产品差异性小，使用范围受限制 不同的产品会产生多个建造者和指挥者 Retrofit创建流程 &gt;&gt; Platform在创建Retrofit过程中有这样一行代码：123Retrofit retrofit = new Retrofit.Builder()....build(); 从代码可以看到在创建Retrofit时得先根据Retrofit.Builder内部类的默认构造方法Retrofit.Builder()创建一个Builder对象，所以我们来看看这个默认构造方法里都做了些什么事：123public Builder() { this(Platform.get());} OK，我们再来看看我们前面说到的Platform这个平台类的静态方法get()1234567891011121314151617181920212223242526272829//静态实例对象，类加载就确定了private static final Platform PLATFORM = findPlatform(); static Platform get() { return PLATFORM; } private static Platform findPlatform() { try { Class.forName(\"android.os.Build\"); if (Build.VERSION.SDK_INT != 0) { return new Android(); } } catch (ClassNotFoundException ignored) { } try { Class.forName(\"java.util.Optional\"); return new Java8(); } catch (ClassNotFoundException ignored) { } try { Class.forName(\"org.robovm.apple.foundation.NSObject\"); return new IOS(); } catch (ClassNotFoundException ignored) { } return new Platform(); } ...} 通过上面的代码我们可以很明确的知道，在Platform类加载的时候它就通过反射的机制确定了当前运行的平台是属于哪一个，是Android，是Java8还是IOS，并生成对应的平台类的实例，get()方法是用来获取当前的平台类的实例。 目前，我们只关注Android平台下的Platform实例，我们也来看看Android平台类中做了些什么：1234567891011121314151617static class Android extends Platform { @Override public Executor defaultCallbackExecutor() { return new MainThreadExecutor(); } @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) { return new ExecutorCallAdapterFactory(callbackExecutor); } static class MainThreadExecutor implements Executor { private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) { handler.post(r); } } } 可以看到Android类中重写了Platform类的两个方法defaultCallbackExecutor()和defaultCallAdapterFactory(Executor callbackExecutor) 前者就是用来返回当前平台下默认的Executor，这Android平台下就是MainThreadExecutor这个类的实例，可以看到这个执行器主要就是用来进行线程切换的，因为我们知道安卓平台下所有的UI操作都必须在UI线程中执行。 后者就是用来返回当前平台下默认的CallAdapter.Factory 当然你也可以不使用这两个默认值，都可以在创建Retrofit过程中自定义配置自己需要的相关实例 Retrofit创建流程 &gt;&gt; ExecutorCallAdapterFactory看完Platform之后紧接着我们再来看看Android平台下默认的CallAdapter.Factory实现ExecutorCallAdapterFactory都做了些什么，这里只贴关键代码：123456789101112131415161718192021222324252627282930public interface CallAdapter&lt;T&gt; { abstract class Factory { public abstract CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit); ... }}final class ExecutorCallAdapterFactory extends CallAdapter.Factory { final Executor callbackExecutor;//对应默认的MainThreadExecutor ExecutorCallAdapterFactory(Executor callbackExecutor) { this.callbackExecutor = callbackExecutor; } @Override public CallAdapter&lt;Call&lt;?&gt;&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) { ... return new CallAdapter&lt;Call&lt;?&gt;&gt;() { @Override public Type responseType() { return responseType; } @Override public &lt;R&gt; Call&lt;R&gt; adapt(Call&lt;R&gt; call) { return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); } }; } ...} 大家看源码可以发现CallAdapter.Factory工厂是通过get()方法来创建CallAdapter的，所以ExecutorCallAdapterFactory关键代码也是在get()方法的实现上，上面的代码中我们可以看到get()方法返回一个CallAdapter实例，这就是我前面介绍关键类作用时说到的CallAdapter.Factory主要负责生成CallAdapter的实现。 该类中，我们从其类的命名以及代码实现结构上来看，ExecutorCallAdapterFactory其实也使用了一种设计模式，那就是工厂方法模式，其实Retrofit中还有一个地方也使用了工厂方法模式，那就是Converter &amp; Converter.Factory它的实现方式和CallAdapter &amp; CallAdapter.Factory是一样样的。 工厂方式模式(创建CallAdapter &amp; Converter)本文我就已CallAdapter进行举例，看懂CallAdapter的创建原理之后，再看Converter的创建也就比较简单，都是一样的道理。 Retrofit场景Retrofit中使用工厂方式模式的场景我在前面讲ExecutorCallAdapterFactory实现的时候已经讲过了，这里就不重复举例了，大家可以对照着源码看下。 工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪个类 工厂方法模式使用场景 不需要知道其具体的类名，只需要知道生成它的工厂 一个类通过其子类来决定创建哪个对象 工厂方法模式类图 Retrofit中的工厂方法 Retrofit中使用工厂方法模式可以讲CallAdapter的创建与具体实现充分解耦，对于创建我们只需要知道其工厂即可，不需要关注是如何实现 所以我们可以通过addCallAdapterFactory()和addConverterFactory()很方便的自定义我们自己所需要的适配器工厂和数据转换工厂 通过addCallAdapterFactory()可以很方便的让Retrofit支持RxJava特性，而通过addConverterFactory()可以自定义配置们想要的转换器，让我们可以将请求数据结果转换成我们想要的任意类型。 这些就是Retrofit使用工厂方法模式带来的好处。 工厂方法模式优缺点 优点 只关注产品工厂即可，不需要关注产品如何创建，由工厂确定如何创建 扩展性好，新增产品时，只需要新增一个具体工厂和具体产品 缺点 新增产品时，需要新增具体工厂和具体产品类，使系统变得庞大 系统中加入抽象层，增加了系统的抽象性和理解难度 适配器模式 &gt;&gt; CallAdapterRetrofit场景先来看看CallAdapter在Retrofit中的使用场景12345678910111213141516public interface CallAdapter&lt;T&gt; { public Type responseType(); public &lt;R&gt; Call&lt;R&gt; adapt(Call&lt;R&gt; call);}//ExecutorCallAdapterFactory中生成CallAdapter实例return new CallAdapter&lt;Call&lt;?&gt;&gt;() { @Override public Type responseType() { return responseType; } @Override public &lt;R&gt; Call&lt;R&gt; adapt(Call&lt;R&gt; call) { return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); } }; 前面讲到ExecutorCallAdapterFactory会生成一个CallAdapter实例。而CallAdapter这个名字看着是不是也很眼熟，也有种似曾相识的感觉，没错，CallAdapter与我们在Android中使用ListView或RecyclerView时经常用到的各种Adapter一样也是一个适配器。 那CallAdapter是来适配什么的呢？ 还记得前面介绍关键类的时候说到的OkHttpCall吗？CallAdapter就是来适配OkHttpCall实例的，结合上面的代码来说的话在调用CallAdapter.adapt方法时OkHttpCall实例会作为参数传递给adapt方法从而交给CallAdapter去进行适配。 在我前面举的登录示例中，我们调用login()方法得到的Call实例就是CallAdapter适配OkHttpCall之后得到的一个新Call实例对象，至于为什么是这样，我后面会一一讲解，各位看官不要离开 所以Retrofit在这个地方又使用了一种设计模式：适配器模式 适配器模式定义将一个类的接口变成客户端所需要的另一个接口，从而使原本因接口不匹配而无法一起工作的两个类可以在一起工作 适配器模式使用场景 需要复用现有类，而现有类不符合系统需求 需要一个统一的输出接口，而输入端类型不可预知 适配器模式类图 Retrofit中的适配器模式12345678910//ExecutorCallAdapterFactory中生成CallAdapter实例return new CallAdapter&lt;Call&lt;?&gt;&gt;() { @Override public Type responseType() { return responseType; } @Override public &lt;R&gt; Call&lt;R&gt; adapt(Call&lt;R&gt; call) { return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); } }; Android平台下默认的CallAdapter会将OkHttpCall 和 MainThreadExecutor两个实例对象适配成一个新的Call实例，这个新的Call实例在执行过程中就具备了切换到UI线程的功能。 那Retrofit在这个地方为什么要使用适配器模式将OkHttpCall进行适配了，直接拿过来用不就可以了吗？ 前面讲过OkHttpCall仅仅只是对OkHttp.Call执行网络请求操作的封装，没有其他功能，也就是说OkHttpCall也只有网络请求的功能，而Retrofit是支持多个平台的（安卓，Java8，IOS，甚至包括支持RxJava特性），而不同的平台可能具有不同的特性。 如果在请求过程中需要用到这些特性的话，那么单靠OkHttp.Call是无法完成的，而如果在其他地方柔和进这些特性的支持可能就会使得框架结构不那么严谨平台解耦性比较差，甚至有可能会增加更多的接口。 Retrofit通过使用适配器模式将平台特性与OkHttpCall适配成一个最终我们需要的Call实例，这样的话我们在使用过程中只需要关注最后拿到的Call对象，而不需要关注底层这个Call实例到底是什么样的，这也就为我们支持更多的特性提供了可能。比如对RxJava特性的支持，我们只需要提供一个支持RxJava特性的CallAdapter适配器即可，所以我们就可以通过addCallAdapterFactory()配置我们提供的支持RxJava特性的CallAdapter.Factory 适配器模式优缺点 优点 复用性好，引入适配器类来重用适配者类，无需修改原有代码 增加类的透明性，将适配过程封装在适配器类中，对使用者来说相对透明 灵活性扩展性好，通过配置可以随时更换适配器 缺点 使用适配器会使系统整体不好把握，调的是A接口，却被适配成了B接口的实现 静态代理模式 &gt;&gt; ExecutorCallbackCallRetrofit场景还是先来看看Retrofit中使用ExecutorCallbackCall的场景1234567//ExecutorCallAdapterFactory中生成CallAdapter实例return new CallAdapter&lt;Call&lt;?&gt;&gt;() { ... @Override public &lt;R&gt; Call&lt;R&gt; adapt(Call&lt;R&gt; call) { return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); } }; 在上面CallAdapter实现中，可以发现它将OkHttpCall适配成了一个新的Call实例：ExecutorCallbackCall，所以我们接着看看ExecutorCallbackCall的具体实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; { final Executor callbackExecutor;//Android平台下的Executor：MainThreadExecutor final Call&lt;T&gt; delegate;//网络实际执行者OkHttpCall实例 ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) { this.callbackExecutor = callbackExecutor; this.delegate = delegate; } @Override public void enqueue(final Callback&lt;T&gt; callback) { if (callback == null) throw new NullPointerException(\"callback == null\"); delegate.enqueue(new Callback&lt;T&gt;() { @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) { //Android平台下此处进行了线程切换 callbackExecutor.execute(new Runnable() { @Override public void run() { if (delegate.isCanceled()) { callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\")); } else { callback.onResponse(ExecutorCallbackCall.this, response); } } }); } @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) { //Android平台下此处进行了线程切换 callbackExecutor.execute(new Runnable() { @Override public void run() { callback.onFailure(ExecutorCallbackCall.this, t); } }); } }); } @Override public boolean isExecuted() { return delegate.isExecuted(); } @Override public Response&lt;T&gt; execute() throws IOException { return delegate.execute(); } @Override public void cancel() { delegate.cancel(); } @Override public boolean isCanceled() { return delegate.isCanceled(); } @SuppressWarnings(\"CloneDoesntCallSuperClone\") // Performing deep clone. @Override public Call&lt;T&gt; clone() { return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone()); } @Override public Request request() { return delegate.request(); } }} 可以看到我们通过login()方法拿到Call实例(也就是ExecutorCallbackCall)之后，在执行网络请求时，在ExecutorCallbackCall的实现中其实都是将具体操作委托给OkHttpCall在执行。所以Retrofit在ExecutorCallbackCall中又使用了一种设计模式：静态代理模式 静态代理模式定义为其他对象提供一种代理以控制对这个对象的访问 静态代理模式使用场景无法访问或不想直接访问某个对象 静态代理模式类图 Retrofit中的静态代理Retrofit中使用ExecutorCallbackCall代理OkHttpCall具体请求操作，可以将Call的使用与底层实现进行解耦，不用关心底层具体请求接口的实现，所以如果将来出现了一个比OkHttp更好的网络请求库，我们完全可以将OkHttp替换掉，即便这样也不会影响外部API接口在项目中的使用。 静态代理的优缺点 优点 协调调用者与被调用者，降低系统耦合度 减小外部接口与内部接口实现的关联，降低耦合 缺点 委托对象与代理对象需要实现相同的接口，当接口类增加方法时，除了所有实现类需要增加该方法外，所有代理类也需要实现此方法，增加了维护难度 一个代理类只能代理一种类型的对象 动态代理 &gt;&gt; Retrofit.create()先看下Retrofit.create()方法的具体实现代码：1234567891011121314public &lt;T&gt; T create(final Class&lt;T&gt; service) { return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] { service }, new InvocationHandler() { private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable { ... ServiceMethod serviceMethod = loadServiceMethod(method); OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); } });} 相信很多人在刚开始用Retrofit时都会有一点疑问，我们明明声明的是接口，为什么通过create()方法就能创建出一个对象实例呢？通过上面的实现源码我们找到了答案，那就是使用了JDK中提供的动态代理机制，它会在运行过程中为我们声明的服务接口动态的创建出一个代理对象，以便实现我们的请求操作。我个人认为这是Retrofit框架得以实现的一个核心之处，另外一个核心之处就是其完善的注解机制，关于其注解本文就不说，主要就是一些注解的声明和解析，比较简单，感兴趣的可以去看看。 上面的源码中我们可以看到，运行过程中得到服务接口的代理对象之后，当我们调用login()这样的接口方法时，其实真实执行的是上面源码中写的invoke()方法，所以我们调用login()方法时其实是执行了如下三步： 根据反射得到接口方法Method对象生成对应的ServiceMethod对象，该对象会对该声明方法上的所有方法注解、参数注解进行解析以得到一个请求所需要的所有信息 得到ServiceMethod对象之后，会根据该对象和方法调用时传递的参数生成OkHttpCall对象，也就是具体的网络实施者 将OkHttpCall作为CallAdapter适配器中adapt()方法的参数传递给CallAdapter进行适配，最后得到我们所需要的ExecutorCallbackCall对象，也就是调用login()方法得到的Call实例对象 动态代理使用场景静态代理特点一个代理对应一种类型，如果有多个类需要代理则需要多个代理，而且维护成本高，而动态代理就是来解决此类问题 动态代理特点运行期由JVM通过反射机制动态生成，可以代理多种类型，代码复用性高。但是只能代理Java接口，不能代理Java实现类。 Call.enqueue() &amp; Call.execute()实现前面从Retrofit的配置、创建、调用接口方法得到Call实例，基本用法都已经讲的差不多了，现在我们来看基本用法的最后一步Call.enqueue() &amp; Call.execute() 前面讲过调用接口方法比如login()时，Android平台下默认得到的是ExecutorCallbackCall实例，而ExecutorCallbackCall实例中执行网络请求的实际上又是OkHttpCall，所以我们来看OkHttpCall中的Call.enqueue() &amp; Call.execute()两个方法的实现，我以Call.enqueue()为例，另外一个大家可以自己去看看 下面是该方法实现的关键代码： OkHttpCall.enqueue()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Override public void enqueue(final Callback&lt;T&gt; callback) { ... okhttp3.Call call; Throwable failure; synchronized (this) { if (executed) throw new IllegalStateException(\"Already executed.\"); executed = true; call = rawCall; failure = creationFailure; if (call == null &amp;&amp; failure == null) { try { //如果okhttp3.Call为空，则先创建该实例 call = rawCall = createRawCall(); } catch (Throwable t) { failure = creationFailure = t; } } } ... //又讲网络执行转交给okhttp3.Call实例来执行 call.enqueue(new okhttp3.Callback() { @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) throws IOException { Response&lt;T&gt; response; try { //将okhttp3.Response结果包装成Retrofit中的结果对象Response response = parseResponse(rawResponse); } catch (Throwable e) { callFailure(e); return; } callSuccess(response); } @Override public void onFailure(okhttp3.Call call, IOException e) { ... } private void callFailure(Throwable e) { ... } private void callSuccess(Response&lt;T&gt; response) { ... } }); } 前面介绍关键类时说过OkHttpCall底层网络执行其实是OkHttp.Call在执行，从上面的代码我们就可以看出来(代码关键地方我加了注释)，上面代码关键第一步是先创建一个okhttp3.call实例，所以我们同样看看创建okhttp3.call实例的代码是怎么实现的123456private okhttp3.Call createRawCall() throws IOException { Request request = serviceMethod.toRequest(args); okhttp3.Call call = serviceMethod.callFactory.newCall(request); ... return call; } 通过上面的createRawCall()方法实现我们可以发现，它会首先通过ServiceMethod.toRequest()方法生成一个OkHttp.Request对象(这部分代码比较简单，我就不细说了)，然后根据ServiceMethod中的成员变量CallFactory创建一个okhttp3.Call实例。但是这个CallFactory是怎么来的呢？其实我们可以猜到这个CallFactory实例就是OkHttpClient实例。但是我们还是看看ServiceMethod的创建过程 ServiceMethod创建12345678910111213141516171819202122232425262728293031323334353637383940414243//在Retrofit.create()方法实现的第一步就是通过loadServiceMethod()方法创建ServiceMethod，这是其实现ServiceMethod loadServiceMethod(Method method) { ServiceMethod result; synchronized (serviceMethodCache) { result = serviceMethodCache.get(method); if (result == null) { result = new ServiceMethod.Builder(this, method).build(); serviceMethodCache.put(method, result); } } return result; }//下面是ServiceMethod相关关键代码final class ServiceMethod&lt;T&gt; { final okhttp3.Call.Factory callFactory; ServiceMethod(Builder&lt;T&gt; builder) { this.callFactory = builder.retrofit.callFactory(); this.callAdapter = builder.callAdapter; this.baseUrl = builder.retrofit.baseUrl(); this.responseConverter = builder.responseConverter; ... } static final class Builder { public Builder(Retrofit retrofit, Method method) { this.retrofit = retrofit; this.method = method; ... } public ServiceMethod build() { //创建CallAdapter callAdapter = createCallAdapter(); //得到请求结果返回类型，接口方法声明 responseType = callAdapter.responseType(); ... //创建得到Converter结果转换器 responseConverter = createResponseConverter(); ... return new ServiceMethod&lt;&gt;(this); } }} 通过上面的ServiceMethod创建过程的相关代码可以看出，ServiceMethod中的实例变量callFactory其实是调用Retrofit.callFactory()方法所得，大家也可以看看上面我注释的CallAdapter和Converter的创建过程，所以我们再来看看这个方法的实现123public okhttp3.Call.Factory callFactory() { return callFactory;} 可以看到该方法只是返回了Retrofit中的callFactory实例，同样，我们再来看看Retrofit中的callFactory实例是怎么来的1234567891011121314151617181920212223242526272829303132public final class Retrofit { private final okhttp3.Call.Factory callFactory; ... Retrofit(okhttp3.Call.Factory callFactory, ...) { this.callFactory = callFactory; ... } public static final class Builder { private okhttp3.Call.Factory callFactory; ... public Builder client(OkHttpClient client) { return callFactory(checkNotNull(client, \"client == null\")); } public Builder callFactory(okhttp3.Call.Factory factory) { this.callFactory = checkNotNull(factory, \"factory == null\"); return this; } public Retrofit build() { ... okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) { callFactory = new OkHttpClient(); } ... return new Retrofit(callFactory, ...); } }} 通过上面的代码，我们可以看出Retrofit中的callFactory实例就是我们使用的OkHttpClient实例，所以这就验证了我们前面猜测的serviceMethod.callFactory就是OkHttpClient实例的猜想。 Ok，回到我们前面将的OkHttpCall.equeue()方法的实现流程上来。 请求结果解析123456789101112131415call.enqueue(new okhttp3.Callback() { @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) throws IOException { Response&lt;T&gt; response; try { //将okhttp3.Response结果包装成Retrofit中的结果对象Response response = parseResponse(rawResponse); } catch (Throwable e) { callFailure(e); return; } callSuccess(response); } ...} 创建完okhttp3.call实例之后，调用该实现的equeue()方法开始执行网络请求，请求执行完成之后，会调用parseResponse方法，我们来看看这个方法实现的关键代码：1234567891011121314Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException { ResponseBody rawBody = rawResponse.body(); ... //上面省略的这段代码是对请求失败时的结果处理，大家可以自行查看源码 ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try { T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); } catch (RuntimeException e) { catchingBody.throwIfCaught(); throw e; } } 这个方法中，当请求成功时，会调用serviceMethod.toResponse()这个方法，我们来看看这个方法又做了哪些事情：123T toResponse(ResponseBody body) throws IOException { return responseConverter.convert(body);} 很明显，上面方法中就直接调用了ServiceMethod中的Converter实例进行结果转换，也就是说在这个地方Retrofit会帮我们把网络请求结果转换成我们所需要的类型，转换成功之后会调用Response.success(body, rawResponse)将转换后的结果包装成Retrofit中的Response对象。 获取配置的Converter问题又来了，上面的Converter是怎么来的呢？ 在前面给出的ServiceMethod创建过程的代码块中，我对ServiceMethod中创建Converter实例的代码进行了注释，我们再回过头来看看这段代码：1234567891011121314151617181920212223242526272829//ServiceMethod.Buibler中的方法private Converter&lt;ResponseBody, T&gt; createResponseConverter() { ... try { return retrofit.responseBodyConverter(responseType, annotations); } catch (RuntimeException e) { // Wide exception range because factories are user code. throw methodError(e, \"Unable to create converter for %s\", responseType); } }//Retrofit中的方法public &lt;T&gt; Converter&lt;ResponseBody, T&gt; responseBodyConverter(Type type, Annotation[] annotations) { return nextResponseBodyConverter(null, type, annotations); }public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(Converter.Factory skipPast, Type type, Annotation[] annotations) { ... int start = converterFactories.indexOf(skipPast) + 1; for (int i = start, count = converterFactories.size(); i &lt; count; i++) { Converter&lt;ResponseBody, ?&gt; converter = converterFactories.get(i).responseBodyConverter(type, annotations, this); if (converter != null) { return (Converter&lt;ResponseBody, T&gt;) converter; } } ... throw new IllegalArgumentException(builder.toString()); } 通过上面的代码我们可以看到会从Retrofit的converterFactories转换器工厂集合中去查找当前接口方法对应的转换器工厂。其实这也告诉我们可以在创建Retrofit时配置多个Converter.Factory转换器工厂，也就是说我们一个接口服务中如果声明的多个接口方法的返回值不一样时，我们可以针对性的配置多个不一样的结果转换器工厂去进行结果解析，而不用为了保持结果类型一致对接口进行其他处理。 上面创建ServiceMethod时得到CallAdapter的过程与得到Converter的过程基本一样，我就不赘述了。 到这里，Retrofit的实现原理、实现流程以及其源码实现过程中用到的设计模式就介绍完了。 内容好长，时间好长~~~~ 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Retrofit-Source-Design-Pattern.html"},{"title":"Android资源应用与适配标准","text":"本文内容来自Android官网对Android开发过程中资源使用、资源适配、资源选择原理的介绍和建议。 Android资源类型Android项目结构一个Android项目有多重资源类型，我们一般都会将各种资源放入项目 res/目录的特定子目录下。例如，以下是一个简单项目的文件层次结构： 正如我们在此示例中所看到的那样，res/目录包含所有资源（在子目录下）：一个图像资源、两个布局资源、启动器图标的 mipmap/ 目录以及一个字符串资源文件。资源目录名称非常重要，将在表 1 中进行介绍。 注：如需了解有关使用 mipmap文件夹的详细信息，请参阅管理项目概览。 Android支持的资源类型表 1. 项目 res/ 目录内支持的资源目录。 目录 资源类型 animator/ 用于定义属性动画的 XML文件。 anim/ 定义渐变动画的 XML 文件。（属性动画也可以保存在此目录中，但是为了区分这两种类型，属性动画首选 animator/ 目录。） color/ 用于定义颜色状态列表的 XML 文件。请参阅颜色状态列表资源 drawable/ 位图文件（.png、.9.png、.jpg、.gif）或编译为以下可绘制对象资源子类型的 XML 文件：位图文件九宫格（9-Patch）状态列表形状动画可绘制对象其他可绘制对象请参阅可绘制对象资源 mipmap/ 适用于不同启动器图标密度的可绘制对象文件。如需了解有关使用 mipmap/ 文件夹管理启动器图标的详细信息，请参阅管理项目概览。 layout/ 用于定义用户界面布局的 XML 文件。请参阅布局资源 menu/ 用于定义应用菜单（如选项菜单、上下文菜单或子菜单）的 XML文件。请参阅菜单资源。 raw/ 要以原始形式保存的任意文件。要使用原始InputStream打开这些资源，请使用资源 ID（即 R.raw.&lt;em&gt;filename&lt;/em&gt;）调用 Resources.openRawResource())但是，如需访问原始文件名和文件层次结构，则可以考虑将某些资源保存在assets/ 目录下（而不是 res/raw/）。assets/ 中的文件没有资源 ID，因此您只能使用 AssetManager 读取这些文件。 values/ 包含字符串、整型数和颜色等简单值的 XML 文件。其他 res/ 子目录中的 XML资源文件是根据XML文件名定义单个资源，而 values/ 目录中的文件可描述多个资源。对于此目录中的文件，&lt;resources&gt; 元素的每个子元素均定义一个资源。例如，&lt;string&gt; 元素创建R.string 资源，&lt;color&gt; 元素创建 R.color资源。由于每个资源均用其自己的 XML元素定义，因此您可以根据自己的需要命名文件，并将不同的资源类型放在一个文件中。但是，为了清晰起见，您可能需要将独特的资源类型放在不同的文件中。例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定：arrays.xml，用于资源数组（类型化数组）。colors.xml：颜色值。dimens.xml：尺寸值。strings.xml：字符串值。styles.xml：样式请参阅字符串资源、样式资源和更多资源类型。 xml/ 可以在运行时通过调用 Resources.getXML()) 读取的任意 XML 文件。各种 XML配置文件（如可搜索配置）都必须保存在此处。 注意：切勿将资源文件直接保存在res/目录内，这会导致出现编译错误。 如需了解有关某些资源类型的详细信息，请参阅资源类型文档。 保存在表 1中定义的子目录下的资源是“默认”资源。即，这些资源定义应用的默认设计和内容。但是，采用Android技术的不同设备类型可能需要不同类型的资源。例如，如果设备的屏幕尺寸大于标准屏幕，则应提供不同的布局资源，以充分利用额外的屏幕空间。 或者，如果设备的语言设置不同，则应提供不同的字符串资源，以转换用户界面中的文本。 要为不同的设备配置提供这些不同资源，除了默认资源以外，您还需要提供备用资源。 为项目提供备用资源图 1. 两种不同的设备，均使用不同的布局资源。 几乎每个应用都应提供备用资源以支持特定的设备配置。 例如，对于不同的屏幕密度和语言，您应分别包括备用可绘制对象资源和备用字符串资源。 在运行时，Android会检测当前设备配置并为应用加载合适的资源。 为一组资源指定特定于配置的备用资源： 在 res/中创建一个以&lt;resources_name&gt;-&lt;config_qualifier&gt;形式命名的新目录。 &lt;resources_name&gt; 是相应默认资源的目录名称（如表 1中所定义）。 &lt;qualifier&gt; 是指定要使用这些资源的各个配置的名称（如表 2中所定义）。您可以追加多个 &lt;qualifier&gt;。以短划线将其分隔。 注意：追加多个限定符时，必须按照表 2 中列出的相同顺序放置它们。如果限定符的顺序错误，则该资源将被忽略。 将相应的备用资源保存在此新目录下。这些资源文件的名称必须与默认资源文件完全一样。 例如，以下是一些默认资源和备用资源： hdpi限定符表示该目录中的资源适用于屏幕密度较高的设备。其中每个可绘制对象目录中的图像已针对特定的屏幕密度调整大小，但是文件名完全相同。 这样一来，用于引用 icon.png 或background.png 图像的资源 ID 始终相同，但是 Android 会通过将设备配置信息与资源目录名称中的限定符进行比较，选择最符合当前设备的各个资源版本。 Android 支持若干配置限定符，您可以通过使用短划线分隔每个限定符，向一个目录名称添加多个限定符。表 2 按优先顺序列出了有效的配置限定符；如果对资源目录使用多个限定符，则必须按照表中列出的顺序将它们添加到目录名称。 Android资源限定符表 2. 配置限定符名称。 配置 限定符值 说明 MCC 和 MNC 示例： mcc310 &lt;nobr&gt;mcc310-mnc004&lt;/nobr&gt; mcc208-mnc00等等 移动国家代码 (MCC)，（可选）后跟设备 SIM卡中的移动网络代码 (MNC)。例如，mcc310 是指美国的任一运营商，mcc310-mnc004 是指美国的 Verizon公司，mcc208-mnc00 是指法国的 Orange公司。如果设备使用无线电连接（GSM 手机），则 MCC 和 MNC 值来自 SIM卡。也可以单独使用MCC（例如，将国家/地区特定的合法资源包括在应用中）。如果只需根据语言指定，则改用“语言和区域”限定符（稍后进行介绍）。如果决定使用 MCC 和MNC 限定符，请谨慎执行此操作并测试限定符是否按预期工作。 另请参阅配置字段 mcc和 mnc，这两个字段分别表示当前的移动国家代码和移动网络代码。 语言和区域 示例：en fr en-rUS fr-rFR fr-rCA等等 语言通过由两个字母组成的 ISO639-1 语言代码定义，可以选择后跟两个字母组成的ISO3166-1-alpha-2 区域码（前带小写字母“r”）。这些代码不区分大小写；r前缀用于区分区域码。不能单独指定区域。如果用户更改系统设置中的语言，它有可能在应用生命周期中发生改变。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。有关针对其他语言本地化应用的完整指南，请参阅本地化。另请参阅 locale 配置字段，该字段表示当前的语言区域。 布局方向 ldrtl ldltr 应用的布局方向。ldrtl 是指“布局方向从右到左”。ldltr是指“布局方向从左到右”，这是默认的隐式值。它适用于布局、图片或值等任何资源。例如，若要针对阿拉伯语提供某种特定布局，并针对任何其他“从右到左”语言（如波斯语或希伯来语）提供某种通用布局，则可编码如下：注：要为应用启用从右到左的布局功能，必须将supportsRtl 设置为 &quot;true&quot;，并将 targetSdkVersion 设置为 17 或更高版本。此项为 API 级别 17 中新增配置。 smallestWidth sw&lt;N&gt;dp 示例：sw320dpsw600dpsw20dp等等 屏幕的基本尺寸，由可用屏幕区域的最小尺寸指定。具体来说，设备的 smallestWidth是屏幕可用高度和宽度的最小尺寸（您也可以将其视为屏幕的“最小可能宽度”）。无论屏幕的当前方向如何，您均可使用此限定符确保应用UI 的可用宽度至少为&lt;N&gt;dp。例如，如果布局要求屏幕区域的最小尺寸始终至少为600dp，则可使用此限定符创建布局资源 res/layout-sw600dp/。仅当可用屏幕的最小尺寸至少为600dp 时，系统才会使用这些资源，而不考虑600dp所代表的边是用户所认为的高度还是宽度。smallestWidth是设备的固定屏幕尺寸特性；设备的 smallestWidth不会随屏幕方向的变化而改变。设备的 smallestWidth 将屏幕装饰元素和系统 UI 考虑在内。例如，如果设备的屏幕上有一些永久性 UI 元素占据沿smallestWidth轴的空间，则系统会声明 smallestWidth 小于实际屏幕尺寸，因为这些屏幕像素不适用于您的 UI。因此，使用的值应该是布局所需要的实际最小尺寸（通常，无论屏幕的当前方向如何，此值都是布局支持的“最小宽度”）。以下是一些可用于普通屏幕尺寸的值：320，适用于屏幕配置如下的设备：240x320 ldpi（QVGA 手机）320x480 mdpi（手机）480x800 hdpi（高密度手机）480，适用于 480x800 mdpi 之类的屏幕（平板电脑/手机）。600，适用于 600x1024 mdpi 之类的屏幕（7 英寸平板电脑）。720，适用于 720x1280 mdpi 之类的屏幕（10 英寸平板电脑）。应用为多个资源目录提供不同的 smallestWidth 限定符值时，系统会使用最接近（但未超出）设备smallestWidth 的值。 此项为 API 级别 13 中新增配置。 另请参阅 android:requiresSmallestWidthDp 属性和 smallestScreenWidthDp 配置字段，前者声明与应用兼容的最小 smallestWidth；后者存放设备的 smallestWidth 值。如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多种屏幕开发者指南。 可用宽度 w&lt;N&gt;dp示例：w720dpw1024dp 等等 指定资源应该使用的最小可用屏幕宽度，以 dp为单位，由 &amp;lt;N&amp;gt; 值定义。在横向和纵向之间切换时，为了匹配当前实际宽度，此配置值也会随之发生变化。br/&gt;应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕宽度的值。此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的左边缘或右边缘上有一些永久性 UI元素，考虑到这些 UI元素，它会使用小于实际屏幕尺寸的宽度值，这样会减少应用的可用空间。此项为 API 级别 13 中新增配置。 另请参阅screenWidthDp 配置字段，该字段存放当前屏幕宽度。如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多种屏幕开发者指南。 可用高度 h&lt;N&gt;dp 示例：h720dp h1024dp等等 指定资源应该使用的最小可用屏幕高度，以“dp”为单位，由 &lt;N&gt; 值定义。在横向和纵向之间切换时，为了匹配当前实际高度，此配置值也会随之发生变化。应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕高度的值。此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的上边缘或下边缘有一些永久性 UI元素，考虑到这些 UI 元素，同时为减少应用的可用空间，它会使用小于实际屏幕尺寸的高度值。非固定的屏幕装饰元素（例如，全屏时可隐藏的手机状态栏）并不在考虑范围内，标题栏或操作栏等窗口装饰也不在考虑范围内，因此应用必须准备好处理稍小于其所指定值的空间。此项为 API 级别 13 中新增配置。另请参阅screenHeightDp 配置字段，该字段存放当前屏幕宽度。如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅支持多种屏幕开发者指南。 屏幕尺寸 smallnormal large xlarge small：尺寸类似于低密度QVGA 屏幕的屏幕。小屏幕的最小布局尺寸约为320x426 dp 单位。例如，QVGA 低密度屏幕和WVGA高密度屏幕。normal：尺寸类似于中等密度HVGA 屏幕的屏幕。标准屏幕的最小布局尺寸约为320x470 dp 单位。例如，WQVGA低密度屏幕、HVGA 中等密度屏幕、WVGA高密度屏幕。large：尺寸类似于中等密度WVGA 屏幕的屏幕。大屏幕的最小布局尺寸约为 480x640 dp 单位。 例如，VGA 和 WVGA 中等密度屏幕。xlarge：明显大于传统中等密度HVGA 屏幕的屏幕。超大屏幕的最小布局尺寸约为720x960 dp 单位。在大多数情况下，屏幕超大的设备体积过大，不能放进口袋，最常见的是平板式设备。API 级别 9 中的新增配置。注：使用尺寸限定符并不表示资源仅适用于该尺寸的屏幕。如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中最匹配的资源。注意：如果所有资源均使用大于当前屏幕的尺寸限定符，则系统不会使用这些资源，并且应用在运行时将会崩溃（例如，如果所有布局资源均用 xlarge 限定符标记，但设备是标准尺寸的屏幕）。此项为 API 级别 4 中新增配置。如需了解详细信息，请参阅支持多种屏幕。另请参阅 screenLayout 配置字段，该字段表示屏幕是小尺寸、标准尺寸还是大尺寸。 屏幕纵横比 longnotlong long：宽屏，如 WQVGA、WVGA、FWVGAnotlong：非宽屏，如 QVGA、HVGA 和 VGA此项为 API 级别 4 中新增配置。它完全基于屏幕的纵横比（宽屏较宽），而与屏幕方向无关。另请参阅 screenLayout 配置字段，该字段指示屏幕是否为宽屏。 圆形屏幕 roundnotround round：圆形屏幕，例如圆形可穿戴式设备notround：方形屏幕，例如手机或平板电脑此项为 API 级别 23 中新增配置。 另请参阅 isScreenRound()) 配置方法，其指示屏幕是否为宽屏。 屏幕方向 portland port：设备处于纵向（垂直）land：设备处于横向（水平）如果用户旋转屏幕，它有可能在应用生命周期中发生改变。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。另请参阅 orientation 配置字段，该字段指示当前的设备方向。 UI 模式 car desk television&lt;br/&gt;appliancewatch` car：设备正在车载手机座上显示desk：设备正在桌面手机座上显示television：设备正在电视上显示，为用户提供“十英尺”体验，其UI 位于远离用户的大屏幕上，主要面向方向键或其他非指针式交互appliance：设备用作不带显示屏的装置watch：设备配有显示屏，戴在手腕上 此项为 API 级别 8 中新增配置，API 13 中新增电视配置，API 20 中新增手表配置。 如需了解应用在设备插入手机座或从中移除时的响应方式，请阅读确定并监控插接状态和类型。如果用户将设备放入手机座中，它有可能在应用生命周期中发生改变。可以使用 启用或禁用其中某些模式。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 夜间模式 night notnight night：夜间notnight：白天 此项为 API 级别 8 中新增配置。如果夜间模式停留在自动模式（默认），它有可能在应用生命周期中发生改变。在这种情况下，该模式会根据当天的时间进行调整。可以使用UiModeManager 启用或禁用此模式。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。 屏幕像素密度 (dpi) ldpimdpihdpixhdpixxhdpixxxhdpi nodpi tvdpianydpi ldpi：低密度屏幕；约为120dpi。mdpi：中等密度（传统 HVGA）屏幕；约为160dpi。hdpi：高密度屏幕；约为 240dpi。xhdpi：超高密度屏幕；约为 320dpi。此项为 API级别 8 中新增配置xxhdpi：超超高密度屏幕；约为 480dpi。此项为 API级别 16 中新增配置xxxhdpi：超超超高密度屏幕使用（仅限启动器图标，请参阅“支持多种屏幕”中的注释）；约为640dpi。此项为 API级别 18 中新增配置nodpi：它可用于您不希望缩放以匹配设备密度的位图资源。tvdpi：密度介于 mdpi 和 hdpi 之间的屏幕；约为 213dpi。它并不是“主要”密度组，主要用于电视，而大多数应用都不需要它。对于大多数应用而言，提供 mdpi 和hdpi资源便已足够，系统将根据需要对其进行缩放。此项为 API 级别 13 中新增配置anydpi：此限定符适合所有屏幕密度，其优先级高于其他限定符。这对于矢量可绘制对象很有用。此项为 API 级别 21 中新增配置 六个主要密度之间的缩放比为 3:4:6:8:12:16（忽略tvdpi 密度）。因此，9x9 (ldpi) 位图相当于 12x12 (mdpi)、18x18 (hdpi)、24x24 (xhdpi) 位图，依此类推。 如果您认为图像资源在电视或其他某些设备上呈现的效果不够好，而想尝试使用 tvdpi 资源，则缩放比例为1.33*mdpi。例如，mdpi屏幕的 100px x 100px 图像应该相当于 tvdpi 的133px x 133px。 注：使用密度限定符并不表示资源仅适用于该密度的屏幕。如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中#BestMatch”&gt;最匹配的资源。如需了解有关如何处理不同屏幕密度以及 Android 如何缩放位图以适应当前密度的详细信息，请参阅支持多种屏幕。 触摸屏类型 notouchfinger notouch：设备没有触摸屏。finger：设备有一个专供用户通过手指直接与其交互的触摸屏。 另请参阅 touchscreen 配置字段，该字段指示设备上的触摸屏类型。 键盘可用性 keysexposed keyshidden keyssoft keysexposed：设备具有可用的键盘。如果设备启用了软键盘（不无可能），那么即使硬键盘没有展示给用户，哪怕设备没有硬键盘，也可以使用此限定符。如果没有提供或已经禁用软键盘，则只有在显示硬键盘时才会使用此限定符。keyshidden：设备具有可用的硬键盘，但它处于隐藏状态，且设备没有启用软键盘。keyssoft：设备已经启用软键盘（无论是否可见）。如果提供了 keysexposed 资源，但未提供 keyssoft资源，那么只要系统已经启用软键盘，就会使用keysexposed 资源，而不考虑键盘是否可见。如果用户打开硬键盘，它有可能在应用生命周期中发生改变。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。另请参阅配置字段 hardKeyboardHidden和keyboardHidden，这两个字段分别指示硬键盘的可见性和任何一种键盘（包括软键盘）的可见性。 主要文本输入法 nokeysqwerty 12key nokeys：设备没有用于文本输入的硬按键。qwerty：设备具有标准硬键盘（无论是否对用户可见）。12key：设备具有 12 键硬键盘（无论是否对用户可见）。另请参阅 keyboard 配置字段，该字段指示可用的主要文本输入法。 导航键可用性 navexposed navhidden navexposed：导航键可供用户使用。navhidden：导航键不可用（例如，位于密封盖子后面）。 如果用户显示导航键，它有可能在应用生命周期中发生改变。如需了解这会在运行期间给应用带来哪些影响，请参阅处理运行时变更。另请参阅navigationHidden 配置字段，该字段指示导航键是否处于隐藏状态。 主要非触摸导航方法 nonavdpad trackball wheel nonav：除了使用触摸屏以外，设备没有其他导航设施。dpad：设备具有用于导航的方向键。trackball：设备具有用于导航的轨迹球。wheel：设备具有用于导航的方向盘（不常见）。另请参阅 navigation配置字段，该字段指示可用的导航方法类型。 平台版本（API 级别） 示例：v3v4v7等等 设备支持的 API 级别。例如，v1 对应于 API 级别1（带有 Android 1.0 或更高版本系统的设备），v4 对应于 API 级别 4（带有 Android1.6 或更高版本系统的设备）。如需了解有关这些值的详细信息，请参阅Android API 级别文档。 注：有些配置限定符是从 Android 1.0 才开始添加，因此并非所有版本的Android系统都支持所有限定符。使用新限定符会隐式添加平台版本限定符，因此较旧版本系统的设备必然会忽略它。 例如，使用 w600dp 限定符会自动包括 v13 限定符，因为可用宽度限定符是 API 级别 13 中的新增配置。为了避免出现任何问题，请始终包含一组默认资源（一组“不带限定符”的资源）。 如需了解详细信息，请参阅利用资源提供最佳设备兼容性部分 限定符命名规则以下是一些关于使用配置限定符名称的规则： 您可以为单组资源指定多个限定符，并使用短划线分隔。例如，drawable-en-rUS-land 适用于横排美国英语设备。 这些限定符必须遵循表 2 中列出的顺序。例如： 错误：drawable-hdpi-port/ 正确：drawable-port-hdpi/ 不能嵌套备用资源目录。例如，您不能拥有 res/drawable/drawable-en/。 值不区分大小写。在处理之前，资源编译器会将目录名称转换为小写，以避免不区分大小写的文件系统出现问题。 名称中使用的任何大写字母只是为了便于认读。 对于每种限定符类型，仅支持一个值。例如，若要对西班牙语和法语使用相同的可绘制对象文件，则您肯定不能拥有名为drawable-rES-rFR/ 的目录，而是需要两个包含相应文件的资源目录，如 drawable-rES/ 和 drawable-rFR/。然而，实际上您无需将相同的文件都复制到这两个位置。相反，您可以创建指向资源的别名。 请参阅下面的创建别名资源。 将备用资源保存到以这些限定符命名的目录中之后，Android 会根据当前设备配置在应用中自动应用这些资源。 每次请求资源时，Android 都会检查备用资源目录是否包含所请求的资源文件，然后找到最匹配资源（下文进行介绍）。 如果没有与特定设备配置匹配的备用资源，则 Android 会使用相应的默认资源（一组用于不含配置限定符的特定资源类型的资源） 创建别名资源如果您想将某一资源用于多种设备配置（但是不想作为默认资源提供），则无需将同一资源放入多个备用资源目录中。 相反，您可以（在某些情况下）创建备用资源，充当保存在默认资源目录下的资源的别名。 注：并非所有资源都会提供相应机制让您创建指向其他资源的别名。 特别是，xml/ 目录中的动画资源、菜单资源、原始资源以及其他未指定资源均不提供此功能。 例如，假设您有一个应用图标 icon.png，并且需要不同语言区域的独特版本。 但是，加拿大英语和加拿大法语这两种语言区域需要使用同一版本。 您可能会认为需要将相同的图像复制到加拿大英语和加拿大法语对应的资源目录中，但事实并非如此。 相反，您可以将用于二者的图像另存为icon_ca.png（除 icon.png 以外的任何名称），并将其放入默认res/drawable/目录中。然后，在res/drawable-en-rCA/ 和 res/drawable-fr-rCA/ 中创建icon.xml文件，使用 &lt;bitmap&gt; 元素引用 icon_ca.png资源。这样，您只需存储 PNG 文件的一个版本和两个指向该版本的小型 XML 文件。（XML 文件示例如下。） 可绘制对象要创建指向现有可绘制对象的别名，请使用&lt;bitmap&gt;元素。例如：123&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;bitmap xmlns:android=\"http://schemas.android.com/apk/res/android\" android:src=\"@drawable/icon_ca\" /&gt; 如果将此文件另存为icon.xml（例如，在备用资源目录中，另存为res/drawable-en-rCA/），则会编译到可作为 R.drawable.icon 引用的资源中，但实际上它是 R.drawable.icon_ca资源（保存在res/drawable/中）的别名。 布局要创建指向现有布局的别名，请使用包装在&lt;merge&gt;中的&lt;include&gt;元素。例如：1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;merge&gt; &lt;include layout=\"@layout/main_ltr\"/&gt;&lt;/merge&gt; 如果将此文件另存为 main.xml，则会编译到可作为 R.layout.main 引用的资源中，但实际上它是 R.layout.main_ltr 资源的别名。 字符串和其他简单值要创建指向现有字符串的别名，只需将所需字符串的资源 ID 用作新字符串的值即可。例如：12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;string name=\"hello\"&gt;Hello&lt;/string&gt; &lt;string name=\"hi\"&gt;@string/hello&lt;/string&gt;&lt;/resources&gt; R.string.hi资源现在是 R.string.hello的别名。 其他简单值的原理相同。 例如，颜色：12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;color name=\"red\"&gt;#f00&lt;/color&gt; &lt;color name=\"highlight\"&gt;@color/red&lt;/color&gt;&lt;/resources&gt; 利用资源提供最佳设备兼容性要使应用支持多种设备配置，则务必为应用使用的每种资源类型提供默认资源，这一点非常重要。 例如，如果应用支持多种语言，请始终包含不带语言和区域限定符的 values/ 目录（用于保存字符串）。相反，如果您将所有字符串放入带有语言和区域限定符的目录中，则在语言设置不支持您的字符串的设备上运行应用时，应用将会崩溃。 但是，只要提供默认 values/ 资源，应用就会正常运行（即使用户不理解该语言，这也总比崩溃要好）。 同样，如果您根据屏幕方向提供不同的布局资源，则应选择一个方向作为默认方向。 例如，不要在 layout-land/ 和 layout-port/ 中分别提供横向和纵向的布局资源，而是保留其中之一作为默认设置，例如：layout/ 用于横向，layout-port/ 用于纵向。 提供默认资源至关重要，这不仅仅因为应用可能在超出预期的配置上运行，也因为新版 Android 有时会添加旧版本不支持的配置限定符。若要使用新的资源限定符，又希望维持对旧版 Android 的代码兼容性，则当旧版 Android 运行应用时，如果不提供默认资源，应用将会崩溃，这是因为它无法使用以新限定符命名的资源。例如，如果将 minSdkVersion 设置为 4，并使用夜间模式（night 或 notnight，API 级别 8 中新增配置）限定所有可绘制对象资源，则 API 级别 4 设备无法访问可绘制对象资源，而且会崩溃。在这种情况下，您可能希望 notnight 成为默认资源，为此，您应排除该限定符，使可绘制对象资源位于drawable/ 或 drawable-night/ 中。 因此，为了提供最佳设备兼容性，请始终为应用正确运行所必需的资源提供默认资源。 然后，使用配置限定符为特定的设备配置创建备用资源。 这条规则有一个例外：如果应用的 minSdkVersion 为 4 或更高版本，则在提供带屏幕密度限定符的备用可绘制对象资源时，不需要默认可绘制对象资源。 即使没有默认可绘制对象资源，Android 也可以从备用屏幕密度中找到最佳匹配项并根据需要缩放位图。 但是，为了在所有类型的设备上提供最佳体验，您应该为所有三种类型的密度提供备用可绘制对象。 Android 如何找到最匹配资源当您请求要为其提供备用资源的资源时，Android 会根据当前的设备配置选择要在运行时使用的备用资源。为演示 Android 如何选择备用资源，假设以下可绘制对象目录分别包含相同图像的不同版本：1234567drawable/drawable-en/drawable-fr-rCA/drawable-en-port/drawable-en-notouch-12key/drawable-port-ldpi/drawable-port-notouch-12key/ 同时，假设设备配置如下：12345语言区域 = en-GB 屏幕方向 = port 屏幕像素密度 = hdpi 触摸屏类型 = notouch 主要文本输入法 = 12key 通过将设备配置与可用的备用资源进行比较，Android 从 drawable-en-port 中选择可绘制对象。 系统使用以下逻辑决定要使用的资源： 淘汰与设备配置冲突的资源文件。 drawable-fr-rCA/ 目录与en-GB语言区域冲突，因而被淘汰。 1234567drawable/drawable-en/drawable-fr-rCA/ ---&gt;//被淘汰drawable-en-port/drawable-en-notouch-12key/drawable-port-ldpi/drawable-port-notouch-12key/ 例外：屏幕像素密度是唯一一个未因冲突而被淘汰的限定符。 尽管设备的屏幕密度为 hdpi，但是 drawable-port-ldpi/ 未被淘汰，因为此时每个屏幕密度均视为匹配。如需了解详细信息，请参阅支持多种屏幕文档。 选择列表（表 2）中（下一个）优先级最高的限定符。（先从 MCC开始，然后下移。） 是否有资源目录包括此限定符？ 若无，请返回到第 2 步，看看下一个限定符。（在该示例中，除非达到语言限定符，否则答案始终为“否”。） 若有，请继续执行第 4 步。 淘汰不含此限定符的资源目录。在该示例中，系统会淘汰所有不含语言限定符的目录。 123456 drawable/ ---&gt;//被淘汰drawable-en/drawable-en-port/drawable-en-notouch-12key/drawable-port-ldpi/ ---&gt;//被淘汰drawable-port-notouch-12key/ ---&gt;//被淘汰 例外：如果涉及的限定符是屏幕像素密度，则 Android 会选择最接近设备屏幕密度的选项。通常，Android 倾向于缩小大型原始图像，而不是放大小型原始图像。请参阅支持多种屏幕。 返回并重复第 2 步、第 3 步和第 4 步，直到只剩下一个目录为止。在此示例中，屏幕方向是下一个判断是否匹配的限定符。因此，未指定屏幕方向的资源被淘汰： 123 drawable-en/ ---&gt;//被淘汰drawable-en-port/drawable-en-notouch-12key/ ---&gt;//被淘汰 剩下的目录是drawable-en-port。 尽管对所请求的每个资源均执行此程序，但是系统仍会对某些方面做进一步优化。 例如，系统一旦知道设备配置，即会淘汰可能永远无法匹配的备用资源。 比如说，如果配置语言是英语（“en”），则系统绝不会将语言限定符设置为非英语的任何资源目录包含在选中的资源池中（不过，仍会将不带语言限定符的资源目录包含在该池中）。 根据屏幕尺寸限定符选择资源时，如果没有更好的匹配资源，则系统将使用专为小于当前屏幕的屏幕而设计的资源（例如，如有必要，大尺寸屏幕将使用标准尺寸的屏幕资源）。 但是，如果唯一可用的资源大于当前屏幕，则系统不会使用这些资源，并且如果没有其他资源与设备配置匹配，应用将会崩溃（例如，如果所有布局资源均用 xlarge 限定符标记，但设备是标准尺寸的屏幕）。 注：限定符的优先顺序（表 2 中）比与设备完全匹配的限定符数量更加重要。例如，在上面的第 4 步中，列表剩下的最后选项包括三个与设备完全匹配的限定符（方向、触摸屏类型和输入法），而 drawable-en 只有一个匹配参数（语言）。但是，语言的优先顺序高于其他两个限定符，因此drawable-port-notouch-12key 被淘汰。 write by laohu2016年11月19日 原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：博客。","link":"/Android-resources-adapter.html"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"AndroidStudio","slug":"AndroidStudio","link":"/tags/AndroidStudio/"},{"name":"OkHttp","slug":"OkHttp","link":"/tags/OkHttp/"},{"name":"View","slug":"View","link":"/tags/View/"},{"name":"Shape","slug":"Shape","link":"/tags/Shape/"},{"name":"百度地图","slug":"百度地图","link":"/tags/百度地图/"},{"name":"Behavior","slug":"Behavior","link":"/tags/Behavior/"},{"name":"Material Design","slug":"Material-Design","link":"/tags/Material-Design/"},{"name":"Flutter","slug":"Flutter","link":"/tags/Flutter/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"多线程","slug":"多线程","link":"/tags/多线程/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"Coroutine","slug":"Coroutine","link":"/tags/Coroutine/"},{"name":"RN","slug":"RN","link":"/tags/RN/"},{"name":"RecyclerView","slug":"RecyclerView","link":"/tags/RecyclerView/"},{"name":"Retrofit","slug":"Retrofit","link":"/tags/Retrofit/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"WordPress","slug":"WordPress","link":"/tags/WordPress/"},{"name":"Thinking","slug":"Thinking","link":"/tags/Thinking/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"小程序","slug":"小程序","link":"/tags/小程序/"},{"name":"IM","slug":"IM","link":"/tags/IM/"},{"name":"DB","slug":"DB","link":"/tags/DB/"},{"name":"Media","slug":"Media","link":"/tags/Media/"},{"name":"RxJava","slug":"RxJava","link":"/tags/RxJava/"},{"name":"SpannableStringBuilder","slug":"SpannableStringBuilder","link":"/tags/SpannableStringBuilder/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"JSONP","slug":"JSONP","link":"/tags/JSONP/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Material Design","slug":"Material-Design","link":"/categories/Material-Design/"},{"name":"Flutter","slug":"Flutter","link":"/categories/Flutter/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Kotlin","slug":"Kotlin","link":"/categories/Kotlin/"},{"name":"React Native","slug":"React-Native","link":"/categories/React-Native/"},{"name":"Blog","slug":"Blog","link":"/categories/Blog/"},{"name":"Other","slug":"Other","link":"/categories/Other/"},{"name":"小程序","slug":"小程序","link":"/categories/小程序/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}