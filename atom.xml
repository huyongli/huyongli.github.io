<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老胡</title>
  
  <subtitle>技术卓越，不断前行</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ittiger.cn/"/>
  <updated>2019-05-10T13:21:27.613Z</updated>
  <id>http://ittiger.cn/</id>
  
  <author>
    <name>老胡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android模块化开发配置</title>
    <link href="http://ittiger.cn/android-module-develop-config.html"/>
    <id>http://ittiger.cn/android-module-develop-config.html</id>
    <published>2019-05-10T13:16:13.000Z</published>
    <updated>2019-05-10T13:21:27.613Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><ol><li>项目由多个模块组成</li><li>每个模块都是一个独立的Feature或组件</li><li>业务模块间解耦不相互直接依赖</li><li>业务模块与公共组件模块通过aar依赖</li><li>每个模块独立开发，独立运行调试</li></ol><h3 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h3><p>当一个项目越来越大，越来越复杂后，代码量就会变得越来大，难以阅读难以维护，业务之间出现耦合的可能性也会越来越大，同时整个APP编译调试的时间也会越来越长。</p><p>而使用模块化开发则可以解决以上问题：</p><ol><li>项目代码结构清晰，每个Feature和公共组件都是一个独立的Library模块</li><li>避免每个Library模块间的直接耦合</li><li>提升模块的复用性</li><li>单个模块独立编译调试速度更快，节省开发时间</li><li>只关注自己所在的模块，从而避免其他Feature的异常block自己的Feature开发</li></ol><p>但是…这篇文章不是教你如何进行模块化开发，而是介绍如何进行模块化开发的工程配置，以满足模块化开发过程中的多团队协作问题。<br><a id="more"></a></p><h3 id="模块化开发配置"><a href="#模块化开发配置" class="headerlink" title="模块化开发配置"></a>模块化开发配置</h3><p>我们先创建一个Android工程，这个工程除了有一个app的主module之外，还有两个library类型的module，工程结构如下图：<br><img src="/img/android-modul-code.png" width="200" hegiht="300"></p><p>上图中module1和module2就代表了两个不同的业务module</p><p><strong>模块化开发配置需要解决哪些问题呢？</strong></p><h4 id="module配置参数化"><a href="#module配置参数化" class="headerlink" title="module配置参数化"></a>module配置参数化</h4><p>大家都知道一个项目的主module存在一个build.gradle文件，里面有如下内容：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line">apply plugin: &apos;kotlin-android&apos;</span><br><span class="line">apply plugin: &apos;kotlin-android-extensions&apos;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 28</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId &quot;xxxxxxxxx&quot;</span><br><span class="line">        minSdkVersion 21</span><br><span class="line">        targetSdkVersion 28</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而工程中的library类型的moudle也有一个build.gradle文件，它的内容如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.library&apos;</span><br><span class="line">apply plugin: &apos;kotlin-android&apos;</span><br><span class="line">apply plugin: &apos;kotlin-android-extensions&apos;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 28</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion 21</span><br><span class="line">        targetSdkVersion 28</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过上面的配置内容可以发现主module和library类型的module除了plugin不一样之外，主module会比library类型module只多一个applicationId。 </p><p>所以如果我们想让某个library类型的module能独立运行调试，我们可以通过参数控制，动态的为该module添加相关配置，具体脚本如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//common-build.gradle</span><br><span class="line">project.ext &#123;</span><br><span class="line">    mainModuleType = &quot;mainModule&quot;//主module</span><br><span class="line">    debugLibraryModuleType = &quot;debugLibraryModule&quot;//可单独运行的library module</span><br><span class="line">    libraryModuleType = &quot;libraryModule&quot;</span><br><span class="line"></span><br><span class="line">    //根据module类型动态添加对应的配置</span><br><span class="line">    configModuleGradleScript = &#123; moduleType -&gt;</span><br><span class="line">        applyPlugin(moduleType)</span><br><span class="line">        applyAndroidDefaultConfig()</span><br><span class="line">        applyApplicationId(moduleType)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //配置module的编译版本相关配置</span><br><span class="line">    applyAndroidDefaultConfig = &#123;</span><br><span class="line">        project.android.compileSdkVersion compileSdkVersion</span><br><span class="line">        project.android.defaultConfig.targetSdkVersion targetSdkVersion</span><br><span class="line">        project.android.defaultConfig.minSdkVersion minSdkVersion</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //根据module类型动态添加对应plugin</span><br><span class="line">    applyPlugin = &#123; moduleType -&gt;</span><br><span class="line">        if(moduleType == libraryModuleType) &#123;</span><br><span class="line">            project.apply plugin: &apos;com.android.library&apos;</span><br><span class="line">            project.description &quot;library&quot;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            project.apply plugin: &apos;com.android.application&apos;</span><br><span class="line">            project.description &quot;app&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        project.apply plugin: &apos;kotlin-android&apos;</span><br><span class="line">        project.apply plugin: &apos;kotlin-android-extensions&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据module类型动态添加对应的applicationId</span><br><span class="line">    applyApplicationId = &#123; moduleType -&gt;</span><br><span class="line">        if(moduleType == mainModuleType) &#123;</span><br><span class="line">            project.android.defaultConfig.applicationId applicationId</span><br><span class="line">        &#125; else if(moduleType == debugLibraryModuleType) &#123;</span><br><span class="line">            project.android.defaultConfig.applicationId applicationId + &quot;.&quot; + project.name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到所有的动态配置脚本我都是通过在<code>project.ext</code>中添加闭包实现的，这样做的好处是在其他脚本文件中也可以引用project.ext中定义的闭包和变量</p><p>另外上面的配置中，在配置可单独调试library module时，我对其<code>applicationId</code>添加一个工程名称作为后缀，这样可以对主app的<code>applicationId</code>进行区分。</p><p>上面脚本里的注释提到了<code>可单独运行的library module</code>，那这是什么意思呢？<br>我们每个工程打包为apk时只能有唯一一个plugin为<code>com.android.application</code>的主module，而其他需要集成的moudle的plugin均为<code>com.android.library</code>，当开发某个业务module(library类型)时，我们需要该module能单独运行以方便我们调试同时节省编译时间，这时我们就需要通过gradle参数控制，将其plugin暂时变为<code>com.android.application</code>以便使其能独立运行，所以这个时候该module也是一个主module，但为了与apk的主module进行区分，所以我把它叫做可单独运行的library module</p><p>那具体如何通过参数控制将某个library module暂时变为可单独编译运行的module，而在集成的时候又设置为library类型的module呢？我们可以在工程根目录的<code>gradle.properties</code>文件中添加参数进行控制<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//gradle.properties文件</span><br><span class="line">debugLibraryModules=[module1]</span><br></pre></td></tr></table></figure></p><p>上面的<code>debugLibraryModules</code>参数将module名称为<code>module1</code>的module设置为可单独运行的library module，这个参数是一个数组，可以配置多个module。当这个数组为空的时候就代表不设置任何library module。</p><p>通过这个参数我们就可以在每个module工程加载脚本时判断当前module是否为可单独编译运行的module，判断方法如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">project.ext &#123;</span><br><span class="line">    //通过module的名称进行判断</span><br><span class="line">    isDebugLibraryModule = &#123; projectName -&gt;</span><br><span class="line">        def debugLibraryModuleList = debugLibraryModules</span><br><span class="line">        return project.hasProperty(&apos;debugLibraryModules&apos;) &amp;&amp; debugLibraryModuleList.indexOf(projectName) != -1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里，我们的参数化动态配置脚本的基础已经完成了，接着要针对主module和library module进行具体的工程配置。</p><h4 id="配置app的主module"><a href="#配置app的主module" class="headerlink" title="配置app的主module"></a>配置app的主module</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//main-module-build.gradle</span><br><span class="line">configModuleGradleScript(mainModuleType)</span><br><span class="line"></span><br><span class="line">getRootProject().getSubprojects().each &#123;item -&gt;</span><br><span class="line">    if(item.name != project.name &amp;&amp; !isDebugLibraryModule(item.name)) &#123;</span><br><span class="line">        project.dependencies.add(&quot;implementation&quot;, project(&quot;:$item.name&quot;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为app的主module是不可能变的，所以该module的moduleType肯定是<code>mainModuleType</code></p><p>另外app在集成其他library module时必须要将其他library module添加为主module的工程依赖，所以上述脚本中使用<code>getRootProject().getSubprojects()</code>先找到工程的所有module,然后将library module都动态添加为主module的工程依赖</p><p>主module的<code>build.gradle</code>内容如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apply from: &quot;$&#123;rootProject.rootDir&#125;/buildScript/common-build.gradle&quot;</span><br><span class="line">apply from: &quot;$&#123;rootProject.rootDir&#125;/buildScript/main-module-build.gradle&quot;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android-optimize.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在该工程的主module动态添加工程源码依赖时，也可以通过参数来控制某个module到底是采用工程源码依赖，还是采用远程仓库的aar依赖，以此来满足不同的业务需要。这篇文章就不介绍了，相信看懂这篇文章的同学应该能自己实现这个需求。</p><h4 id="配置library-module"><a href="#配置library-module" class="headerlink" title="配置library module"></a>配置library module</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//library-module-build.gradle</span><br><span class="line">def getModuleType() &#123;</span><br><span class="line">    if(isDebugLibraryModule(project.name)) &#123;</span><br><span class="line">        return debugLibraryModuleType</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return libraryModuleType</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">configModuleGradleScript(getModuleType())</span><br></pre></td></tr></table></figure><p>在配置library module时，要先判断当前library moduel是否已经通过参数设置为可单独运行的module，如果是的话则该module调用闭包<code>configModuleGradleScript</code>的参数为<code>debugLibraryModuleType</code>，否则则为<code>libraryModuleType</code></p><p>library module的<code>build.gradle</code>内容如下<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">apply from: &quot;$&#123;rootProject.rootDir&#125;/buildScript/common-build.gradle&quot;</span><br><span class="line">apply from: &quot;$&#123;rootProject.rootDir&#125;/buildScript/library-module-build.gradle&quot;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android-optimize.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            if(isDebugLibraryModule(project.name)) &#123;</span><br><span class="line">                manifest.srcFile &apos;src/debug/AndroidManifest.xml&apos;</span><br><span class="line">                java.srcDirs = [&apos;src/debug/java&apos;, &apos;src/main/java&apos;]</span><br><span class="line">                res.srcDirs = [&apos;src/debug/res&apos;,&apos;src/main/res&apos;]</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                manifest.srcFile &apos;src/main/AndroidManifest.xml&apos;</span><br><span class="line">                resources &#123;</span><br><span class="line">                    //排除java/debug文件夹下的所有文件</span><br><span class="line">                    exclude &apos;src/debug/*&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述脚本在配置可单独运行的library module时，虽然已经动态将其plugin设置为<code>com.android.application</code>也添加了<code>applicationId</code>，但是该module依旧还不能单独运行，因为我们一开始创建的library module中的<code>AndroidManifest.xml</code>文件没有配置也不能配置启动<code>Activity</code>,所以需要在library module的<code>buld.gradle</code>脚本中添加如下脚本：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            if(isDebugLibraryModule(project.name)) &#123;</span><br><span class="line">                manifest.srcFile &apos;src/debug/AndroidManifest.xml&apos;</span><br><span class="line">                java.srcDirs = [&apos;src/debug/java&apos;, &apos;src/main/java&apos;]</span><br><span class="line">                res.srcDirs = [&apos;src/debug/res&apos;,&apos;src/main/res&apos;]</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                manifest.srcFile &apos;src/main/AndroidManifest.xml&apos;</span><br><span class="line">                resources &#123;</span><br><span class="line">                    //排除java/debug文件夹下的所有文件</span><br><span class="line">                    exclude &apos;src/debug/*&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>上面的脚本先检查当前module是否为可单独运行的library module，如果是则采用<code>src/debug/AndroidManifest.xml</code>文件。要注意的是该文件必须要包含’src/main/AndroidManifest.xml’文件的所有内容，同时还要设置启动<code>Activity</code>。</p><p>到这里，模块化开发的工程配置介绍完了，有兴趣的同学可以在这<a href="https://github.com/huyongli/AndroidModuleDesign" target="_blank" rel="noopener">https://github.com/huyongli/AndroidModuleDesign</a>查看完整代码</p><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模块化&quot;&gt;&lt;a href=&quot;#模块化&quot; class=&quot;headerlink&quot; title=&quot;模块化&quot;&gt;&lt;/a&gt;模块化&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;项目由多个模块组成&lt;/li&gt;
&lt;li&gt;每个模块都是一个独立的Feature或组件&lt;/li&gt;
&lt;li&gt;业务模块间解耦不相互直接依赖&lt;/li&gt;
&lt;li&gt;业务模块与公共组件模块通过aar依赖&lt;/li&gt;
&lt;li&gt;每个模块独立开发，独立运行调试&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;模块化的好处&quot;&gt;&lt;a href=&quot;#模块化的好处&quot; class=&quot;headerlink&quot; title=&quot;模块化的好处&quot;&gt;&lt;/a&gt;模块化的好处&lt;/h3&gt;&lt;p&gt;当一个项目越来越大，越来越复杂后，代码量就会变得越来大，难以阅读难以维护，业务之间出现耦合的可能性也会越来越大，同时整个APP编译调试的时间也会越来越长。&lt;/p&gt;
&lt;p&gt;而使用模块化开发则可以解决以上问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目代码结构清晰，每个Feature和公共组件都是一个独立的Library模块&lt;/li&gt;
&lt;li&gt;避免每个Library模块间的直接耦合&lt;/li&gt;
&lt;li&gt;提升模块的复用性&lt;/li&gt;
&lt;li&gt;单个模块独立编译调试速度更快，节省开发时间&lt;/li&gt;
&lt;li&gt;只关注自己所在的模块，从而避免其他Feature的异常block自己的Feature开发&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是…这篇文章不是教你如何进行模块化开发，而是介绍如何进行模块化开发的工程配置，以满足模块化开发过程中的多团队协作问题。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://ittiger.cn/categories/Android/"/>
    
    
      <category term="Android" scheme="http://ittiger.cn/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android中用Kotlin Coroutine(协程)和Retrofit进行网络请求和取消请求</title>
    <link href="http://ittiger.cn/Kotlin-Coroutine-For-Android-Network.html"/>
    <id>http://ittiger.cn/Kotlin-Coroutine-For-Android-Network.html</id>
    <published>2019-04-22T09:25:05.000Z</published>
    <updated>2019-05-09T14:05:03.147Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin Coroutine(协程)系列：<br><a href="http://ittiger.cn/Kotlin-Coroutine-Guide.html">1. Kotlin Coroutine(协程) 简介</a><br><a href="http://ittiger.cn/Kotlin-Coroutine-Basic-Knowledge.html">2. Kotlin Coroutine(协程) 基本知识</a><br><a href="http://ittiger.cn/Kotlin-Coroutine-For-Android-Network.html">3. Android中用Kotlin Coroutine(协程)和Retrofit进行网络请求和取消请求</a>   </p><p>前面两篇文章介绍了协程的一些基本概念和基本知识，这篇则介绍在<code>Android</code>中如何使用协程配合<code>Retrofit</code>发起网络请求，同时介绍在使用协程时如何优雅的取消已经发起的网络请求。<br><a id="more"></a><br>此篇文章的Demo地址<a href="https://github.com/huyongli/AndroidKotlinCoroutine" target="_blank" rel="noopener">：https://github.com/huyongli/AndroidKotlinCoroutine</a></p><h3 id="创建CoroutineScope"><a href="#创建CoroutineScope" class="headerlink" title="创建CoroutineScope"></a>创建CoroutineScope</h3><p>在前面的文章中我写到<code>CoroutineScope.launch</code>方法是一个很常用的协程构建器。因此使用协程必须先得创建一个<code>CoroutineScope</code>对象，代码如下：<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CoroutineScope(Dispatchers.Main + Job())</span><br></pre></td></tr></table></figure></p><p>上面的代码创建了一个<code>CoroutineScope</code>对象，为其协程指定了在主线程中执行，同时分配了一个<code>Job</code>   </p><p>在demo中我使用的是MVP模式写的，所以我将<code>CoroutineScope</code>的创建放到了<code>BasePresenter</code>中，代码如下：<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MvpView</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MvpPresenter</span>&lt;<span class="hljs-type">V: MvpView</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@UiThread</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">attachView</span><span class="hljs-params">(view: <span class="hljs-type">V</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@UiThread</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">detachView</span><span class="hljs-params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePresenter</span>&lt;<span class="hljs-type">V: MvpView</span>&gt; : <span class="hljs-type">MvpPresenter</span>&lt;<span class="hljs-type">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> view: V</span><br><span class="line">    <span class="hljs-keyword">val</span> presenterScope: CoroutineScope <span class="hljs-keyword">by</span> lazy &#123;</span><br><span class="line">        CoroutineScope(Dispatchers.Main + Job())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">attachView</span><span class="hljs-params">(view: <span class="hljs-type">V</span>)</span></span> &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.view = view</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">detachView</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        presenterScope.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用CoroutineScope-cancel-取消协程"><a href="#使用CoroutineScope-cancel-取消协程" class="headerlink" title="使用CoroutineScope.cancel()取消协程"></a>使用CoroutineScope.cancel()取消协程</h3><p>大家应该可以看到上面<code>BasePresenter.detachView</code>中调用了<code>presenterScope.cancel()</code>，那这个方法有什么作用呢，作用就是取消掉<code>presenterScope</code>创建的所有协程和其子协程。</p><p>前面的文章我也介绍过使用<code>launch</code>创建协程时会返回一个<code>Job</code>对象，通过<code>Job</code>对象的<code>cancel</code>方法也可以取消该任务对应的协程，那我这里为什么不使用这种方式呢？</p><p>很明显，如果使用<code>Job.cancel()</code>方式取消协程，那我创建每个协程的时候都必须保存返回的<code>Job</code>对象，然后再去取消，显然要更复杂点，而使用<code>CoroutineScope.cancel()</code>则可以一次性取消该协程上下文创建的所有协程和子协程，该代码也可以很方便的提取到基类中，这样后面在写业务代码时也就不用关心协程与View的生命周期的问题。</p><p>其实大家看源码的话也可以发现<code>CoroutineScope.cancel()</code>最终使用的也是<code>Job.cancel()</code>取消协程</p><h3 id="扩展Retrofit-Call适配协程"><a href="#扩展Retrofit-Call适配协程" class="headerlink" title="扩展Retrofit.Call适配协程"></a>扩展Retrofit.Call适配协程</h3><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApiService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GET(<span class="hljs-meta-string">"data/iOS/2/1"</span>)</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getIOSGank</span><span class="hljs-params">()</span></span>: Call&lt;GankResult&gt;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GET(<span class="hljs-meta-string">"data/Android/2/1"</span>)</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAndroidGank</span><span class="hljs-params">()</span></span>: Call&lt;GankResult&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiSource</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;</span><br><span class="line">        <span class="hljs-meta">@JvmField</span></span><br><span class="line">        <span class="hljs-keyword">val</span> instance = Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="hljs-string">"http://gank.io/api/"</span>)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .build().create(ApiService::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以看到上面的api接口定义应该很熟悉，我们可以通过下面的代码发起异步网络请求<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ApiSource.instance.getAndroidGank().enqueue(<span class="hljs-keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, t: <span class="hljs-type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, response: <span class="hljs-type">Response</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>前面的文章介绍过协程可以让异步代码像写同步代码那样方便，那上面这段异步代码能不能使用协程改造成类似写同步代码块那样呢？很显然是可以的，具体改造代码如下：<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//扩展Retrofit.Call类，为其扩展一个await方法，并标识为挂起函数</span></span><br><span class="line"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Call<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">await</span><span class="hljs-params">()</span></span>: T &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> suspendCoroutine &#123;</span><br><span class="line">        enqueue(<span class="hljs-keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, t: <span class="hljs-type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                <span class="hljs-comment">//请求失败，抛出异常，手动结束当前协程</span></span><br><span class="line">                it.resumeWithException(t)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, response: <span class="hljs-type">Response</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(response.isSuccessful) &#123;</span><br><span class="line">                   <span class="hljs-comment">//请求成功，将请求结果拿到并手动恢复所在协程</span></span><br><span class="line">                   it.resume(response.body()!!)</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span>&#123;</span><br><span class="line">                   <span class="hljs-comment">//请求状态异常，抛出异常，手动结束当前协程</span></span><br><span class="line">                   it.resumeWithException(Throwable(response.toString()))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码扩展了一个挂起函数<code>await</code>，执行该方法时，会执行<code>Retrofit.Call</code>的异步请求同时在协程中挂起该函数，直到异步请求成功或者出错再重新恢复所在协程。</p><h3 id="suspendCoroutine"><a href="#suspendCoroutine" class="headerlink" title="suspendCoroutine"></a>suspendCoroutine</h3><p>全局函数，此函数可以获取当前方法所在协程上下文，并将当前协程挂起，直到某个时机再重新恢复协程执行，但是这个时机其实是由开发者自己控制的，就像上面代码中的<code>it.resume</code>和<code>it.resumeWithException</code>。</p><h3 id="发起请求，写法一"><a href="#发起请求，写法一" class="headerlink" title="发起请求，写法一"></a>发起请求，写法一</h3><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//使用CoroutineScope.launch创建一个协程，此协程在主线程中执行</span></span><br><span class="line">presenterScope.launch &#123;</span><br><span class="line">    <span class="hljs-keyword">val</span> time = System.currentTimeMillis()</span><br><span class="line">    view.showLoadingView()</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">val</span> ganks = queryGanks()</span><br><span class="line">        view.showLoadingSuccessView(ganks)</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">        view.showLoadingErrorView()</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="hljs-string">"耗时：<span class="hljs-subst">$&#123;System.currentTimeMillis() - time&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">queryGanks</span><span class="hljs-params">()</span></span>: List&lt;Gank&gt; &#123;</span><br><span class="line">    <span class="hljs-comment">//此方法执行线程和调用者保持一致，因此也是在主线程中执行</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-comment">//先查询Android列表，同时当前协程执行流程挂起在此处</span></span><br><span class="line">        <span class="hljs-keyword">val</span> androidResult = ApiSource.instance.getAndroidGank().await()</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">//Android列表查询完成之后恢复当前协程，接着查询IOS列表，同时将当前协程执行流程挂起在此处</span></span><br><span class="line">        <span class="hljs-keyword">val</span> iosResult = ApiSource.instance.getIOSGank().await()</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//Android列表和IOS列表都查询结束后，恢复协程，将两者结果合并，查询结束</span></span><br><span class="line">        <span class="hljs-keyword">val</span> result = mutableListOf&lt;Gank&gt;().apply &#123;</span><br><span class="line">            addAll(iosResult.results)</span><br><span class="line">            addAll(androidResult.results)</span><br><span class="line">        &#125;</span><br><span class="line">        result</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">        <span class="hljs-comment">//处理协程中的异常，否则程序会崩掉</span></span><br><span class="line">        e.printStackTrace()</span><br><span class="line">        <span class="hljs-keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码大家可以发现，协程中对异常的处理使用的是<code>try-catch</code>的方式，初学，我也暂时只想到了这种方式。所以在使用协程时，最好在业务的适当地方使用<code>try-catch</code>捕获异常，否则一旦协程执行出现异常，程序就崩掉了。</p><p>另外上面的代码的写法还有一个问题，因为挂起函数执行时会挂起当前协程，所以上述两个请求是依次顺序执行，因此上面的<code>queryGanks()</code>方法其实是耗费了两次网络请求的时间，因为请求Android列表和请求ios列表两个请求不是并行的，所以这种写法肯定不是最优解。</p><h3 id="发起请求，写法二"><a href="#发起请求，写法二" class="headerlink" title="发起请求，写法二"></a>发起请求，写法二</h3><p>下面我们再换另外一种写法。<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">queryGanks</span><span class="hljs-params">()</span></span>: List&lt;Gank&gt; &#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 此方法执行线程和调用者保持一致，因此也在主线程中执行</span></span><br><span class="line"><span class="hljs-comment">     * 因为网络请求本身是异步请求，同时async必须在协程上下文中执行，所以此方法实现中采用withContext切换执行线程到主线程，获取协程上下文对象</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">return</span> withContext(Dispatchers.Main) &#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-comment">//在当前协程中创建一个新的协程发起Android列表请求，但是不会挂起当前协程</span></span><br><span class="line">            <span class="hljs-keyword">val</span> androidDeferred = async &#123;</span><br><span class="line">                <span class="hljs-keyword">val</span> androidResult = ApiSource.instance.getAndroidGank().await()</span><br><span class="line">                androidResult</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//发起Android列表请求后，立刻又在当前协程中创建了另外一个子协程发起ios列表请求，也不会挂起当前协程</span></span><br><span class="line">            <span class="hljs-keyword">val</span> iosDeferred = async &#123;</span><br><span class="line">                <span class="hljs-keyword">val</span> iosResult = ApiSource.instance.getIOSGank().await()</span><br><span class="line">                iosResult</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">val</span> androidResult = androidDeferred.await().results</span><br><span class="line">            <span class="hljs-keyword">val</span> iosResult = iosDeferred.await().results</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//两个列表请求并行执行，等待两个请求结束之后，将请求结果进行合并</span></span><br><span class="line">            <span class="hljs-comment">//此时当前方法的执行时间实际上两个请求中耗时时间最长的那个，而不是两个请求所耗时间的总和，因此此写法优于上面一种写法</span></span><br><span class="line">            <span class="hljs-keyword">val</span> result = mutableListOf&lt;Gank&gt;().apply &#123;</span><br><span class="line">                addAll(iosResult)</span><br><span class="line">                addAll(androidResult)</span><br><span class="line">            &#125;</span><br><span class="line">            result</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">            <span class="hljs-keyword">throw</span> e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种写法与前一种写法的区别是采用<code>async</code>构建器创建了两个子协程分别去请求Android列表和IOS列表，同时因为<code>async</code>构建器执行的时候不会挂起当前协程，所以两个请求是并行执行的，因此效率较上一个写法要高很多。</p><h3 id="发起请求，写法三"><a href="#发起请求，写法三" class="headerlink" title="发起请求，写法三"></a>发起请求，写法三</h3><p>第三个写法就是在<code>Retorfit</code>的<code>CallAdapter</code>上做文章，通过自定义实现<code>CallAdapterFactory</code>，将api定义时的结果<code>Call</code>直接转换成<code>Deferred</code>,这样就可以同时发起Android列表请求和IOS列表请求，然后通过<code>Deferred.await</code>获取请求结果，这种写法是写法一写法二的结合。</p><p>这种写法<code>JakeWharton</code>大神早已为我们实现了，地址在这<a href="https://github.com/JakeWharton/retrofit2-kotlin-coroutines-adapter" target="_blank" rel="noopener">https://github.com/JakeWharton/retrofit2-kotlin-coroutines-adapter</a></p><p>这里我就不说这种方案的具体实现了，感兴趣的同学可以去看其源码。</p><p>写法三的具体代码如下：<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">val</span> instance = Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="hljs-string">"http://gank.io/api/"</span>)</span><br><span class="line">        .addCallAdapterFactory(CoroutineCallAdapterFactory())</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .build().create(CallAdapterApiService::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span></span><br><span class="line">        </span><br><span class="line"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">queryGanks</span><span class="hljs-params">()</span></span>: List&lt;Gank&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> withContext(Dispatchers.Main) &#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">val</span> androidDeferred = ApiSource.callAdapterInstance.getAndroidGank()</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">val</span> iosDeferred = ApiSource.callAdapterInstance.getIOSGank()</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">val</span> androidResult = androidDeferred.await().results</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">val</span> iosResult = iosDeferred.await().results</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">val</span> result = mutableListOf&lt;Gank&gt;().apply &#123;</span><br><span class="line">                addAll(iosResult)</span><br><span class="line">                addAll(androidResult)</span><br><span class="line">            &#125;</span><br><span class="line">            result</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">            <span class="hljs-keyword">throw</span> e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的第三种写法看起来更简洁，也是并行请求，耗时为请求时间最长的那个请求的时间，和第二种差不多。</p><p>具体实现demo的地址见文章开头，有兴趣的可以看看。</p><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin Coroutine(协程)系列：&lt;br&gt;&lt;a href=&quot;http://ittiger.cn/Kotlin-Coroutine-Guide.html&quot;&gt;1. Kotlin Coroutine(协程) 简介&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://ittiger.cn/Kotlin-Coroutine-Basic-Knowledge.html&quot;&gt;2. Kotlin Coroutine(协程) 基本知识&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://ittiger.cn/Kotlin-Coroutine-For-Android-Network.html&quot;&gt;3. Android中用Kotlin Coroutine(协程)和Retrofit进行网络请求和取消请求&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;前面两篇文章介绍了协程的一些基本概念和基本知识，这篇则介绍在&lt;code&gt;Android&lt;/code&gt;中如何使用协程配合&lt;code&gt;Retrofit&lt;/code&gt;发起网络请求，同时介绍在使用协程时如何优雅的取消已经发起的网络请求。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://ittiger.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://ittiger.cn/tags/Kotlin/"/>
    
      <category term="Coroutine" scheme="http://ittiger.cn/tags/Coroutine/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Coroutine(协程) 基本知识</title>
    <link href="http://ittiger.cn/Kotlin-Coroutine-Basic-Knowledge.html"/>
    <id>http://ittiger.cn/Kotlin-Coroutine-Basic-Knowledge.html</id>
    <published>2019-04-14T08:41:36.000Z</published>
    <updated>2019-05-09T14:05:09.863Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin Coroutine(协程)系列：<br><a href="http://ittiger.cn/Kotlin-Coroutine-Guide.html">1. Kotlin Coroutine(协程) 简介</a><br><a href="http://ittiger.cn/Kotlin-Coroutine-Basic-Knowledge.html">2. Kotlin Coroutine(协程) 基本知识</a><br><a href="http://ittiger.cn/Kotlin-Coroutine-For-Android-Network.html">3. Android中用Kotlin Coroutine(协程)和Retrofit进行网络请求和取消请求</a><br>这篇文章主要介绍协程中的一些基本概念。</p><h3 id="挂起函数-suspend关键字"><a href="#挂起函数-suspend关键字" class="headerlink" title="挂起函数(suspend关键字)"></a>挂起函数(suspend关键字)</h3><a id="more"></a><p><code>Kotlin</code>中提供了关键字<code>suspend</code>用来描述一个函数为挂起函数，写法如下：<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//官方提供的函数</span></span><br><span class="line"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delay</span><span class="hljs-params">(timeMillis: <span class="hljs-type">Long</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上写法就代表<code>delay</code>函数为一个挂起函数。</p><p>在前面一篇文章<a href="https://blog.csdn.net/huyongl1989/article/details/89287132" target="_blank" rel="noopener">Kotlin Coroutine(协程) 简介</a>中我提到过挂起函数只会挂起当前协程，不会挂起阻塞当前协程所处的线程。事实上，想要执行协程就至少需要一个挂起函数，因此挂起函数是协程中一个非常重要的概念。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li>挂起函数能用普通函数的方式获取参数和返回值</li><li>调用挂起函数时，可能会挂起当前协程(如果挂起函数的相关调用已经有结果，那么系统可能会选择不挂起)，而不会挂起所在的线程。</li><li>挂起函数执行结束后，协程会自动恢复执行，此时才能继续执行挂起函数后续的代码</li><li>挂起函数只能在协程或其他挂起函数中调用，否则会编译报错</li><li><code>suspend</code>可以将普通函数、扩展函数、lambda表达式均标记为挂起函数</li></ol><h3 id="CoroutineScope"><a href="#CoroutineScope" class="headerlink" title="CoroutineScope"></a>CoroutineScope</h3><p>官方描述：为协程定义了一个范围</p><blockquote><p>Defines a scope for new coroutines.   </p></blockquote><p>也可以理解为协程的上下文环境，更通俗点你可以将其看作为一个协程。</p><p>我们再来看下官方源码中的定义：<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoroutineScope</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * Context of this scope.</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过这个代码我们可以看到<code>CoroutineScope</code>初始定义中只有一个协程上下文<code>CoroutineContext</code>对象，所以协程的上下文对象其实是由<code>CoroutineContext</code>决定的，因此将<code>CoroutineScope</code>看作协程更好理解。</p><h3 id="CoroutineContext"><a href="#CoroutineContext" class="headerlink" title="CoroutineContext"></a>CoroutineContext</h3><p>协程上下文，包含了协程中的一些元素，主要有<code>Job</code>和<code>CoroutineDispatcher</code></p><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>协程的后台任务，它有自己的生命周期，该任务可以被取消。   </p><p><code>Job</code>可以有父<code>Job</code>，当父<code>Job</code>被取消时，其所有子<code>Job</code>也会被取消。   </p><p><code>Job</code>有三种状态:</p><ol><li><code>isActive</code> 是否处于活动状态</li><li><code>isCompleted</code> 是否完成</li><li><code>isCancelled</code> 是否被取消</li></ol><p>可参考下表：<br><strong>State</strong> | [isActive] | [isCompleted] | [isCancelled]<br> ——————————– | ———- | ————- | ————- |<br> <em>New</em> (optional initial state)   | <code>false</code>    | <code>false</code>       | <code>false</code>       |<br> <em>Active</em> (default initial state) | <code>true</code>     | <code>false</code>       | <code>false</code>       |<br> <em>Completing</em> (transient state)   | <code>true</code>     | <code>false</code>       | <code>false</code>       |<br> <em>Cancelling</em> (transient state)   | <code>false</code>    | <code>false</code>       | <code>true</code>        |<br> <em>Cancelled</em> (final state)        | <code>false</code>    | <code>true</code>        | <code>true</code>        |<br> <em>Completed</em> (final state)        | <code>false</code>    | <code>true</code>        | <code>false</code>       |</p><p>当创建协程开始执行并获取到<code>Job</code>对象后，如果想等该协程执行结束再执行其他的业务逻辑，那么可以调用<code>Job.join()</code>方法，该方法会等待该协程任务执行结束，该方法为挂起函数。</p><h3 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred"></a>Deferred</h3><p>它是<code>Job</code>的子类，与<code>Job</code>不同的是它可以有返回值，而<code>Job</code>是没有返回值的。</p><p>通过调用<code>Deferred</code>的<code>await()</code>方法即可拿到返回值，而<code>await()</code>方法也是一个挂起函数，因此调用该方法时会挂起当前协程，直到拿到返回值协程重新恢复执行。</p><p><code>Android</code>中协程结合<code>Retrofit</code>发起网络请求可以考虑使用该类获取请求结果</p><h3 id="CoroutineDispatcher"><a href="#CoroutineDispatcher" class="headerlink" title="CoroutineDispatcher"></a>CoroutineDispatcher</h3><p>协程调度器，它可以将协程的执行局限在指定的线程中，它有四个默认的实现：</p><ol><li><code>Dispatchers.Default</code> 默认调度器，在使用<code>launch</code>和<code>async</code>等协程构造器创建协程时，如果不指定调度器则会使用此默认调度器，该调度器会让协程在<code>JVM</code>提供的共享线程池中执行</li><li><code>Dispatchers.Main</code> 主线程调度器，让协程在主线程即UI线程中执行</li><li><code>Dispatchers.IO</code> 让协程在IO线程(子线程)中执行，该调度器会与<code>Dispatchers.Default</code>调度器共享同一个线程池</li><li><code>Dispatchers.Unconfined</code> 该调度器不指定协程在某个线程中执行。设置了该调度器的协程会在调用者线程中启动执行直到第一个挂起点，挂起后，它将在挂起函数执行的线程中恢复，恢复的线程完全取决于该挂起函数在哪个线程执行。</li><li><code>newSingleThreadContext</code> 这是<code>Kotlin</code>另外提供的一个调度器，它会为协程启动一个新的线程。一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 close 函数，或存储在一个顶级变量中使它在整个应用程序中被重用。</li></ol><p>另外需要注意的是：协程调度器默认承袭外部协程的调度器。</p><h3 id="GlobalScope"><a href="#GlobalScope" class="headerlink" title="GlobalScope"></a>GlobalScope</h3><p>这是一个全局的<code>CoroutineScope</code>不会受任何Job约束，通过它创建的是全局协程，它会在整个应用的生命周期中运行，不能被取消</p><h3 id="launch函数"><a href="#launch函数" class="headerlink" title="launch函数"></a>launch函数</h3><p>这是一个扩展的<code>CoroutineScope</code>实例方法，同时也是一个很常用的协程构建器。   </p><p>通过其默认参数会创建一个不会阻塞当前线程且会立即执行的协程，该方法会返回一个<code>Job</code>对象，该方法默认承袭所在的<code>CoroutineScope</code>对象的调度器。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val scope = CoroutineScope(Dispatchers.Main + Job())</span><br><span class="line">scrope.launch &#123;</span><br><span class="line">    //协程实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码通过<code>launch</code>创建的协程会在UI线程中执行</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val scope = CoroutineScope(Dispatchers.Main + Job())</span><br><span class="line">scrope.launch(Dispatchers.IO) &#123;</span><br><span class="line">    //协程实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码通过<code>launch</code>创建的协程会在IO线程中执行</p><h3 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h3><p>这是一个全局的协程构建器，可以在任何地方调用。</p><p>该构建器会创建一个阻塞当前线程的协程，所以该构建器不建议使用在协程内。</p><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>和<code>launch</code>函数一样，也是<code>CoroutineScope</code>的扩展实例方法，它也是一个常用的协程构建器，不同是它创建协程时返回的是<code>Deferred</code>,通过<code>Deferred</code>可以拿到执行结果<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">val</span> a = async &#123;</span><br><span class="line">    log(<span class="hljs-string">"I'm computing a piece of the answer"</span>)</span><br><span class="line">    <span class="hljs-number">6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">val</span> b = async &#123;</span><br><span class="line">    log(<span class="hljs-string">"I'm computing another piece of the answer"</span>)</span><br><span class="line">    <span class="hljs-number">7</span></span><br><span class="line">&#125;</span><br><span class="line">log(<span class="hljs-string">"The answer is <span class="hljs-subst">$&#123;a.await() * b.await()&#125;</span>"</span>)</span><br></pre></td></tr></table></figure></p><h3 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h3><p>全局函数</p><ol><li>让协程休眠指定时间，类似于Java中的Thread.sleep的作用</li><li>delay是一个挂起函数，调用后不会阻塞挂起当前线程</li><li>当协程的休眠时间到了之后，当前所处协程会重新恢复执行</li></ol><h3 id="withContext"><a href="#withContext" class="headerlink" title="withContext"></a>withContext</h3><p>切换协程上下文，一般主要用来切换协程所在的线程环境，如从主线程切换到IO线程。</p><p>调用该方法不会创建新的协程，同时是一个挂起函数</p><p>该方法会有一个返回值，其返回值为<code>withContext</code>中lambda表达式的返回值</p><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin Coroutine(协程)系列：&lt;br&gt;&lt;a href=&quot;http://ittiger.cn/Kotlin-Coroutine-Guide.html&quot;&gt;1. Kotlin Coroutine(协程) 简介&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://ittiger.cn/Kotlin-Coroutine-Basic-Knowledge.html&quot;&gt;2. Kotlin Coroutine(协程) 基本知识&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://ittiger.cn/Kotlin-Coroutine-For-Android-Network.html&quot;&gt;3. Android中用Kotlin Coroutine(协程)和Retrofit进行网络请求和取消请求&lt;/a&gt;&lt;br&gt;这篇文章主要介绍协程中的一些基本概念。&lt;/p&gt;
&lt;h3 id=&quot;挂起函数-suspend关键字&quot;&gt;&lt;a href=&quot;#挂起函数-suspend关键字&quot; class=&quot;headerlink&quot; title=&quot;挂起函数(suspend关键字)&quot;&gt;&lt;/a&gt;挂起函数(suspend关键字)&lt;/h3&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://ittiger.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://ittiger.cn/tags/Kotlin/"/>
    
      <category term="Coroutine" scheme="http://ittiger.cn/tags/Coroutine/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Coroutine(协程) 简介</title>
    <link href="http://ittiger.cn/Kotlin-Coroutine-Guide.html"/>
    <id>http://ittiger.cn/Kotlin-Coroutine-Guide.html</id>
    <published>2019-04-13T11:07:19.000Z</published>
    <updated>2019-05-09T14:04:49.167Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin Coroutine(协程)系列：<br><a href="http://ittiger.cn/Kotlin-Coroutine-Guide.html">1. Kotlin Coroutine(协程) 简介</a><br><a href="http://ittiger.cn/Kotlin-Coroutine-Basic-Knowledge.html">2. Kotlin Coroutine(协程) 基本知识</a><br><a href="http://ittiger.cn/Kotlin-Coroutine-For-Android-Network.html">3. Android中用Kotlin Coroutine(协程)和Retrofit进行网络请求和取消请求</a>   </p><h3 id="协程介绍"><a href="#协程介绍" class="headerlink" title="协程介绍"></a>协程介绍</h3><a id="more"></a><p>协程是可挂起计算的实例。</p><p>它在概念上类似于线程，在这个意义上，它需要一个代码块运行，并具有类似的生命周期，它可以被创建和启动，但它不绑定到任何特定的线程。</p><p>它可以在一个线程中挂起其执行，并在另一个线程中恢复。而且，像future 或 promise那样，它在完结时可能伴随着某种结果（值或异常）</p><p>协程开发人员这样描述协程：</p><blockquote><p>协程就像非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。</p></blockquote><p>如上面所说，协程是由开发者自己控制的，因此在使用协程时我们一定要记住一点，我们必须知道我们使用的协程在何时挂起，它又在何时重新恢复执行，如果没法知道这两点，那就意味着我们无法控制协程，这个时候要慎用协程。   </p><h3 id="为什么使用协程"><a href="#为什么使用协程" class="headerlink" title="为什么使用协程"></a>为什么使用协程</h3><h5 id="使用协程可以提高线程的利用率。"><a href="#使用协程可以提高线程的利用率。" class="headerlink" title="使用协程可以提高线程的利用率。"></a>使用协程可以提高线程的利用率。</h5><p>通常我们在<code>Android</code>中发起一个网络请求都会经历如下几步：</p><ol><li>在主线程中创建一个请求任务，如：<code>Retrofit.Call</code></li><li>为这个任务分配一个子线程去执行请求任务，如：调用<code>Retrofit.Call.enqueue(callback)</code>方法</li><li>子线程发起请求后将会阻塞等待网络请求的返回结果，拿到结果后会将数据转换成我们需要的实体对象</li><li>在主线程中执行回调接口，执行余下的业务操作   </li></ol><p>上面的流程中为请求任务分配子线程一般都会配合线程池去做，以防止不断创建线程而产生系统开销，但在线程真正执行过程中经常会遇到因磁盘IO或者是网络请求等操作而导致线程阻塞，而此时当前线程只能阻塞等待，无法做任何事情，在等待的这段时间里线程相当于白白了浪费了自身资源，导致线程自身利用率低下。</p><p>在<code>Android</code>中改用协程发起网络请求流程如下：</p><ol><li>在主线程中创建一个协程，在协程中创建网络请求任务</li><li>为协程分配一个子线程去发起网络请求</li><li>挂起子线程中的协程，此时仅仅是协程挂起，该子线程并没有挂起阻塞</li><li>协程等待请求结果回来之后，会在子线程中重新恢复协程执行</li><li>在主线程中执行某个回调，拿到请求数据执行余下的业务操作</li></ol><p>在上述流程步骤3中挂起协程后子线程并不会阻塞，此时该子线程可以被系统分配去做其他的事情，当协程挂起结束时重新在子线程中恢复执行。这样该线程就不会存在因阻塞导致的空闲浪费，提高了线程利用率。</p><p><strong>总的来说，使用协程可以最大程度的复用线程，通过让线程满载运行，从而达到充分的利用CPU提高系统性能。</strong></p><h5 id="告别回调地狱"><a href="#告别回调地狱" class="headerlink" title="告别回调地狱"></a>告别回调地狱</h5><p>使用协程另外一个好处就是可以让开发者们告别异步编程中的回调地狱，简化异步编程，让写异步代码和写同步代码一样简单，增强了代码的可读性、可理解性和可维护性。</p><p><strong>举个例子</strong><br>假定有个登录有如下流程：</p><ol><li>发请求获取用户token</li><li>根据token获取用户信息</li></ol><p>常用实现方式代码如下：<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">login</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    requestToken &#123; token -&gt;</span><br><span class="line">        requestUserInfo(token) &#123; user -&gt;</span><br><span class="line">            Log.i(<span class="hljs-string">"tag"</span>, user.toString())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的例子是<code>Android</code>开发中经常会遇到的问题，一个请求依赖前一个请求的结果，这个时候经常会出现这样的写法，在第一个请求的成功回调中根据请求结果发起第二个网络请求。这里还只存在两层的嵌套，试想一下，如果嵌套层次出现4次，5次，甚至更多会出现怎样的情况，估计开发者自己写起来都会崩溃。</p><p>使用RxJava实现代码如下：<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Single.fromCallable &#123; requestToken() &#125;</span><br><span class="line">    .map &#123; token -&gt; requestUserInfo(tokenm) &#125;</span><br><span class="line">    .subscribe(</span><br><span class="line">        &#123; user -&gt; Log.i(<span class="hljs-string">"tag"</span>, user.toString()) &#125;, <span class="hljs-comment">// onSuccess</span></span><br><span class="line">        &#123; e -&gt; e.printStackTrace() &#125;  <span class="hljs-comment">// onError</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p><p>使用<code>RxJava</code>的实现方式虽然将回调嵌套改成了链式写法，阅读起来要稍微好点，但是依然存在回调而且增加了实现的复杂度，对不熟悉<code>RxJava</code>的人来说更少增加了难度。</p><p>使用协程实现方式代码如下：<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">login</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">val</span> token = requestToken()</span><br><span class="line">    <span class="hljs-keyword">val</span> user = requestUserInfo(token)</span><br><span class="line">    Log.i(<span class="hljs-string">"tag"</span>, user.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>怎么样，使用协程的写法是不是简便很多，而且看起来非常符合人们的阅读和理解习惯。</p><h3 id="Android中使用协程示例"><a href="#Android中使用协程示例" class="headerlink" title="Android中使用协程示例"></a>Android中使用协程示例</h3><p>自己写了一个<code>Android</code>使用协程配合<code>Retrofit</code>发起网络请求的<code>Demo</code>，主要包含了如下内容：   </p><ol><li>如何将Kotlin Coroutine(协程)和Retrofit结合使用</li><li>如何在Kotlin Coroutine(协程)切换协程所在线程</li><li>如何在Kotlin Coroutine(协程)中将两个请求结果进行合并</li><li>Kotlin Coroutine(协程)中如何实现并发请求</li><li>MVP开发模式中如何在Presenter生命周期结束时优雅的取消协程</li><li>如何将一个普通异步操作改造为协程中的挂起函数</li></ol><p>代码地址：<a href="https://github.com/huyongli/AndroidKotlinCoroutine" target="_blank" rel="noopener">https://github.com/huyongli/AndroidKotlinCoroutine</a></p><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin Coroutine(协程)系列：&lt;br&gt;&lt;a href=&quot;http://ittiger.cn/Kotlin-Coroutine-Guide.html&quot;&gt;1. Kotlin Coroutine(协程) 简介&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://ittiger.cn/Kotlin-Coroutine-Basic-Knowledge.html&quot;&gt;2. Kotlin Coroutine(协程) 基本知识&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://ittiger.cn/Kotlin-Coroutine-For-Android-Network.html&quot;&gt;3. Android中用Kotlin Coroutine(协程)和Retrofit进行网络请求和取消请求&lt;/a&gt;   &lt;/p&gt;
&lt;h3 id=&quot;协程介绍&quot;&gt;&lt;a href=&quot;#协程介绍&quot; class=&quot;headerlink&quot; title=&quot;协程介绍&quot;&gt;&lt;/a&gt;协程介绍&lt;/h3&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://ittiger.cn/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://ittiger.cn/tags/Kotlin/"/>
    
      <category term="Coroutine" scheme="http://ittiger.cn/tags/Coroutine/"/>
    
  </entry>
  
  <entry>
    <title>Flutter实战之封装一个LinearLayout</title>
    <link href="http://ittiger.cn/Flutter-For-LinearLayout.html"/>
    <id>http://ittiger.cn/Flutter-For-LinearLayout.html</id>
    <published>2018-11-05T07:03:57.000Z</published>
    <updated>2019-05-09T13:54:24.848Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>在<code>APP</code>开发过程中，经常遇到需要添加背景、设置边距、动态显示和隐藏某个组件。 </p><p>但是在<code>Flutter</code>中，能同时具有添加背景、设置边距、阴影、边框、圆角的布局只有<code>Container</code>(参考我上一篇文章的介绍<a href="https://blog.csdn.net/huyongl1989/article/details/83745871" target="_blank" rel="noopener">Flutter入门之Row、Column、Container布局</a>)，这个已经算是业务功能比较多的组件了，而要想实现组件的显示和隐藏则需要用到另外一个组件<code>Offstage</code>，水平的线性布局则需要用到组件<code>Row</code>，垂直的线性布局则需要用到组件<code>Column</code>，而<code>Row</code>和<code>Column</code>这两个布局都不具备直接设置背景、边距、显示和隐藏等功能。<br><a id="more"></a><br>在开发过程中这种需求又很常见，不可能每个地方都把这些代码重复一遍，所以对这几个组件封装一下，实现了一个类似<code>Android</code>中<code>LinearLayout</code>布局的组件很有必要。</p><h3 id="封装LinearLayout"><a href="#封装LinearLayout" class="headerlink" title="封装LinearLayout"></a>封装LinearLayout</h3><p>封装成<code>LinearLayout</code>其实很简单，就是将<code>Row</code>、<code>Column</code>、<code>Offstage</code>、<code>Container</code>四个组件合理的组合在一起就可以了。</p><ol><li>首先要暴露一个参数确定是水平的线性布局还是垂直的线性布局</li><li>将<code>Container</code>经常用到的背景、边距参数暴露出来</li><li>将<code>Row</code>、<code>Column</code>中用到的主轴、交叉轴的对齐方式暴露出来</li><li>将<code>Row</code>、<code>Column</code>中主轴size的适配方式暴露出来</li><li>暴露出一个方法用来动态改变组件的显示和隐藏</li></ol><p>代码如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line">import &apos;package:flutter_library/common/util.dart&apos;;</span><br><span class="line"></span><br><span class="line">enum LayoutOrientation &#123; horizontal, vertical &#125;</span><br><span class="line"></span><br><span class="line">class LinearLayout extends StatefulWidget &#123;</span><br><span class="line">  final LayoutOrientation orientation;</span><br><span class="line">  final bool isVisible;</span><br><span class="line">  final Decoration background;</span><br><span class="line">  final EdgeInsetsGeometry padding;</span><br><span class="line">  final EdgeInsetsGeometry margin;</span><br><span class="line">  final List&lt;Widget&gt; children;</span><br><span class="line"></span><br><span class="line">  final MainAxisAlignment mainAxisAlignment;</span><br><span class="line">  final MainAxisSize mainAxisSize;</span><br><span class="line">  final CrossAxisAlignment crossAxisAlignment;</span><br><span class="line"></span><br><span class="line">  LinearLayout(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    this.orientation,</span><br><span class="line">    this.isVisible = true,</span><br><span class="line">    this.background,</span><br><span class="line">    this.padding,</span><br><span class="line">    this.margin,</span><br><span class="line">    this.children = const &lt;Widget&gt;[],</span><br><span class="line">    this.mainAxisAlignment = MainAxisAlignment.start,</span><br><span class="line">    this.mainAxisSize = MainAxisSize.min,</span><br><span class="line">    this.crossAxisAlignment = CrossAxisAlignment.center,</span><br><span class="line">  &#125;) : super(key: key);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  LinearLayoutState createState() &#123;</span><br><span class="line">    return LinearLayoutState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LinearLayoutState extends State&lt;LinearLayout&gt; &#123;</span><br><span class="line">  bool _isVisible = true;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    _isVisible = widget.isVisible;</span><br><span class="line">    super.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return isNotNull(_isVisible)</span><br><span class="line">        ? Offstage(</span><br><span class="line">            offstage: !_isVisible,</span><br><span class="line">            child: _buildLayoutWidget(),</span><br><span class="line">          )</span><br><span class="line">        : _buildLayoutWidget();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _buildLayoutWidget() &#123;</span><br><span class="line">    if (_isNeedContainerWidget()) &#123;</span><br><span class="line">      return _buildContainerWidget();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return _buildOrientationWidget();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool _isNeedContainerWidget() &#123;</span><br><span class="line">    return isNotNull(widget.background) ||</span><br><span class="line">        isNotNull(widget.padding) ||</span><br><span class="line">        isNotNull(widget.margin);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _buildContainerWidget() &#123;</span><br><span class="line">    return Container(</span><br><span class="line">      decoration: widget.background,</span><br><span class="line">      padding: widget.padding,</span><br><span class="line">      margin: widget.margin,</span><br><span class="line">      child: _buildOrientationWidget(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _buildOrientationWidget() &#123;</span><br><span class="line">    if (widget.orientation == LayoutOrientation.horizontal) &#123;</span><br><span class="line">      return _buildHorizontalWidget();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return _buildVerticalWidget();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _buildVerticalWidget() &#123;</span><br><span class="line">    return Column(</span><br><span class="line">      mainAxisSize: widget.mainAxisSize,</span><br><span class="line">      mainAxisAlignment: widget.mainAxisAlignment,</span><br><span class="line">      crossAxisAlignment: widget.crossAxisAlignment,</span><br><span class="line">      children: widget.children,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _buildHorizontalWidget() &#123;</span><br><span class="line">    return Row(</span><br><span class="line">      mainAxisSize: widget.mainAxisSize,</span><br><span class="line">      mainAxisAlignment: widget.mainAxisAlignment,</span><br><span class="line">      crossAxisAlignment: widget.crossAxisAlignment,</span><br><span class="line">      children: widget.children,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool isVisible() &#123;</span><br><span class="line">    return _isVisible;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void setVisible(bool isVisible) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _isVisible = isVisible;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>package:flutter_library/common/util.dart文件代码如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool isNull(dynamic obj) &#123;</span><br><span class="line">  return obj == null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isNotNull(dynamic obj) &#123;</span><br><span class="line">  return obj != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="LinearLayout使用"><a href="#LinearLayout使用" class="headerlink" title="LinearLayout使用"></a>LinearLayout使用</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class LinearLayoutSampleWidget extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    return LinearLayoutSampleState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LinearLayoutSampleState extends State&lt;LinearLayoutSampleWidget&gt; &#123;</span><br><span class="line">  GlobalKey&lt;LinearLayoutState&gt; _key = GlobalKey&lt;LinearLayoutState&gt;();</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(&apos;LinearLayout Sample&apos;),</span><br><span class="line">      ),</span><br><span class="line">      body:</span><br><span class="line">        LinearLayout(</span><br><span class="line">          background: BoxDecoration(color: Colors.blue),</span><br><span class="line">          orientation: LayoutOrientation.vertical,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            LinearLayout(</span><br><span class="line">              key: _key,</span><br><span class="line">              background: BoxDecoration(color: Colors.red),</span><br><span class="line">              orientation: LayoutOrientation.horizontal,</span><br><span class="line">              mainAxisSize: MainAxisSize.min,</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                Icon(Icons.list),</span><br><span class="line">                Text(&apos;线性布局&apos;)</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">            FlatButton(</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                bool isVisible = _key.currentState.isVisible();</span><br><span class="line">                _key.currentState.setVisible(!isVisible);</span><br><span class="line">              &#125;,</span><br><span class="line">              child: Text(&apos;切换显示&apos;),</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        )  </span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重点说一下Demo中的<code>GlobalKey&lt;LinearLayoutState&gt; _key = GlobalKey&lt;LinearLayoutState&gt;()</code>这段代码，这个就是用来给<code>LinearLayout</code>设定一个唯一标识符，这样才能在后面点击按钮的时候调用<code>setVisible</code>方法来显示和隐藏。而泛型<code>LinearLayoutState</code>则是我封装的代码中的一个类，因为我的<code>setVisible</code>方法暴露在此State中。</p><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;APP&lt;/code&gt;开发过程中，经常遇到需要添加背景、设置边距、动态显示和隐藏某个组件。 &lt;/p&gt;
&lt;p&gt;但是在&lt;code&gt;Flutter&lt;/code&gt;中，能同时具有添加背景、设置边距、阴影、边框、圆角的布局只有&lt;code&gt;Container&lt;/code&gt;(参考我上一篇文章的介绍&lt;a href=&quot;https://blog.csdn.net/huyongl1989/article/details/83745871&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flutter入门之Row、Column、Container布局&lt;/a&gt;)，这个已经算是业务功能比较多的组件了，而要想实现组件的显示和隐藏则需要用到另外一个组件&lt;code&gt;Offstage&lt;/code&gt;，水平的线性布局则需要用到组件&lt;code&gt;Row&lt;/code&gt;，垂直的线性布局则需要用到组件&lt;code&gt;Column&lt;/code&gt;，而&lt;code&gt;Row&lt;/code&gt;和&lt;code&gt;Column&lt;/code&gt;这两个布局都不具备直接设置背景、边距、显示和隐藏等功能。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://ittiger.cn/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://ittiger.cn/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门之Row、Column、Container布局</title>
    <link href="http://ittiger.cn/Flutter-Row-Column-Container.html"/>
    <id>http://ittiger.cn/Flutter-Row-Column-Container.html</id>
    <published>2018-11-05T03:21:17.000Z</published>
    <updated>2019-05-09T13:52:51.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>写过<code>Android</code>的都知道<code>Android</code>中有个很常用布局<code>LinearLayout</code>，它可以实现线性的横向或纵向的布局结构。对于学习<code>Flutter</code>的<code>Android</code>开发者来说，肯定也想知道<code>Flutter</code>中该如何实现线性布局结构。</p><p>在<code>Flutter</code>中线性布局结构的实现是通过两个不同的<code>widget</code>分别来实现横向和纵向布局结构的。组件<code>Row</code>用来实现横向的线性布局，而组件<code>Column</code>则用来实现纵向的线性布局，而<code>Container</code>则是用来设置背景、设置大小、设置边距(padding)的布局。<br><a id="more"></a><br>下面来分别介绍三个组件的相关属性：</p><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p><code>Container</code>的构造函数如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Container(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    this.alignment,</span><br><span class="line">    this.padding,</span><br><span class="line">    Color color,</span><br><span class="line">    Decoration decoration,</span><br><span class="line">    this.foregroundDecoration,</span><br><span class="line">    double width,</span><br><span class="line">    double height,</span><br><span class="line">    BoxConstraints constraints,</span><br><span class="line">    this.margin,</span><br><span class="line">    this.transform,</span><br><span class="line">    this.child,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ol><li><code>key</code>: 该属性代表当前<code>widget</code>的唯一标识符(类似于<code>Android</code>中的id)，在程序运行过程中，如果想调用该<code>widget</code>的某个方法，那就需要设置该属性值，该属性不是必须值</li><li><code>alignment</code>: 子元素的对齐方式，官方已经提供了几种常用的对齐方式</li><li><code>padding</code>: 这个比较好理解，跟<code>Android</code>中的是一个意思，内边距</li><li><code>color</code>: 设置组件的背景色</li><li><code>decoration</code>: 与<code>color</code>属性功能一样，都是设置背景，不过<code>decoration</code>功能更强大，它可以设置背景图片、圆角、渐变、阴影、边框等</li><li><code>width</code> &amp; <code>height</code>: 组件的宽高</li><li><code>constraints</code>: 组件的宽高限制</li><li><code>margin</code>: 外边距</li><li><code>transform</code>: 矩阵转换</li><li><code>child</code>: 子元素</li></ol><p>另外在使用过程中，<code>Container</code>如果作为应用的根节点的话，它的宽高会自动填充为屏幕大小。</p><h3 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h3><p><code>Row</code>的构造函数如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Row(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,</span><br><span class="line">    MainAxisSize mainAxisSize = MainAxisSize.max,</span><br><span class="line">    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,</span><br><span class="line">    TextDirection textDirection,</span><br><span class="line">    VerticalDirection verticalDirection = VerticalDirection.down,</span><br><span class="line">    TextBaseline textBaseline,</span><br><span class="line">    List&lt;Widget&gt; children = const &lt;Widget&gt;[],</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><h4 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h4><ol><li><code>key</code>: 该属性代表当前<code>widget</code>的唯一标识符(类似于<code>Android</code>中的id)，在程序运行过程中，如果想调用该<code>widget</code>的某个方法，那就需要设置该属性值，该属性不是必须值</li><li><code>mainAxisAlignment</code>: 子元素在主轴的对齐方式，<code>Row</code>的主轴即为水平方向</li><li><code>mainAxisSize</code>: 主轴方向大小适配方式，只有两种取值方式：<ul><li><code>MainAxisSize.max</code> 主轴方向大小(在<code>Row</code>中指宽度)与父容器大小相同(即<code>Android</code>中的<code>match_parent</code>)</li><li><code>MainAxisSize.min</code> 主轴方向大小(在<code>Row</code>中指宽度)由子元素决定(即<code>Android</code>中的<code>wrap_content</code>)</li></ul></li><li><code>crossAxisAlignment</code>: 子元素在交叉轴(垂直方向)的对齐方式</li><li><code>children</code>: 子元素列表</li></ol><h3 id="Column"><a href="#Column" class="headerlink" title="Column"></a>Column</h3><p><code>Column</code>的构造函数<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Column(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,</span><br><span class="line">    MainAxisSize mainAxisSize = MainAxisSize.max,</span><br><span class="line">    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,</span><br><span class="line">    TextDirection textDirection,</span><br><span class="line">    VerticalDirection verticalDirection = VerticalDirection.down,</span><br><span class="line">    TextBaseline textBaseline,</span><br><span class="line">    List&lt;Widget&gt; children = const &lt;Widget&gt;[],</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><h4 id="关键属性-1"><a href="#关键属性-1" class="headerlink" title="关键属性"></a>关键属性</h4><ol><li><code>key</code>: 该属性代表当前<code>widget</code>的唯一标识符(类似于<code>Android</code>中的id)，在程序运行过程中，如果想调用该<code>widget</code>的某个方法，那就需要设置该属性值，该属性不是必须值</li><li><code>mainAxisAlignment</code>: 子元素在主轴的对齐方式，<code>Column</code>的主轴即为垂直方向</li><li><code>mainAxisSize</code>: 主轴方向大小适配方式，只有两种取值方式：<ul><li><code>MainAxisSize.max</code> 主轴方向大小(在<code>Column</code>中指高度)与父容器大小相同(即<code>Android</code>中的<code>match_parent</code>)</li><li><code>MainAxisSize.min</code> 主轴方向大小(在<code>Column</code>中指高度)由子元素决定(即<code>Android</code>中的<code>wrap_content</code>)</li></ul></li><li><code>crossAxisAlignment</code>: 子元素在交叉轴(水平方向)的对齐方式</li><li><code>children</code>: 子元素列表</li></ol><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h3&gt;&lt;p&gt;写过&lt;code&gt;Android&lt;/code&gt;的都知道&lt;code&gt;Android&lt;/code&gt;中有个很常用布局&lt;code&gt;LinearLayout&lt;/code&gt;，它可以实现线性的横向或纵向的布局结构。对于学习&lt;code&gt;Flutter&lt;/code&gt;的&lt;code&gt;Android&lt;/code&gt;开发者来说，肯定也想知道&lt;code&gt;Flutter&lt;/code&gt;中该如何实现线性布局结构。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Flutter&lt;/code&gt;中线性布局结构的实现是通过两个不同的&lt;code&gt;widget&lt;/code&gt;分别来实现横向和纵向布局结构的。组件&lt;code&gt;Row&lt;/code&gt;用来实现横向的线性布局，而组件&lt;code&gt;Column&lt;/code&gt;则用来实现纵向的线性布局，而&lt;code&gt;Container&lt;/code&gt;则是用来设置背景、设置大小、设置边距(padding)的布局。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://ittiger.cn/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://ittiger.cn/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter实战之Gank Demo实践</title>
    <link href="http://ittiger.cn/Flutter-Gank-Demo.html"/>
    <id>http://ittiger.cn/Flutter-Gank-Demo.html</id>
    <published>2018-11-02T06:47:38.000Z</published>
    <updated>2019-05-09T13:51:28.850Z</updated>
    
    <content type="html"><![CDATA[<p>初学Flutter，看了两天文档，花了两天时间利用gank.io提供的api接口实践了下Flutter，写了个Demo.</p><p>主要实践了Flutter的如下几个知识点：<br><a id="more"></a></p><ol><li>如何使用<code>dio</code>框架发起网络请求</li><li>如何实现常用布局，如：<ul><li>水平布局: <code>Row</code></li><li>垂直布局: <code>Column</code></li><li>层叠布局: <code>Stack</code></li><li>如何设置间距: <code>Padding</code></li></ul></li><li>如何显示网络图片<code>Image</code></li><li>如何使用下拉刷新组件: <code>RefreshIndicator</code></li><li>如何使用<code>ListView</code>组件，以及添加上拉加载更多功能</li><li>如何给普通<code>widget</code>添加事件监听: <code>GestureDetector</code></li><li>如何实现水波纹效果: <code>InkWell</code></li><li>如何使用<code>Card</code>实现卡片式布局</li><li>在Flutter中如何使用<code>WebView</code></li><li>如何创建<code>Material Design</code>风格的应用以及自定义其主题样式</li><li>如何使用<code>AppBar</code>组件同时给其添加<code>TabBarView</code>组件和<code>BottomNavigationBar</code></li><li>如何进行页面跳转: <code>Navigator</code></li></ol><p>Demo代码地址<a href="https://github.com/huyongli/FlutterGank" target="_blank" rel="noopener">请戳这这这</a></p><p>Demo效果如如下：<br><img src="/img/Flutter/gank-demo1" width="240" height="480" alt><img src="/img/Flutter/gank-demo2" width="240" height="480" alt><br><img src="/img/Flutter/gank-demo3" width="240" height="480" alt><img src="/img/Flutter/gank-demo4" width="240" height="480" alt></p><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初学Flutter，看了两天文档，花了两天时间利用gank.io提供的api接口实践了下Flutter，写了个Demo.&lt;/p&gt;
&lt;p&gt;主要实践了Flutter的如下几个知识点：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://ittiger.cn/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://ittiger.cn/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入门之Could not find lint-gradle-api.jar</title>
    <link href="http://ittiger.cn/Flutter-For-Start-Build-Error.html"/>
    <id>http://ittiger.cn/Flutter-For-Start-Build-Error.html</id>
    <published>2018-11-02T02:35:30.000Z</published>
    <updated>2019-05-09T13:47:22.209Z</updated>
    
    <content type="html"><![CDATA[<p>这两天在学习<code>Flutter</code>，学习过程中尝试着写了个Demo，然后在Android平台运行想看下效果，结果直接<code>gradle</code>都没过，错误提示如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Where: Build file &apos;PROJECTPATH/android/app/build.gradle&apos; line: 25</span><br><span class="line">What went wrong: A problem occurred evaluating project &apos;:app&apos;.</span><br><span class="line">Could not resolve all files for configuration &apos;classpath&apos;. Could not find lint-gradle-api.jar (com.android.tools.lint:lint-gradle-api:26.1.2). Searched in the following locations: https://jcenter.bintray.com/com/android/tools/lint/lint-gradle-api/26.1.2/lint-gradle-api-26.1.2.jar</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>看到这个错误第一反应是这个库在仓库里没找到，然后看了下Android工程根目录下的<code>build.gradle</code>文件，其配置如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我又给了加了个<code>mavenCentral()</code>，结果运行依旧是这个错误，而且我的网络是没有任何问题的。</p><p>前面的方式无法解决后，就在<code>flutter</code>的github里的issue中看了半天，然后发了一种说法：</p><blockquote><p>在你的flutter安装目录下找到文件：flutter/packages/flutter_tools/gradle/flutter.gradle</p></blockquote><p>打开该文件将文件中如下脚本内容：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    maven &#123;</span><br><span class="line">        url &apos;https://dl.google.com/dl/android/maven2&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改成：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        url &apos;https://dl.google.com/dl/android/maven2&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就是将maven和jcenter调换一个顺序。</p><p>我使用这种方式解决了编译错误的问题，当然还有个前提条件是你的网络可以成功访问google。我没有试过国内网络的环境，不过按照这种方式国内网络环境可以将仓库地址改为国内镜像地址，至于具体镜像地址，大家可以在网上找。</p><p>我代码中使用的flutter版本为：<code>sdk: &quot;&gt;=2.0.0-dev.68.0 &lt;3.0.0&quot;</code></p><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天在学习&lt;code&gt;Flutter&lt;/code&gt;，学习过程中尝试着写了个Demo，然后在Android平台运行想看下效果，结果直接&lt;code&gt;gradle&lt;/code&gt;都没过，错误提示如下：&lt;br&gt;&lt;figure class=&quot;highlight plain hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Where: Build file &amp;apos;PROJECTPATH/android/app/build.gradle&amp;apos; line: 25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;What went wrong: A problem occurred evaluating project &amp;apos;:app&amp;apos;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Could not resolve all files for configuration &amp;apos;classpath&amp;apos;. Could not find lint-gradle-api.jar (com.android.tools.lint:lint-gradle-api:26.1.2). Searched in the following locations: https://jcenter.bintray.com/com/android/tools/lint/lint-gradle-api/26.1.2/lint-gradle-api-26.1.2.jar&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Flutter" scheme="http://ittiger.cn/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="http://ittiger.cn/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>多线程之：Synchronized与ReentrantLock</title>
    <link href="http://ittiger.cn/Java-Synchronized-ReentrantLock.html"/>
    <id>http://ittiger.cn/Java-Synchronized-ReentrantLock.html</id>
    <published>2018-10-26T03:17:44.000Z</published>
    <updated>2019-05-09T14:07:50.446Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><ol><li>保证多线程环境下共享的、可修改的状态的正确性。(这里的状态在程序中可以看作为数据)</li><li>反着来说则是如果状态非共享、不可修改，也就不存在线程安全的问题<a id="more"></a><h3 id="保证线程安全的两种方法"><a href="#保证线程安全的两种方法" class="headerlink" title="保证线程安全的两种方法"></a>保证线程安全的两种方法</h3></li><li><strong>封装</strong>，通过封装将对象内部状态隐藏、保护起来</li><li><strong>不可变</strong>，将状态改为不可变,例如将状态定义为<code>final</code></li></ol><h3 id="线程安全要保证的基本特性"><a href="#线程安全要保证的基本特性" class="headerlink" title="线程安全要保证的基本特性"></a>线程安全要保证的基本特性</h3><ol><li><strong>原子性</strong><br> 相关操作不会在中途被其他线程所干扰，一般通过同步机制实现</li><li><strong>可见性</strong><br> 一个行程修改了某个共享变量，其新状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的</li><li><strong>有序性</strong><br>  保证线程内串行语义，避免指令重排</li></ol><h3 id="Synchronized与ReentrantLock"><a href="#Synchronized与ReentrantLock" class="headerlink" title="Synchronized与ReentrantLock"></a>Synchronized与ReentrantLock</h3><h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><p><code>synchronized</code>可以很方便的解决多线程间资源共享同步的问题，也就是我们平常所说的线程安全问题。   </p><p>它可以修饰方法和代码块，无法是用作何种修饰，<code>synchronized</code>获取的锁都是对象。</p><p>关于<code>synchronized</code>的使用这里就不说了。</p><h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><p><code>ReentrantLock</code>一般称为再入锁,是Lock的实现类，是一个互斥的同步器。</p><p>再入锁通过代码直接调用 <code>lock()</code> 方法获取，代码书写也更加灵活。同时<code>ReentrantLock</code> 提供了很多实用的方法，能够实现很多<code>synchronized</code> 无法做到的细节控制，比如可以控制 fairness，也就是公平性，或者利用条件定义等。</p><p>但是，编码中也需要注意，必须要明确调用 unlock() 方法释放，不然就会一直持有该锁。</p><h6 id="条件变量-Condition"><a href="#条件变量-Condition" class="headerlink" title="条件变量(Condition)"></a>条件变量(Condition)</h6><p><code>ReentrantLock</code>配合条件变量（<code>java.util.concurrent.locks.Condition</code>），可以将复杂而晦涩的同步操作转变为直观可控的对象行为。</p><p>条件变量最为典型的应用场景就是标准类库中的 <code>ArrayBlockingQueue</code>等，看下源码：</p><p>通过再入锁获取条件变量:<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/** Condition for waiting puts */</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity, <span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();</span><br><span class="line"><span class="hljs-keyword">this</span>.items = <span class="hljs-keyword">new</span> Object[capacity];</span><br><span class="line">lock = <span class="hljs-keyword">new</span> ReentrantLock(fair);</span><br><span class="line">notEmpty = lock.newCondition();</span><br><span class="line">notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个条件变量是从<strong>同一再入锁</strong>创建出来，然后使用在特定操作中，如下面的 take 方法，判断和等待条件满足:<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;</span><br><span class="line">lock.lockInterruptibly();</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)</span><br><span class="line">        notEmpty.await();</span><br><span class="line">    <span class="hljs-keyword">return</span> dequeue();</span><br><span class="line">&#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当队列为空时，试图take获取元素的线程会等待其他元素入队操作的发生，而不是直接返回，这是 BlockingQueue 的语义，使用条件 notEmpty 就可以优雅地实现这一逻辑。</p><p>那么，怎么保证入队触发后续 take 操作呢？请看 enqueue 实现：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">this</span>.items;</span><br><span class="line">items[putIndex] = e;</span><br><span class="line"><span class="hljs-keyword">if</span> (++putIndex == items.length) putIndex = <span class="hljs-number">0</span>;</span><br><span class="line">count++;</span><br><span class="line">notEmpty.signal(); <span class="hljs-comment">// 通知等待的线程，非空条件已经满足</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 signal/await 的组合，完成了条件判断和通知等待线程，非常顺畅就完成了状态流转。注意，signal 和 await 成对调用非常重要，不然假设只有 await 动作，线程会一直等待直到被打断（interrupt）</p><h5 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h5><p><code>synchronized</code> 和 <code>ReentrantLock</code> 的性能不能一概而论，早期版本 <code>synchronized</code> 在很多场景下性能相差较大，在后续版本进行了较多改进。</p><p>在低竞争场景中<code>synchronized</code>表现可能优于 <code>ReentrantLock</code></p><p>而在多线程高竞争条件下，<code>ReentrantLock</code>比<code>synchronized</code>有更加优异的性能表现。</p><h5 id="高竞争"><a href="#高竞争" class="headerlink" title="高竞争"></a>高竞争</h5><p>如果大部分情况，每个线程都不需要真的获取锁，就是低竞争；反之，大部分都要获取锁才能正常工作，就是高竞争</p><h5 id="用法比较"><a href="#用法比较" class="headerlink" title="用法比较"></a>用法比较</h5><ol><li>Lock使用起来比较灵活，但是必须有释放锁的配合动作</li><li>Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁</li><li>Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等</li></ol><h5 id="特性比较"><a href="#特性比较" class="headerlink" title="特性比较"></a>特性比较</h5><p><code>ReentrantLock</code>的优势体现在：   </p><ol><li>具备尝试非阻塞地获取锁的特性：当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁</li><li>能被中断地获取锁的特性：与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放</li><li>超时获取锁的特性：在指定的时间范围内获取锁；如果截止时间到了仍然无法获取锁，则返回</li><li>可以控制线程的竞争公平性</li></ol><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>在使用<code>ReentrantLock</code>类的时，一定要注意三点：</p><ol><li>在finally中释放锁，目的是保证在获取锁之后，最终能够被释放</li><li>不要将获取锁的过程写在try块内，因为如果在获取锁时发生了异常，异常抛出的同时，也会导致锁无故被释放。</li><li><code>ReentrantLock</code>提供了一个<code>newCondition</code>的方法，以便用户在同一锁的情况下可以根据不同的情况执行等待或唤醒的动作。</li></ol><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是线程安全&quot;&gt;&lt;a href=&quot;#什么是线程安全&quot; class=&quot;headerlink&quot; title=&quot;什么是线程安全&quot;&gt;&lt;/a&gt;什么是线程安全&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;保证多线程环境下共享的、可修改的状态的正确性。(这里的状态在程序中可以看作为数据)&lt;/li&gt;
&lt;li&gt;反着来说则是如果状态非共享、不可修改，也就不存在线程安全的问题&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="http://ittiger.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ittiger.cn/tags/Java/"/>
    
      <category term="多线程" scheme="http://ittiger.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>React Native学习问题记录</title>
    <link href="http://ittiger.cn/RN-Problem-Record.html"/>
    <id>http://ittiger.cn/RN-Problem-Record.html</id>
    <published>2018-10-23T03:39:00.000Z</published>
    <updated>2019-05-09T14:02:44.365Z</updated>
    
    <content type="html"><![CDATA[<p>最近做了一个RN的项目，RN小白，自然遇到了不少问题，这里记录一下。<br><a id="more"></a></p><ol><li><p>命令行下启动IOS版本时出现如下错误：</p> <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun: error: unable to find utility &quot;instruments&quot;, not a developer tool or</span><br></pre></td></tr></table></figure><p> 这个是装完xcode后模拟器无法识别的问题，解决办法是在终端下执行如下命令：</p> <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo xcode-select -s /Applications/Xcode.app/Contents/Developer/</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">2. 终端命令启动某个APP时，出现红屏错误，而上面显示的错误信息表明加载代码的路径与当前要运行的代码路径不相符。这个错误应该是你上一次运行了另外一个APP，而当你再次运行第二个不同的APP时没有把上一个APP的终端监听给关掉。此时只需要关闭react-native start的监听终端即可，然后重启APP</span><br><span class="line">3. 在使用`react-devtools`查看APP的布局结构时，出现如下信息而无法链接上APP</span><br></pre></td></tr></table></figure><p> Waiting for React to connect</p> <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在终端下执行如下命令，然后重启`react-devtools`即可</span><br></pre></td></tr></table></figure><p> adb reverse tcp:8097 tcp:8097</p> <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4. `ScrollView`中`TextInput`的焦点问题。当`ScrollView`中存在`TextInput`时，当输入完文字后，`TextInput`会还占用焦点，导致`ScrollView`内的其他元素需要点击两次才能起作用，这时需要设置`ScrollView`的如下属性：`keyboardShouldPersistTaps=&quot;handled&quot;`即可</span><br><span class="line">5. 针对软键盘遮挡问题，我试了几种方案，发现下面两种方案比较简单有效：</span><br><span class="line">- RN官方提供的`KeyboardAvoidingView`方案最简单有效</span><br><span class="line">- 另外一种方案是自己监听软键盘的打开与关闭然后结合`Animated`动画来实现软键盘的遮挡问题，这种方案比较灵活</span><br><span class="line">6. IOS启动指定版本模拟器: `react native run-ios --simulator &quot;iPhone X&quot;`</span><br><span class="line">7. Android打包失败，信息如下：</span><br></pre></td></tr></table></figure><ul><li><p>What went wrong:<br>Execution failed for task ‘:app:bundleReleaseJsAndAssets’.</p><blockquote><p>A problem occurred starting process ‘command ‘node’’</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个错误的可能原因是gradle deamon的缓存问题，关掉cradle deamon，重新再执行一次就可以解决</span><br></pre></td></tr></table></figure></blockquote><p>./gradlew –stop<br><code>`</code></p></li></ul></li></ol><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做了一个RN的项目，RN小白，自然遇到了不少问题，这里记录一下。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React Native" scheme="http://ittiger.cn/categories/React-Native/"/>
    
    
      <category term="RN" scheme="http://ittiger.cn/tags/RN/"/>
    
  </entry>
  
  <entry>
    <title>整洁代码的理解</title>
    <link href="http://ittiger.cn/Thinking-Code-Clean.html"/>
    <id>http://ittiger.cn/Thinking-Code-Clean.html</id>
    <published>2018-09-15T14:59:37.000Z</published>
    <updated>2019-05-09T13:41:58.274Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间看了<code>《代码整洁之道》</code>这本书，书中的一些观点讲的很不错，这些观点很容易让人对号入座，也很容易让人知道自己写的代码是否漂亮、是否整洁。通过这篇文章记录下读后感和书中的一些观点。</p><a id="more"></a><h3 id="为什么要整洁代码"><a href="#为什么要整洁代码" class="headerlink" title="为什么要整洁代码"></a>为什么要整洁代码</h3><ul><li>很多时候我们修复bug或开发新功能时都会先看看周边的相关代码(开发过程中经常碰到前面写的代码到后面就忘了，回看代码是常事)，如果想要bug或新功能写的轻松那自然就要求代码阅读也轻松。不整洁的代码阅读起来会轻松吗。</li><li>相信很多人都不愿意去接手别人写的二手代码，为什么呢，因为很多人写的代码质量很一般，让其他的人阅读他的代码很是困难。所以整洁的代码也能帮助其他人轻松的理解自己的代码。</li></ul><h3 id="整洁代码核心思想"><a href="#整洁代码核心思想" class="headerlink" title="整洁代码核心思想"></a>整洁代码核心思想</h3><p><strong><em>如何在意代码</em></strong><br>这跟生活是一个道理，当你真正在意某件事情的时候，在意到什么程度，事情在意程度不一样，对事情的处理态度和方式也不一样。所以只有你真正的在意你写的代码，你才会去关注代码的质量，写出整洁漂亮的代码。</p><p>我有一个Android开发的QQ群，经常在群里听到有人说公司领导不在乎代码质量和实现过程，只关注结果，所以他们也不关注自己写的代码是否漂亮是否整洁，只求赶快完成功能交差。我相信有很多这样的程序员都是这样，只追求功能实现，从来不管代码写的怎么样，因为他们不注重自己写的代码怎么样，他们只看重自己能不能在规定时间内向领导交差。</p><h3 id="天敌：后面再优化"><a href="#天敌：后面再优化" class="headerlink" title="天敌：后面再优化"></a>天敌：后面再优化</h3><p>很多程序员都有一个习惯，经常会说：先实现目前的功能，等后面有时间了再来优化代码。其实大家也知道结果了，基本上大部分的人后面都不会去做什么代码优化，前面的说辞也变成了说说而已。</p><p>所以写代码的时候如果当时能写出更好的代码就当时一次性写好，不要想着以后再去优化，这基本是不可能的了。时间长了就会在不知不觉中养成习惯，如果每次都想着以后再优化，那每次写代码基本上都不会去关注代码的质量，相反每次编码都尽自己最大努力去写好，时间长了你的代码质量和要求自然就上去了。</p><h3 id="什么样的代码是整洁代码"><a href="#什么样的代码是整洁代码" class="headerlink" title="什么样的代码是整洁代码"></a>什么样的代码是整洁代码</h3><ul><li>代码逻辑一目了然，很清楚方法、类、模块做的是什么事情</li><li>整洁的代码只专注于做好一件事(不论是方法、类还是模块)，处理的事情多了，自然就会让逻辑变的复杂</li><li>让代码块小，小块的代码便于阅读和理解</li><li>尽量减少依赖，让代码便于维护</li><li>性能调至最优，省得引诱做没规矩的优化，搞出一堆混乱代码来</li><li>依据某种分层战略完善错误处理代码</li></ul><h3 id="如何写出整洁代码"><a href="#如何写出整洁代码" class="headerlink" title="如何写出整洁代码"></a>如何写出整洁代码</h3><h4 id="减少重复代码"><a href="#减少重复代码" class="headerlink" title="减少重复代码"></a>减少重复代码</h4><p>当代码中一段代码多次出现的时候，就表示某种想法没有在代码中得到良好的体现。所以减少重复代码以提高代码表达力，尽早构建简单抽象。</p><h4 id="使用异常代替错误码"><a href="#使用异常代替错误码" class="headerlink" title="使用异常代替错误码"></a>使用异常代替错误码</h4><p>错误码通常是枚举或者是常量，而这样的错误码就像磁铁一样，导致所有用到这些错误码类都需要导入引用它，一旦错误码需要修改就需要修改所有的这些类。而使用异常则不会存在这些问题，新异常可以从异常类里直接派生出来，而不需要修改已有代码。</p><h4 id="有意义的命名"><a href="#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h4><h5 id="命名要名副其实"><a href="#命名要名副其实" class="headerlink" title="命名要名副其实"></a>命名要名副其实</h5><p>选一个好的名称是比较耗费时间的，但是一旦选对了名称那省下的时间是很可观的。类名、变量名、方法名应该就可以答复大部分的问题，例如它做了什么事，怎么做。如果名称需要注释来补充，那就不算名副其实。</p><h5 id="避免误导"><a href="#避免误导" class="headerlink" title="避免误导"></a>避免误导</h5><ol><li>例如：字母l和数字1，字母o和数字0，这两种就很容易让人傻傻分不清</li><li>不要使用外形太像的命名方式，比如：ControllerForEfficientHandlingOfStrings和ControllerForEfficientStorageOfStrings，这种名称很长又只有细微差别的命名方式很容易迷惑</li><li>不要使用有特殊意义的字符串来命名。<h5 id="做有意义的区分"><a href="#做有意义的区分" class="headerlink" title="做有意义的区分"></a>做有意义的区分</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void copyChars(char a1[], char a2[]) &#123;</span><br><span class="line">for(int i = 0; i &lt; a1.length; a1++) &#123;</span><br><span class="line">a2[i] = a1[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>上面的代码虽然很简单，但是命名方式还是很有问题的，如果把参数名分别改为source和destination对整个方法的实现来说就要清晰很多</p><h5 id="使用读得出来的名称"><a href="#使用读得出来的名称" class="headerlink" title="使用读得出来的名称"></a>使用读得出来的名称</h5><p>命名的时候尽量使用大众熟知的单词，不要使用自造词、拼音单词混用或是自己偷懒将单词进行简写之类，这样的命名只会增加代码的阅读负担，让人看的云里雾里。</p><h5 id="使用可搜索的名称"><a href="#使用可搜索的名称" class="headerlink" title="使用可搜索的名称"></a>使用可搜索的名称</h5><p>在阅读代码的过程中常用的功能就是搜索，所以一个方便搜索的名称还是很重要的。<br>比如一个字符串最大长度只允许为7，代码中有好几个地方需要做这种判断，但是经常就有人偷懒直接使用数字7进行判断，那在代码搜索的时候是搜索7容易还是搜索MAX_LENGTH_SEVEN容易，答案很明显了。</p><p>对于搜索来说，长名称胜于短名称，搜得到的名称胜于用自造编码代写的名称。</p><h5 id="类名、函数名"><a href="#类名、函数名" class="headerlink" title="类名、函数名"></a>类名、函数名</h5><ol><li>类是对一类具有共同特征的事物的抽象，所以类和对象名应该是名称或名词短语，而不应该是动词</li><li>方法通常是完成了一件什么事，所以方法名应当是动词或动词短语。</li></ol><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><blockquote><p>让函数表达其意图，该给函数赋予哪些属性，好让读者一看就知道函数是什么样的程序</p></blockquote><ol><li><strong>函数第一规则就是要短小、尽量的短小</strong><ul><li>很多人在看别人的代码的时候一旦遇上很长的函数，心理就开始打退堂鼓了，为什么呢？其实很重要的一个原因就是因为长函数的实现逻辑都弄的比较复杂，而且这个函数可能做了好几件事，阅读起来会让人很吃力。而短小的函数一眼看上去逻辑就比较清晰简单，至少阅读的人心理上就要好受很多。</li></ul></li><li><strong>函数只做一件事</strong><ul><li>每个函数应该只做一件事，如果一个函数实现里做了多件事，那势必会让这个函数变的比较长。</li></ul></li><li><strong>函数参数尽量少</strong></li><li><strong>输出参数比输入更难以理解，尽量以返回值作为输出</strong><ul><li>很多人在方法实现的时候喜欢将List作为方法参数输入而方法返回类型为void(在Android开发中尤其多)，然后在方法实现里修改List的元素，后面直接用这个List作为修改后的List。这种写法稍不注意就会引发bug，而且不容易被发现。</li></ul></li><li><strong>不要用标记参数(boolean)</strong><ul><li>使用标记参数会增加函数的理解度和复杂度。一旦使用标记参数，就意味着你的函数实现里其实是做了两件不同的事。</li></ul></li><li><strong>将多个参数封装成一个类</strong><ul><li>如果一个函数有多个参数的话，就需要考虑将这些参数封装成一个类，使用对象作为参数输入了。</li></ul></li><li><strong>不要在函数中做函数名以外的事情</strong></li><li><strong>抽离try-catch代码块</strong><ul><li>处理错误异常也是一件事，所以要抽离</li></ul></li><li><strong>将被调用函数的实现直接定义在调用者的下方</strong><ul><li>使用这种方式方便阅读，避免阅读过程中来回的代码切换。</li><li>在web开发中jslint有条规则是将方法安装字母顺序进行排序，我个人不太认可这种方式，我认为将被调用函数的实现直接定义在调用者的下方这种方式比较好。</li></ul></li></ol><h4 id="避免急于求成"><a href="#避免急于求成" class="headerlink" title="避免急于求成"></a>避免急于求成</h4><p>编码的时候先按照思路实现，然后再斟酌打磨，按照规则打磨出整洁的代码。要想一次就写出完美的代码是不太可能的。先按思路实现，等你实现完可能就会发现有更好的实现方式，或者是更好的命名，这时慢慢的斟酌，慢慢的修改。</p><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间看了&lt;code&gt;《代码整洁之道》&lt;/code&gt;这本书，书中的一些观点讲的很不错，这些观点很容易让人对号入座，也很容易让人知道自己写的代码是否漂亮、是否整洁。通过这篇文章记录下读后感和书中的一些观点。&lt;/p&gt;
    
    </summary>
    
      <category term="Other" scheme="http://ittiger.cn/categories/Other/"/>
    
    
      <category term="Thinking" scheme="http://ittiger.cn/tags/Thinking/"/>
    
  </entry>
  
  <entry>
    <title>Hashtable、HashMap、TreeMap</title>
    <link href="http://ittiger.cn/Java-HashMap-Hashtable-TreeMap.html"/>
    <id>http://ittiger.cn/Java-HashMap-Hashtable-TreeMap.html</id>
    <published>2018-08-30T09:45:51.000Z</published>
    <updated>2019-05-09T13:42:49.169Z</updated>
    
    <content type="html"><![CDATA[<p>Hashtable、HashMap、TreeMap都是比较常见的一些Map实现，它们都是<code>key-value</code>键值对的形式存储和操作数据的容器类，同时他们的元素中不能有重复的key,一个key也只能映射一个value值。</p><p>下面我从不同的维度来分别说说这三个集合，文章中涉及到的源码版本是<code>JDK8</code></p><a id="more"></a><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><ul><li><code>Hashtable</code>和<code>HashMap</code>底层都是采用数组存储数据</li><li><code>TreeMap</code>底层是采用红黑树存储数据</li></ul><h2 id="元素特性"><a href="#元素特性" class="headerlink" title="元素特性"></a>元素特性</h2><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p><code>Hashtable</code>中存储的<code>key</code>和<code>value</code>都不能为<code>null</code>，这个从它的源码实现是可以看出来的<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line">    // Make sure the value is not null</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Makes sure the key is not already in the hashtable.</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    int hash = key.hashCode();</span><br><span class="line">    ...//省略部分</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是<code>Hashtable</code>添加元素的源码实现，从开头的if判断就可以发现它的<code>value</code>值是不允许为<code>null</code>的，而它的<code>key</code>虽然没有显式判断，但是在执行<code>int hash = key.hashCode();</code>这句代码时，如果<code>key</code>为<code>null</code>的话，代码执行到这里程序就崩了，所以从侧面也反应出<code>key</code>也不能为<code>null</code></p><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p><code>HashMap</code>中存储的<code>key</code>和<code>value</code>都允许为<code>null</code>，这个依然是从源码中看出来的。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//HashMap的put方法具体实现比较复杂代码比较多，这里我只贴出添加元素时涉及到key和value的相关代码</span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    return new Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    return new TreeNode&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//TreeNode最终还是继承自Node，所以这里就不贴出TreeNode的构造函数了</span><br></pre></td></tr></table></figure></p><p>从上面的几段代码中可以看到在将<code>key-value</code>添加到<code>HashMap</code>中时没有任何地方会使用它们，因此<code>key</code>和<code>value</code>都是可以为<code>null</code>的</p><p>但是一个<code>HashMap</code>中只能有一个<code>key</code>为<code>null</code>，但是可以有多个<code>value</code>为<code>null</code></p><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p><code>TreeMap</code>中如果用户未实现<code>Comparator</code>接口，则<code>key</code>不能为<code>null</code>，如果实现了<code>Comparator</code>接口，那么<code>key</code>能否为<code>null</code>则需要根据<code>Comparator</code>接口的具体实现有关。<code>value</code>则是可以为<code>null</code>。至于原因，我们依然通过源码来寻求答案<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Comparator&lt;? super K&gt; cpr = comparator;</span><br><span class="line">    if (cpr != null) &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            if (cmp &lt; 0)</span><br><span class="line">                t = t.left;</span><br><span class="line">            else if (cmp &gt; 0)</span><br><span class="line">                t = t.right;</span><br><span class="line">            else</span><br><span class="line">                return t.setValue(value);</span><br><span class="line">        &#125; while (t != null);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (key == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span><br><span class="line">        do &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            if (cmp &lt; 0)</span><br><span class="line">                t = t.left;</span><br><span class="line">            else if (cmp &gt; 0)</span><br><span class="line">                t = t.right;</span><br><span class="line">            else</span><br><span class="line">                return t.setValue(value);</span><br><span class="line">        &#125; while (t != null);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过上面的代码可以很明显的看到当成员变量<code>comparator</code>为空时(<code>Comparator</code>接口未实现)，有明显的<code>key</code>的非空判断，而当实现了该接口后，这会通过<code>Comparator</code>接口的<code>compare</code>方法比较当前<code>key</code>与<code>TreeMap</code>中已存在的<code>key</code>是否相等，所以这个时候<code>key</code>能否为<code>nul</code>就跟<code>Comparator</code>接口的<code>compare</code>方法具体实现有关了。</p><p><strong><em>注意这段代码</em></strong><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmp = k.compareTo(t.key);</span><br><span class="line">if (cmp &lt; 0)</span><br><span class="line">    t = t.left;</span><br><span class="line">else if (cmp &gt; 0)</span><br><span class="line">    t = t.right;</span><br><span class="line">else</span><br><span class="line">    return t.setValue(value);</span><br></pre></td></tr></table></figure></p><p>从上面的代码中我们还可以看出<code>TreeMap</code>的<code>key</code>是有序的，而且当前节点的<code>key</code>比其左子树节点的<code>key</code>要大，而比右子树节点的<code>key</code>要小。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><ul><li><code>Hashtable</code>和<code>HashMap</code>都是无序的</li><li><code>TreeMap</code>的<code>key</code>是有序的，有序的原因在前面分析其<code>put</code>源码的时候已经说过了。要注意的是这里是<code>key</code>是有序的，而不是其<code>value</code>是有序的，而且其默认是升序排序方式(深度优先搜索)，对于其排序方式，可以自定义实现<code>Comparator</code>接口来自定义排序规则</li></ul><h2 id="初始化和扩容方式"><a href="#初始化和扩容方式" class="headerlink" title="初始化和扩容方式"></a>初始化和扩容方式</h2><h4 id="Hashtable-1"><a href="#Hashtable-1" class="headerlink" title="Hashtable"></a>Hashtable</h4><ol><li>默认初始化容量为11个</li><li>容量阈值默认为当前容量的0.75倍，当集合数据大于等于阈值时就会进行扩容</li><li>不要求底层数组的容量一定为2的幂次方</li><li>扩容时会将容量变为原来的2倍加1</li><li>在初始化时就会创建底层数组</li><li>扩容时会创建一个扩容后的新数组，然后将原来数组的数据拷贝到新数组中<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void addEntry(int hash, K key, V value, int index) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (count &gt;= threshold) &#123;//数据个数大于等于阈值时进行扩容</span><br><span class="line">        rehash();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">//扩容函数</span><br><span class="line">protected void rehash() &#123;</span><br><span class="line">    int oldCapacity = table.length;</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line">    </span><br><span class="line">    //此处将oldCapacity左移一位，即将其扩大一倍</span><br><span class="line">    int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123;</span><br><span class="line">        if (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            return;</span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    //重新计算容量阈值</span><br><span class="line">    threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">    table = newMap;</span><br><span class="line">    //拷贝数据</span><br><span class="line">    for (int i = oldCapacity ; i-- &gt; 0 ;) &#123;</span><br><span class="line">        for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line"></span><br><span class="line">            int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;</span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap"></a>HashMap</h4><ol><li>默认初始化容量为16个</li><li>容量阈值默认为当前容量的0.75倍，当集合数据大于等于阈值时就会进行扩容</li><li>底层数据的容量要求一定是2的幂次方</li><li>扩容时会将容量变为原来的2倍</li><li>初始化时不会创建底层数组，而是在调用put方法添加数据时再创建底层数据</li><li>扩容时会创建一个扩容后的新数组，然后将原来数组的数据拷贝到新数组中<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;//初始化创建底层数组</span><br><span class="line">    ...</span><br><span class="line">    if (++size &gt; threshold)//元素个数大于等于阈值则进行扩容</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">//初始化或扩容函数</span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;//MAXIMUM_CAPACITY=2^30</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)//此处的newCap = oldCap &lt;&lt; 1则是进行数组扩容一倍</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);//重新计算新的阈值</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    ....</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="TreeMap-1"><a href="#TreeMap-1" class="headerlink" title="TreeMap"></a>TreeMap</h4><ol><li>因为<code>TreeMap</code>是树结构，所以不存在容量和扩容的问题</li><li>初始化时不会创建其根节点，而是在调用put方法添加数据时才会创建其根节点</li></ol><h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><h4 id="Hashtable-2"><a href="#Hashtable-2" class="headerlink" title="Hashtable"></a><code>Hashtable</code></h4><p>其方法都采用了<code>synchronized</code>修饰，因此是线程安全的，不会出现两个线程同时对数据进行操作的情况，它保证了线程安全性。但也因为这样导致其在多线程环境下使用此集合效率低下，因为一个线程访问其同步方法时，其他访问<code>Hashtable</code>的线程都会处于阻塞状态，现在已不推荐使用此集合。</p><h4 id="HashMap-2"><a href="#HashMap-2" class="headerlink" title="HashMap"></a><code>HashMap</code></h4><p><code>HashMap</code>的方法没有采用<code>synchronized</code>修饰，所以是非线程安全的，在程序中任一时刻可能会存在多个线程同时修改其数据，从而导致数据不一致。</p><p>在多线程环境下，我们可以使用下面两种方式使用<code>HashMap</code></p><ol><li>使用<code>Collections.synchronizedMap()</code>方法将<code>HashMap</code>转换为线程安全的<code>SynchronizedMap</code>包装类,其内部也是使用<code>synchronized</code>来达到同步效果，只不过此时锁住的是一个<code>Object</code>类型的成员变量,和锁住<code>HashMap</code>对象本身效果是一样，效率也比较低下，仅仅适合用在并发度不高的情景。</li><li>使用<code>ConcurrentHashMap</code>集合，相较于<code>Hashtable</code>锁住的是对象整体， <code>ConcurrentHashMap</code>基于<code>lock</code>实现锁分段技术。首先将<code>Map</code>存放的数据分成一段一段的存储方式，然后给每一段数据分配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。<code>ConcurrentHashMap</code>不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升</li></ol><h4 id="TreeMap-2"><a href="#TreeMap-2" class="headerlink" title="TreeMap"></a><code>TreeMap</code></h4><p><code>HashMap</code>的方法没有采用<code>synchronized</code>修饰，所以<code>TreeMap</code>也是非线程安全的。</p><p>在多线程环境下建议使用<code>ConcurrentSkipListMap</code>代替</p><h2 id="HashMap的哈希冲突"><a href="#HashMap的哈希冲突" class="headerlink" title="HashMap的哈希冲突"></a>HashMap的哈希冲突</h2><p><code>HashMap</code>采用<strong>链地址法</strong>来解决哈希冲突，对哈希冲突或链地址法不了解的同学请参考我的另外一篇文章<a href="https://blog.csdn.net/huyongl1989/article/details/82220920" target="_blank" rel="noopener">Hash冲突解决方法</a></p><p>但是在<code>HashMap</code>中对链地址法采用了一点点变化，对于哈希冲突导致出现同义词元素显示采用单链表存放，当这个链表大小超过一个阈值(TREEIFY_THRESHOLD=8)且<code>HashMap</code>的大小大于等于另一个容量阈值(MIN_TREEIFY_CAPACITY = 64),就会把这个单链表该造为树形结构。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    //此处判断链表的大小是否超过阈值</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">    int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        //HashMap的元素大小大于等于MIN_TREEIFY_CAPACITY则将该单链表改造成红黑树</span><br><span class="line">        //树改造逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要改造呢，我的理解是这样的：</p><ul><li>因为单链表适合数据的插入和删除，而对于查询来说其效率要低一点，在单链表数据量小的时候，查询遍历的效率可能影响不太大，而当单链表数据量变大之后，其查询带来的性能影响就没法忽略了，所以这里就对单链表改造为红黑树，这样其<code>key</code>是有序的，查询的时候性能就要提高很多。</li><li>还有一种说法是因为安全性。因为构造哈希冲突的数据难度不大，会有人利用恶意代码产生大量这种数据与服务器交互，导致服务器CPU资源被大量占用，这样就会导致哈希碰撞拒绝服务器攻击。</li></ul><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hashtable、HashMap、TreeMap都是比较常见的一些Map实现，它们都是&lt;code&gt;key-value&lt;/code&gt;键值对的形式存储和操作数据的容器类，同时他们的元素中不能有重复的key,一个key也只能映射一个value值。&lt;/p&gt;
&lt;p&gt;下面我从不同的维度来分别说说这三个集合，文章中涉及到的源码版本是&lt;code&gt;JDK8&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://ittiger.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ittiger.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hash冲突解决方法</title>
    <link href="http://ittiger.cn/Java-hash-conflict.html"/>
    <id>http://ittiger.cn/Java-hash-conflict.html</id>
    <published>2018-08-30T06:32:24.000Z</published>
    <updated>2019-05-09T13:43:09.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="何为Hash冲突"><a href="#何为Hash冲突" class="headerlink" title="何为Hash冲突"></a>何为Hash冲突</h2><p>假设Hash表大小为5(即5个槽位)，现在要把2,5,6,7,8这几个数存储到Hash表中，假设hash函数为<code>hash(num)=num % size</code></p><p>简单计算下，第一个数2的hash值为2所以放到第三个槽中，第二个数5的hash值为0放到第一个槽中，第三个数6的hash值为1放到第二个槽中，如下图所示：</p><table><thead><tr><th>1号槽</th><th>2号槽</th><th>3号槽</th><th>4号槽</th><th>5号槽</th></tr></thead><tbody><tr><td>5</td><td>6</td><td>2</td><td></td><td></td><td></td></tr></tbody></table><a id="more"></a><p>第四个数7的hash值也为2，应该放到第二个槽位，但是第二个槽位中已经放有数据了，这种情况就属于hash冲突。<br>简单来说，就是两个不同的数据经过hash函数计算之后得到了相同的hash值，这就叫做hash冲突。</p><h2 id="如何解决冲突"><a href="#如何解决冲突" class="headerlink" title="如何解决冲突"></a>如何解决冲突</h2><h3 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h3><p>开放地址法也称为再散列法</p><h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p>当关键字key的哈希地址 <code>p=hash(key)</code>出现冲突时，以hash值p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，然后将相应元素存入其中</p><h5 id="基本公式"><a href="#基本公式" class="headerlink" title="基本公式"></a>基本公式</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = hash(key)</span><br><span class="line">h = (p + di) % m</span><br></pre></td></tr></table></figure><p>上面的公公式中：</p><ol><li><code>hash(key)</code>是根据关键字key计算得到的hash值p</li><li><code>di</code>是一个增量序列，根据这个增量序列取值的区分，开放地址法也有不同的区分</li><li><code>m</code>是hash表的表长(表大小)</li></ol><h5 id="线性探测再散列"><a href="#线性探测再散列" class="headerlink" title="线性探测再散列"></a>线性探测再散列</h5><p>当上述公式中的增量序列<code>di</code>的取值为递增顺序取值时即为<code>线性探测再散列</code><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">di = 1,2,3,4,5 ... n-1,n   (n &lt;= m - 1)</span><br></pre></td></tr></table></figure></p><p>这种方式在发生hash冲突时，会逐步向后移动一个位置，顺序的查看下一个槽位，一直到找出下一个空的槽位或是直到查遍全表</p><p>当hash值p出现冲突时，则将数据放到<code>(p + 1) % m</code>处，如果此时还存在冲突，则将数据放到<code>(p + 2) % m</code>处，如果再次存在冲突，则将数据放到<code>(p + 3) % m</code>处，依次类推</p><h5 id="二次探测再散列"><a href="#二次探测再散列" class="headerlink" title="二次探测再散列"></a>二次探测再散列</h5><p>当<code>di</code>的取值规则如下时则称为<code>二次探测再散列</code><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1*1,-1*1, 2*2,-2*2, 3*3,-3*3, ..., k*k,-k*k   (k &lt;= m/2)</span><br></pre></td></tr></table></figure></p><p>当hash值p出现冲突时，则将数据放到<code>(p + 1) % m</code>处，如果此时还存在冲突，则将数据放到<code>(p - 1) % m</code>处，如果再次存在冲突，则将数据放到<code>(p + 4) % m</code>处，如果依然存在冲突，则将数据放到<code>(p - 4) % m</code>处，依次类推</p><h5 id="伪随机探测再散列"><a href="#伪随机探测再散列" class="headerlink" title="伪随机探测再散列"></a>伪随机探测再散列</h5><p>当<code>di</code>的取值是随机数序列时则称为<code>伪随机探测再散列</code><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">di = 随机数序列</span><br><span class="line">//假设有个随机数序列：2，8，3，5，11，6，7</span><br></pre></td></tr></table></figure></p><p>当hash值p出现冲突时，则将数据放到<code>(p + 2) % m</code>处，如果此时还存在冲突，则将数据放到<code>(p + 8) % m</code>处，如果再次存在冲突，则将数据放到<code>(p + 3) % m</code>处，如果依然存在冲突，则将数据放到<code>(p + 5) % m</code>处，依次类推</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>对开放地址法构造的哈希表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点</li><li>开放地址法要求哈希表空间大于或等于装填数据数目</li></ul><h3 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h3><p>这种方式是构造多个不同的哈希函数<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hi = RHi(key)     i=1,2,3,...,k</span><br></pre></td></tr></table></figure></p><p>当哈希值<code>hi = RH1(key)</code>发生冲突时，再计算<code>hi = RH2(key)</code>….一直到不产生冲突为止。</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>这种方式不容易产生聚集，但是增加了计算时间</p><h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>这种方法的原理是将所有哈希值为i而导致冲突的元素构成一个同义词单链表，并将单链表的头指针存在哈希表的第i个槽位中。因此对哈希值为i的元素的查找、添加、删除都是在此单链表中进行。结构如下图<br><img src="/img/Java-Basic/java-hash.jpeg" alt="这里写图片描述"></p><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li>处理冲突简单，无堆积现象，即非同义词不会产生冲突，平均查找路径较短</li><li>链地址法中各链表的节点空间都是动态申请的，因此链地址法比较适合构造Hash表前无法确定表长的业务场景</li><li>链地址法构造的哈希表删除操作比较容易实现，只需要简单的删除链表上对应的节点即可</li></ol><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>链地址法的指针需要额外的空间</p><h3 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h3><p>这种方法的原理是将哈希表分为基本表和溢出表两部分，凡是和基本表中元素发生冲突的元素均存入溢出表</p><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;何为Hash冲突&quot;&gt;&lt;a href=&quot;#何为Hash冲突&quot; class=&quot;headerlink&quot; title=&quot;何为Hash冲突&quot;&gt;&lt;/a&gt;何为Hash冲突&lt;/h2&gt;&lt;p&gt;假设Hash表大小为5(即5个槽位)，现在要把2,5,6,7,8这几个数存储到Hash表中，假设hash函数为&lt;code&gt;hash(num)=num % size&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;简单计算下，第一个数2的hash值为2所以放到第三个槽中，第二个数5的hash值为0放到第一个槽中，第三个数6的hash值为1放到第二个槽中，如下图所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;1号槽&lt;/th&gt;
&lt;th&gt;2号槽&lt;/th&gt;
&lt;th&gt;3号槽&lt;/th&gt;
&lt;th&gt;4号槽&lt;/th&gt;
&lt;th&gt;5号槽&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Java" scheme="http://ittiger.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ittiger.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>final、finally、finalize</title>
    <link href="http://ittiger.cn/Java-final-finally-finalize.html"/>
    <id>http://ittiger.cn/Java-final-finally-finalize.html</id>
    <published>2018-08-29T08:49:37.000Z</published>
    <updated>2019-05-09T13:43:27.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ol><li>final可以用来修饰类、方法、变量，修饰对象不同所代表的意义也不同<ul><li>修饰类则代表该类不可继承扩展</li><li>修饰方法则代表该方法不可重写</li><li>修饰变量则代表该变量某种程度不可更改。为什么说是某种程度呢，因为这需要根据变量的类型来区分<ul><li>如果修饰的变量是基本类型，则该变量赋值一次之后就无法修改，这是final就是不可变的标志</li><li>如果修饰的变量是引用类型，那么该变量赋值一次之后，就无法修改该变量的引用，但是该引用对象的属性还是可以更改的，比较常见的就是变量引用了一个<code>List</code>,虽说用了final修饰，但是依然可以对该<code>List</code>的元素进行各种操作</li></ul></li></ul></li><li>将变量或参数使用final修饰可以清楚的避免意外赋值导致的编码错误</li><li>因为final修饰变量产生了某种程度的不可变的特性，所以它可以保护只读数据，因此在并发编程中使用final修饰变量有利于减少额外的同步开销，也可以省去一些防御性拷贝必要，从而提升性能<a id="more"></a><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2>finally是java保证重点代码一定要被执行的一种机制。我们可以使用<code>try-finally</code>或<code>try-catch-finally</code>来进行类型关闭JDBC链接、保证unlock锁等操作</li></ol><h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h2><p>finalize 是基础类<code>java.lang.Object</code>的一个方法,它的作用是保证对象在被垃圾收集器收集前完成特定资源的回收。finalize机制现在已经不推荐使用，并且在JDK9开始被标记为deprecated。</p><p>如果调用了finalize方法，则会导致该对象称为“特殊公民”，JVM需要对它进行额外的处理。这样反而导致了finalize成为了快速回收的阻碍者，它可能导致你的对象经过多个垃圾收集周期才能被回收。</p><p>在实践中因为finalize拖慢垃圾收集，导致大量对象堆积，也是一种典型的导致OOM的原因。</p><p>因为我们要确保回收资源就是因为资源都是有限的，垃圾收集的时间不可预测，可能会极大加剧资源占用。所以对于消耗非常高频的资源，千万不要指望finalize去承担资源释放的职责。</p><p>资源用完立刻显示释放，或者利用资源池尽量重用</p><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;final&quot;&gt;&lt;a href=&quot;#final&quot; class=&quot;headerlink&quot; title=&quot;final&quot;&gt;&lt;/a&gt;final&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;final可以用来修饰类、方法、变量，修饰对象不同所代表的意义也不同&lt;ul&gt;
&lt;li&gt;修饰类则代表该类不可继承扩展&lt;/li&gt;
&lt;li&gt;修饰方法则代表该方法不可重写&lt;/li&gt;
&lt;li&gt;修饰变量则代表该变量某种程度不可更改。为什么说是某种程度呢，因为这需要根据变量的类型来区分&lt;ul&gt;
&lt;li&gt;如果修饰的变量是基本类型，则该变量赋值一次之后就无法修改，这是final就是不可变的标志&lt;/li&gt;
&lt;li&gt;如果修饰的变量是引用类型，那么该变量赋值一次之后，就无法修改该变量的引用，但是该引用对象的属性还是可以更改的，比较常见的就是变量引用了一个&lt;code&gt;List&lt;/code&gt;,虽说用了final修饰，但是依然可以对该&lt;code&gt;List&lt;/code&gt;的元素进行各种操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;将变量或参数使用final修饰可以清楚的避免意外赋值导致的编码错误&lt;/li&gt;
&lt;li&gt;因为final修饰变量产生了某种程度的不可变的特性，所以它可以保护只读数据，因此在并发编程中使用final修饰变量有利于减少额外的同步开销，也可以省去一些防御性拷贝必要，从而提升性能&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="http://ittiger.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ittiger.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Exception与Error</title>
    <link href="http://ittiger.cn/Java-Exception-Error.html"/>
    <id>http://ittiger.cn/Java-Exception-Error.html</id>
    <published>2018-08-29T08:19:09.000Z</published>
    <updated>2019-05-09T13:43:44.936Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/Java-Basic/java-exception-error.png" alt="这里写图片描述"></p><h1 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h1><p><code>Exception</code>和<code>Error</code>都是继承自<code>Throwable</code>，在Java中只有<code>Throwable</code>的实例才可以被抛(<code>throw</code>)出或捕获(<code>catch</code>)，它是java异常处理机制的基本组成类型。</p><p><code>Exception</code>和<code>Error</code>体现了Java平台设计者对不同异常情况的分类<br><a id="more"></a></p><h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><ol><li><code>Exception</code>是程序正常运行中，可以预料的意外情况，可能并且应该被捕获从而进行相应的处理</li><li><code>Exception</code>又分为编译器异常和运行期异常。<ul><li>编译器异常在代码中必须显示的进行捕获处理，这也是编译期检查的一部分。</li><li>运行期异常就是在程序运行过程中，由于程序逻辑等原因导致的运行异常，比如：<code>NullPointerException</code>,<code>ArrayIndexOutOfBoundsException</code>之类，这类异常通常都是可以通过编码避免的逻辑错误，具体根据需要来判断是非需要补货，并不会在编译期强制要求</li></ul></li></ol><h1 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h1><p><code>Error</code>是指在正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序(比如JVM自身)处于正常、不可恢复的状态。所以既然是非正常情况，那么也不便于也不需要捕获，常见的比如<code>OutOfMemoryError</code>之类，都是Error的子类。</p><h1 id="ClassNotFoundException-amp-amp-NoClassDefFoundError"><a href="#ClassNotFoundException-amp-amp-NoClassDefFoundError" class="headerlink" title="ClassNotFoundException &amp;&amp; NoClassDefFoundError"></a>ClassNotFoundException &amp;&amp; NoClassDefFoundError</h1><h3 id="ClassNotFoundException"><a href="#ClassNotFoundException" class="headerlink" title="ClassNotFoundException"></a>ClassNotFoundException</h3><p>在程序运行过程中通过某个类的字符串名称加载该类时，如果没有找到具有指定名称的类的定义的时候就会抛出<code>ClassNotFoundException</code>异常。通过字符串限定类名加载类主要有如下三种方式：</p><ol><li><code>Class.forName(java.lang.String)</code></li><li><code>ClassLoader.findSystemClass(java.lang.String)</code></li><li><code>ClassLoader.loadClass(java.lang.String, boolean)</code></li></ol><h3 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h3><p>如果<code>JVM</code>或者<code>ClassLoader</code>实例尝试加载（可以通过正常的方法调用，也可能是使用new来创建新的对象）类的时候却找不到类的定义。要查找的类在编译的时候是存在的，运行的时候却找不到了。这个时候就会导致<code>NoClassDefFoundError</code> </p><p>造成该问题的原因可能是打包过程漏掉了部分类，或者jar包出现损坏或者篡改。解决这个问题的办法是查找那些在开发期间存在于类路径下但在运行期间却不在类路径下的类。</p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ol><li>在开发过程中尽量不要捕获类似Exception这样的通用异常，而是应该捕获特定异常，因为特定异常可以尽可能多的告知我们错误信息，而通用异常则会隐藏一些信息</li><li>程序中不要捕获不希望被捕获的异常，有些时候我们可能更希望<code>RuntimeException</code>扩散出来，而不是被捕获</li><li>不要吞掉异常。很多人经常写出这样的代码，因为这样会导致程序出现问题的时候，我们很难定位和发现错误<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//下面就是一个吞掉异常的例子</span><br><span class="line">try &#123;</span><br><span class="line">    //业务逻辑。。。</span><br><span class="line">&#125; catch(IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h1><p>在处理java异常的方法中<code>try-catch-finally</code>是最常用的方式，但是在使用该代码块的时候会有一些隐藏的问题，主要是在方法返回值的问题上。</p><p>按照一般的惯性认知：当遇到return语句的时候，执行函数会立刻返回。但是在java中遇到finally的时候就有会例外。</p><p>除了return语句，try代码块中的break和continue语句也可能使控制权进入finally代码块。</p><p>当函数返回值是引用类型同时存在finally语句块时要特别注意，如果在finally块中对返回的引用对象属性进行了更改，这时即使没有在finally块中显示调用return语句，这个更改也会作用在返回值上。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public User getUser() &#123;</span><br><span class="line">    User user = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        user = new User(&quot;user&quot;);</span><br><span class="line">        //其他业务逻辑。。。</span><br><span class="line">        return user;</span><br><span class="line">    &#125; catch(IOException e) &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if(user != null) &#123;</span><br><span class="line">            user.setName(&quot;user1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码中该函数最终返回的User对象的name属性其实为user1</p><p>产生上述问题的原因是因为JVM会保证在return语句执行之前，先执行finally语句</p><h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>另外一个使用<code>try-catch</code>要注意的点是<code>try-catch</code>代码段会产生额外的性能开销，它往往会影响JVM对代码进行优化，所以建议仅捕获有必要的代码段，不要一个<code>try-catch</code>包住大段的代码。因此使用异常控制代码流程也不是一个好注意，它远比通常意义上的条件语句(<code>if/else</code>,<code>swich</code>)要低效</p><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/Java-Basic/java-exception-error.png&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;相同点&quot;&gt;&lt;a href=&quot;#相同点&quot; class=&quot;headerlink&quot; title=&quot;相同点&quot;&gt;&lt;/a&gt;相同点&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Exception&lt;/code&gt;和&lt;code&gt;Error&lt;/code&gt;都是继承自&lt;code&gt;Throwable&lt;/code&gt;，在Java中只有&lt;code&gt;Throwable&lt;/code&gt;的实例才可以被抛(&lt;code&gt;throw&lt;/code&gt;)出或捕获(&lt;code&gt;catch&lt;/code&gt;)，它是java异常处理机制的基本组成类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Exception&lt;/code&gt;和&lt;code&gt;Error&lt;/code&gt;体现了Java平台设计者对不同异常情况的分类&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://ittiger.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ittiger.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>强引用、软引用、弱引用、虚引用</title>
    <link href="http://ittiger.cn/Java-Reference.html"/>
    <id>http://ittiger.cn/Java-Reference.html</id>
    <published>2018-08-29T06:56:20.000Z</published>
    <updated>2019-05-09T13:42:28.162Z</updated>
    
    <content type="html"><![CDATA[<p>在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。</p><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>特点：我们平常典型编码<code>Object obj = new Object()</code>中的obj就是强引用。</p><p>通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出<code>OutOfMemoryError</code>运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。</p><a id="more"></a><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>特点：软引用通过SoftReference类实现。 </p><p>软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 <code>OutOfMemoryError</code> 之前，清理软引用指向的对象。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。</p><p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>弱应用同样可用于内存敏感的缓存。</p><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>特点：虚引用也叫幻象引用，通过PhantomReference类来实现。</p><p>无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue queue = new ReferenceQueue ();</span><br><span class="line">PhantomReference pr = new PhantomReference (object, queue);</span><br></pre></td></tr></table></figure></p><p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。</p><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><p>可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。</p><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。&lt;/p&gt;
&lt;h2 id=&quot;强引用&quot;&gt;&lt;a href=&quot;#强引用&quot; class=&quot;headerlink&quot; title=&quot;强引用&quot;&gt;&lt;/a&gt;强引用&lt;/h2&gt;&lt;p&gt;特点：我们平常典型编码&lt;code&gt;Object obj = new Object()&lt;/code&gt;中的obj就是强引用。&lt;/p&gt;
&lt;p&gt;通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出&lt;code&gt;OutOfMemoryError&lt;/code&gt;运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://ittiger.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ittiger.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>String、StringBuffer与StringBuilder</title>
    <link href="http://ittiger.cn/Java-String-StringBuffer-StringBuilder.html"/>
    <id>http://ittiger.cn/Java-String-StringBuffer-StringBuilder.html</id>
    <published>2018-08-29T06:43:07.000Z</published>
    <updated>2019-05-09T13:39:07.758Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h3 id="String的创建机制"><a href="#String的创建机制" class="headerlink" title="String的创建机制"></a>String的创建机制</h3><p>因为String在Java中使用过于频繁，Java为了避免在系统中产生大量的String对象，引入了字符串常量池的概念。 </p><p>其运行机制是：</p><ul><li>创建一个字符串时，首先检查池中是否有值相同的字符串对象(equals决定)，如果有则不需要创建而是直接从常量池中找到的该字符串对象的引用；</li><li>如果没有则新建一个字符串对象，返回该对象引用，并且将新创建的字符串对象放入池中<a id="more"></a>但是通过new方法创建的String对象是不检查字符串池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入池中。</li></ul><p><strong>举例：</strong><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//通过直接量赋值方式，放入字符串常量池</span><br><span class="line">String str1 = &quot;123&quot;; </span><br><span class="line">//通过new方式赋值方式，不放入字符串常量池</span><br><span class="line">String str2 = new String(“123”);</span><br><span class="line">//此时的str1 != str2</span><br><span class="line"></span><br><span class="line">String str3 = &quot;1&quot; + &quot;2&quot; + &quot;3&quot;;</span><br><span class="line">//str3 == str1 是成立的</span><br></pre></td></tr></table></figure></p><p>上述代码中在编译期的时候，str3即被编译成”123”字符串，而此时常量池中已经存在该字符串，所以str3与str1是相等的</p><h3 id="String的特性"><a href="#String的特性" class="headerlink" title="String的特性"></a>String的特性</h3><h5 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h5><p>String对象一旦生成，则不能再对它的值进行改变，这里的不可变指这个字符串对象无法改变，而我们平时定义的字符串变量虽然可以改变，但是实质上它是改变了这个变量的引用，相当于将这个变量指向了另外一个字符串对象，而一开始的字符串对象还是没有变的。</p><p>不可变的主要作用在于当一个对象需要被多线程共享，并且访问频繁时，可以省略同步和锁等待的时间，从而大幅度提高系统性能。</p><p>不可变模式是一个可以提高多线程程序的性能，降低多线程程序复杂度的设计模式。</p><h5 id="针对常量池的优化"><a href="#针对常量池的优化" class="headerlink" title="针对常量池的优化"></a>针对常量池的优化</h5><p>当2个String对象拥有相同的值时，他们只引用常量池中的同一个拷贝。当同一个字符串反复出现时，这个技术可以大幅度节省内存空间。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;123&quot;;</span><br><span class="line">String str2 = &quot;123&quot;;</span><br><span class="line">//此时的str1 == str2是成立的</span><br></pre></td></tr></table></figure></p><h5 id="为什么不可变"><a href="#为什么不可变" class="headerlink" title="为什么不可变"></a>为什么不可变</h5><p>我们看String的源码可以发现String底层是采用字符数组(<code>char[]</code>)来存储字符串值，该数组的定义如下<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final char value[];</span><br></pre></td></tr></table></figure></p><p>这个数组定义为<code>private final</code>，在java中数组也是对象，所以当String对象一旦初始化完成，其内部变量<code>value</code>的引用就无法改变，顶多只能改变数组中元素的值，但是在看遍String的所有方法后，发现String中根本没有一个方法可以改变<code>value</code>这个char数组里面的元素，所以在String初始化完成后即不可变。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;abcde&quot;;</span><br><span class="line">a = a.subString(1);//这时a=&quot;bcde&quot;</span><br></pre></td></tr></table></figure></p><p>虽然我们在编码过程中经常会调用String的<code>toLowerCase</code>,<code>substring</code>等方法，如上面的例子中虽然a最终被改变成了<code>&quot;bcde&quot;</code>，但是实际上这是生成的一个新字符串对象，只是将变量a的引用指向了这个新对象，而没有改变原有字符串对象<code>&quot;abcde&quot;</code>的值。</p><h1 id="StringBuffer-amp-StringBuilder"><a href="#StringBuffer-amp-StringBuilder" class="headerlink" title="StringBuffer &amp; StringBuilder"></a>StringBuffer &amp; StringBuilder</h1><p><code>StringBuffer</code>和<code>StringBuilder</code>都实现了<code>AbstractStringBuilder</code>抽象类，拥有几乎一致对外提供的调用接口；</p><p>其底层在内存中的存储方式与String相同，都是采用char数组存储数据，只是这个char数组没被final修饰，因此这个char数组的引用可以改变且该数组中的元素也可以改变，所以<code>StringBuffer/StringBuilder</code>对象的值是可以改变的。</p><p>而<code>StringBuffer/StringBuilder</code>在改变char数组过程中是在该对象自身内部进行的，所以对象本身的引用还是同一个。因此定义一个<code>StringBuffer/StringBuilder</code>变量，修改其值之后，其引用还是同一个，不会改变。</p><p>两者对象在构造过程中，首先按照默认大小申请一个字符数组，由于会不断加入新数据，当超过默认大小后，会创建一个更大的数组，并将原先的数组内容复制过来，再丢弃旧的数组。因此，对于较大对象的扩容会涉及大量的内存复制操作，如果能够预先评估大小，可提升性能。</p><p>唯一需要注意的是：StringBuffer是线程安全的，但是StringBuilder是线程不安全的。可参看Java标准类库的源代码，StringBuffer类中方法定义前面都会有synchronize关键字。为此，StringBuffer的性能要远低于StringBuilder。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>在字符串内容不经常发生变化的业务场景优先使用String类。例如：常量声明、少量的字符串拼接操作等。如果有大量的字符串内容拼接，避免使用String与String之间的“+”操作，因为这样会产生大量无用的中间对象，耗费空间且执行效率低下（新建对象、回收对象花费大量时间）。</li><li>在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在多线程环境下，建议使用StringBuffer，例如XML解析、HTTP参数解析与封装。</li><li>在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在单线程环境下，建议使用StringBuilder，例如SQL语句拼装、JSON封装等。</li></ul><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h1&gt;&lt;h3 id=&quot;String的创建机制&quot;&gt;&lt;a href=&quot;#String的创建机制&quot; class=&quot;headerlink&quot; title=&quot;String的创建机制&quot;&gt;&lt;/a&gt;String的创建机制&lt;/h3&gt;&lt;p&gt;因为String在Java中使用过于频繁，Java为了避免在系统中产生大量的String对象，引入了字符串常量池的概念。 &lt;/p&gt;
&lt;p&gt;其运行机制是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个字符串时，首先检查池中是否有值相同的字符串对象(equals决定)，如果有则不需要创建而是直接从常量池中找到的该字符串对象的引用；&lt;/li&gt;
&lt;li&gt;如果没有则新建一个字符串对象，返回该对象引用，并且将新创建的字符串对象放入池中&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://ittiger.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://ittiger.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序之页面数据绑定及页面跳转传参</title>
    <link href="http://ittiger.cn/weixin-xcx-data-binding-and-params-transfer.html"/>
    <id>http://ittiger.cn/weixin-xcx-data-binding-and-params-transfer.html</id>
    <published>2017-07-17T09:50:02.000Z</published>
    <updated>2019-05-09T09:49:25.862Z</updated>
    
    <content type="html"><![CDATA[<p>在写前面的小程序入门项目时，发现有两个很常用而且觉得也算比较重要的知识点，这里记录下：</p><h3 id="页面数据绑定"><a href="#页面数据绑定" class="headerlink" title="页面数据绑定"></a>页面数据绑定</h3><p>比如你的页面需要显示一个<code>Hello</code>字符串，这个这个字符串可能会根据某些情况会动态变化，这个时候就需要进行数据绑定展示了</p><p>在wxml文件布局如下：<br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>在js中设置好变量如下：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">data: &#123;</span><br><span class="line">message: <span class="hljs-string">"Hello"</span>,</span><br><span class="line">number: <span class="hljs-number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>就这样data里面的message属性就可以通过view组件展示出来了，看了上面的写法，也很容易明白，组件展示数据信息时是通过<br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;属性名称&#125;&#125;</span><br></pre></td></tr></table></figure></p><p>这的写法与data里面的属性进行绑定的。</p><p>如果在数据信息展示出来后，后面要更新这个属性信息的展示的话，就不能简单的通过<code>this.data.message=&quot;Hello World&quot;来实现，因为这样是无法达到改变数据信息的目的的。小程序中改变数据信息要求使用函数</code>setData()<code>函数来实现。例如上面我们修改</code>message`的值的话需要进行如下操作：</p><!--mroe--><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">this</span>.setData(&#123;</span><br><span class="line">message: <span class="hljs-string">"Hello World"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过该函数更新之后，页面上会自动的更新展示，而不需要我们去进行额外的操作，微信将数据的展示与更新进行了分离，只要你使用特定的方法修改属性值，界面就会自动更新，这样的实方式比起android中的手动通知更新要方便很多</p><h3 id="页面跳转参数"><a href="#页面跳转参数" class="headerlink" title="页面跳转参数"></a>页面跳转参数</h3><p>小程序中从一个页面跳转到另外一个页面有几种方式，这里我以<code>wx.navigateTo()</code>跳转进行说明：<br>我从<code>index</code>页面跳转到<code>logs</code>页面，很简单</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.navigateTo(&#123;</span><br><span class="line">url: <span class="hljs-string">'../log/logs</span></span><br><span class="line"><span class="hljs-string">&#125;)</span></span><br></pre></td></tr></table></figure><p>那如果我在跳转的同时要向<code>logs</code>页面传递参数该怎么办呢，也很简单，直接在url后拼接相关参数即可(与http中的get请求的传参方式是一样的)</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.navigateTo(&#123;</span><br><span class="line">url: <span class="hljs-string">'../video/video?message='</span> + <span class="hljs-keyword">this</span>.data.message + <span class="hljs-string">"&amp;number="</span> + <span class="hljs-keyword">this</span>.data.number</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>参数是传过去了，那在<code>logs</code>页面中该如何获取这些参数呢？其实也很简单：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onLoad: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>&#123;</span><br><span class="line"><span class="hljs-keyword">var</span> message = options.message;</span><br><span class="line"><span class="hljs-keyword">var</span> number = options.number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，我们在新页面的<code>onLoad</code>函数中就可以直接获取到传递过来的参数信息。</p><h3 id="点击View传参"><a href="#点击View传参" class="headerlink" title="点击View传参"></a>点击View传参</h3><p>在我前面的文章<a href="http://ittiger.cn/weixin-xcx-first-project.html"> 微信小程序之入门项目</a>中点击视频列表中的某一项跳转到视频播放页面，而在点击列表中的某一项时，需要获取当前项的数据信息，如果我想通过点击事件就将这些数据信息作为参数传递过去该怎么做呢？代码如下：</p><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">"&#123;&#123;tab.videos&#125;&#125;"</span> <span class="hljs-attr">wx:for-item</span>=<span class="hljs-string">"video"</span> <span class="hljs-attr">data-video</span>=<span class="hljs-string">"&#123;&#123;video&#125;&#125;"</span> <span class="hljs-attr">wx:key</span>=<span class="hljs-string">"*this"</span> <span class="hljs-attr">bindtap</span>=<span class="hljs-string">"onItemClick"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码通过for循环实现了一个列表，并为每一项绑定了点击事件，而<code>view</code>组件实现中有一个属性是微信没有提供的：<code>data-video</code>，这个属性是我们手动添加上去的，微信中如果要在wxml中传递参数到点击事件中的话则可以通过<code>data-**</code>的形式进行传参(**号即为参数名称)，此处是将每一项数据<code>video</code>作为参数进行传递，同时参数名称为<code>video</code></p><p>接下来再来看看点击事件中如何获取该<code>video</code>信息：</p><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onItemClick: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> video = event.currentTarget.dataset.video;</span><br><span class="line">    <span class="hljs-keyword">var</span> url = video.url;</span><br><span class="line">    <span class="hljs-keyword">var</span> title = video.title;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>没错，就像代码中写的，在点击事件中我们可以通过<code>event.currentTarget.dataset</code>获取传过来的<code>video</code>信息，这个参数在调试的时候也是可以通过event对象看到的</p><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写前面的小程序入门项目时，发现有两个很常用而且觉得也算比较重要的知识点，这里记录下：&lt;/p&gt;
&lt;h3 id=&quot;页面数据绑定&quot;&gt;&lt;a href=&quot;#页面数据绑定&quot; class=&quot;headerlink&quot; title=&quot;页面数据绑定&quot;&gt;&lt;/a&gt;页面数据绑定&lt;/h3&gt;&lt;p&gt;比如你的页面需要显示一个&lt;code&gt;Hello&lt;/code&gt;字符串，这个这个字符串可能会根据某些情况会动态变化，这个时候就需要进行数据绑定展示了&lt;/p&gt;
&lt;p&gt;在wxml文件布局如下：&lt;br&gt;&lt;figure class=&quot;highlight xml hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;view&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;#123;&amp;#123;message&amp;#125;&amp;#125;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;view&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小程序" scheme="http://ittiger.cn/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="http://ittiger.cn/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序之Tab切换</title>
    <link href="http://ittiger.cn/weixin-xcx-tabbar-switch.html"/>
    <id>http://ittiger.cn/weixin-xcx-tabbar-switch.html</id>
    <published>2017-07-17T09:44:58.000Z</published>
    <updated>2019-05-09T09:55:45.295Z</updated>
    
    <content type="html"><![CDATA[<p>做过<code>android</code>的都知道在<code>android</code>里面实现<code>Tab切换</code>非常简单，使用<code>android</code>提供的<code>TabLayout+ViewPager</code>很容器就实现了<code>Tab切换</code>的效果。</p><p>但是小程序中是没有提供类似可以直接使用的组件，因此想要实现此功能需要我们自己去编码实现。在<a href="http://ittiger.cn/weixin-xcx-first-project.html">上一篇</a>文章中我提到的小程序练手项目就实现了<code>Tab切换</code>效果，具体效果图可以参考文章<a href="http://ittiger.cn/weixin-xcx-first-project.html">微信小程序入门项目</a>。</p><a id="more"></a><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>翻看小程序的文档可以发现，微信为我们提供了一个<code>swiper</code>组件，通过该组件可以实现<code>view</code>的滑动切换，它的功能与<code>android</code>中的<code>ViewPager</code>是类似的。因此实现<code>Tab切换</code>现在只需要实现头部的<code>Tabbar</code>即可，对于该功能我们可以采用多个横向排列的<code>view</code>组件构成一个<code>Tabbar</code>，每个<code>view</code>组件作为一个<code>Tab</code>项，然后再将其点击事件与<code>swiper</code>进行关联即可实现<code>Tab</code>的点击和滑动切换功能。而对于<code>Tabbar</code>的当前<code>Tab</code>项下面的指示器我们可以采用<code>border-bottom</code>样式实现，也可以单独使用一个<code>view</code>组件作为指示器，我这里采用的是第二种方式实现指示器。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>实现代码如下：</p><h4 id="页面布局代码"><a href="#页面布局代码" class="headerlink" title="页面布局代码"></a>页面布局代码</h4><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"page"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar"</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">block</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">"&#123;&#123;tabs&#125;&#125;"</span> <span class="hljs-attr">wx:key</span>=<span class="hljs-string">"*this"</span>&gt;</span></span><br><span class="line">          <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"&#123;&#123;index&#125;&#125;"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar__item &#123;&#123;activeIndex == index ? 'navbar__item_on' : ''&#125;&#125;"</span> <span class="hljs-attr">bindtap</span>=<span class="hljs-string">"navTabClick"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar__title"</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="line">          <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;/<span class="hljs-name">block</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar__slider"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width: &#123;&#123;sliderWidth&#125;&#125;px; transform: translateX(&#123;&#123;sliderOffset&#125;&#125;px); -webkit-transform: translateX(&#123;&#123;sliderOffset&#125;&#125;px);"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"position: absolute;top: 68rpx;width: 100%;height:&#123;&#123;contentHeight&#125;&#125;px"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">swiper</span> <span class="hljs-attr">current</span>=<span class="hljs-string">"&#123;&#123;activeIndex&#125;&#125;"</span> <span class="hljs-attr">duration</span>=<span class="hljs-string">"300"</span> <span class="hljs-attr">bindchange</span>=<span class="hljs-string">"bindChange"</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>热门视频<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>比赛集锦<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>你懂专栏<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>天下足球<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">swiper</span>&gt;</span> </span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="布局样式代码"><a href="#布局样式代码" class="headerlink" title="布局样式代码"></a>布局样式代码</h4><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">view</span> , <span class="hljs-selector-tag">page</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0px</span>;</span><br><span class="line">  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-class">.page</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-class">.navbar</span> &#123;</span><br><span class="line">    <span class="hljs-attribute">display</span>: flex;</span><br><span class="line">    <span class="hljs-attribute">position</span>: absolute;</span><br><span class="line">    <span class="hljs-attribute">z-index</span>: <span class="hljs-number">500</span>;</span><br><span class="line">    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-class">.navbar__item</span> &#123;</span><br><span class="line">    <span class="hljs-attribute">position</span>: relative;</span><br><span class="line">    <span class="hljs-attribute">display</span>: block;</span><br><span class="line">    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10</span>rpx <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-attribute">text-align</span>: center;</span><br><span class="line">    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-attribute">height</span>: <span class="hljs-number">48</span>rpx;</span><br><span class="line">    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">48</span>rpx;</span><br><span class="line">    &lt;!-- NavBar的总高度为：height + padding-top + padding-bottom = 68rpx --&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-class">.navbar__item_on</span> &#123;</span><br><span class="line">    <span class="hljs-attribute">color</span>: <span class="hljs-number">#16B13A</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-class">.navbar__slider</span> &#123;</span><br><span class="line">    <span class="hljs-attribute">position</span>: absolute;</span><br><span class="line">    <span class="hljs-attribute">display</span>: block;</span><br><span class="line">    <span class="hljs-attribute">content</span>: <span class="hljs-string">" "</span>;</span><br><span class="line">    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-attribute">height</span>: <span class="hljs-number">3px</span>;</span><br><span class="line">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#16B13A</span>;</span><br><span class="line">    <span class="hljs-attribute">transition</span>: transform .<span class="hljs-number">3s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-class">.navbar__title</span>&#123;</span><br><span class="line">    <span class="hljs-attribute">display</span>: inline-block;</span><br><span class="line">    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">15px</span>;</span><br><span class="line">    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">8em</span>;</span><br><span class="line">    <span class="hljs-attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-tag">swiper</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-tag">swiper-item</span>&#123;</span><br><span class="line">  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="line">  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">20</span>rpx;</span><br><span class="line">  <span class="hljs-attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="js代码"><a href="#js代码" class="headerlink" title="js代码"></a>js代码</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> tabs = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="hljs-string">"热门视频"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="hljs-string">"比赛集锦"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="hljs-string">"你懂专栏"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="hljs-string">"天下足球"</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">   * 页面的初始数据</span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    tabs: tabs,     <span class="hljs-comment">//展示的数据</span></span><br><span class="line">    slideOffset: <span class="hljs-number">0</span>,<span class="hljs-comment">//指示器每次移动的距离</span></span><br><span class="line">    activeIndex: <span class="hljs-number">0</span>,<span class="hljs-comment">//当前展示的Tab项索引</span></span><br><span class="line">    sliderWidth: <span class="hljs-number">96</span>,<span class="hljs-comment">//指示器的宽度,计算得到</span></span><br><span class="line">    contentHeight: <span class="hljs-number">0</span><span class="hljs-comment">//页面除去头部Tabbar后，内容区的总高度，计算得到</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">   * 生命周期函数--监听页面加载</span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br><span class="line">  onLoad: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;</span><br><span class="line">    wx.getSystemInfo(&#123;</span><br><span class="line">      success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">        <span class="hljs-comment">//计算相关宽度</span></span><br><span class="line">          sliderWidth: res.windowWidth / that.data.tabs.length,</span><br><span class="line">          sliderOffset: res.windowWidth / that.data.tabs.length * that.data.activeIndex,</span><br><span class="line">          contentHeight: res.windowHeight - res.windowWidth / <span class="hljs-number">750</span> * <span class="hljs-number">68</span><span class="hljs-comment">//计算内容区高度，rpx -&gt; px计算</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  bindChange: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> current = e.detail.current;</span><br><span class="line">    <span class="hljs-keyword">this</span>.setData(&#123;</span><br><span class="line">      activeIndex: current,</span><br><span class="line">      sliderOffset: <span class="hljs-keyword">this</span>.data.sliderWidth * current</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"bindChange:"</span> + current);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  navTabClick: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.setData(&#123;</span><br><span class="line">      sliderOffset: e.currentTarget.offsetLeft,</span><br><span class="line">      activeIndex: e.currentTarget.id</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"navTabClick:"</span> + e.currentTarget.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面的布局代码和js代码其实写起来都不难，关键在于css样式的编写，对于不熟悉CSS的人来说调样式太痛苦了。这个效果也是我调了好半天，参考了好多代码之后写出来的，真o(╯□╰)o，看来想写好小程序还得好好学学CSS样式。</p><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做过&lt;code&gt;android&lt;/code&gt;的都知道在&lt;code&gt;android&lt;/code&gt;里面实现&lt;code&gt;Tab切换&lt;/code&gt;非常简单，使用&lt;code&gt;android&lt;/code&gt;提供的&lt;code&gt;TabLayout+ViewPager&lt;/code&gt;很容器就实现了&lt;code&gt;Tab切换&lt;/code&gt;的效果。&lt;/p&gt;
&lt;p&gt;但是小程序中是没有提供类似可以直接使用的组件，因此想要实现此功能需要我们自己去编码实现。在&lt;a href=&quot;http://ittiger.cn/weixin-xcx-first-project.html&quot;&gt;上一篇&lt;/a&gt;文章中我提到的小程序练手项目就实现了&lt;code&gt;Tab切换&lt;/code&gt;效果，具体效果图可以参考文章&lt;a href=&quot;http://ittiger.cn/weixin-xcx-first-project.html&quot;&gt;微信小程序入门项目&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="小程序" scheme="http://ittiger.cn/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="http://ittiger.cn/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序之入门项目</title>
    <link href="http://ittiger.cn/weixin-xcx-first-project.html"/>
    <id>http://ittiger.cn/weixin-xcx-first-project.html</id>
    <published>2017-07-17T09:40:39.000Z</published>
    <updated>2019-05-09T09:55:20.735Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习微信小程序，尝试着写了一个足球视频播放的小程序，先放效果截图吧</p><a id="more"></a><p><img src="/img/weixin-xcx/1.jpg" width="400"></p><p><img src="/img/weixin-xcx/2.jpg" width="400"></p><p><img src="/img/weixin-xcx/3.jpg" width="400"></p><hr><p>通过这个小程序的练习熟悉小程序中网络加载，页面编写和配置，页面跳转及传参，页面展示时的数据绑定以及独立模块的引用等知识点。</p><p>当然写小程序最重要的一点是必须要熟悉CSS样式的编写，对于我这种对CSS不熟的人来说真是太困难了。一个界面效果都需要调上半天。</p><p>项目代码地址如下：<br><a href="https://github.com/huyongli/WXSoccerVideo" target="_blank" rel="noopener">https://github.com/huyongli/WXSoccerVideo</a></p><hr><p>原创文章，严禁随意转载。欢迎大家添加个人微信讨论交流，添加时请备注：姓名 + 方向，否则可能不予通过。<br><img src="/img/weixinCode.jpeg" width="200" height="200" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习微信小程序，尝试着写了一个足球视频播放的小程序，先放效果截图吧&lt;/p&gt;
    
    </summary>
    
      <category term="小程序" scheme="http://ittiger.cn/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="http://ittiger.cn/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
</feed>
