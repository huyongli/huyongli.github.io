<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[【译】Room 🔗 Coroutines]]></title>
      <url>http://ittiger.cn/Room-Coroutines.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>原文链接：<a href="https://medium.com/androiddevelopers/room-coroutines-422b786dc4c5" target="_blank" rel="noopener">https://medium.com/androiddevelopers/room-coroutines-422b786dc4c5</a><br>作者：<a href="https://medium.com/@florina.muntenescu" target="_blank" rel="noopener">Florina Muntenescu
</a></p>
</blockquote>
<p><code>Room</code>从2.1版本(目前已更新到2.2.0-alpha03版本)开始添加了对<code>kotlin</code>协程的支持。现在我们可以使用<code>suspend</code>关键字将<code>DAO</code>中的方法声明为挂起函数，从而保证这些方法不在主线程中执行。请继续阅读以理解如何在<code>Room</code>中使用协程，它的工作原理，以及如何测试这个新功能。</p>
<a id="more"></a>
<h3 id="给你的数据库添加suspend特性"><a href="#给你的数据库添加suspend特性" class="headerlink" title="给你的数据库添加suspend特性"></a>给你的数据库添加suspend特性</h3><p>如果想在你的APP中使用协程来操作<code>Room数据库</code>，那么必须将项目中的<code>Room</code>版本升级为2.1版本，同时在<code>build.gradle</code>文件添加如下依赖：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &quot;androidx.room:room-coroutines:$&#123;versions.room&#125;&quot;</span><br></pre></td></tr></table></figure></p>
<p>另外你的<code>kotlin</code>版本至少为<code>1.3.0</code>，<code>Coroutines</code>版本至少为<code>1.0.0</code></p>
<p>现在你可以将<code>DAO</code>中的方法使用<code>suspend</code>关键字将其定义为挂起函数了<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//具有suspend方法的DAO代码示例</span><br><span class="line">@Dao</span><br><span class="line">interface UsersDao &#123;</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * FROM users&quot;)</span><br><span class="line">    suspend fun getUsers(): List&lt;User&gt;</span><br><span class="line"></span><br><span class="line">    @Query(&quot;UPDATE users SET age = age + 1 WHERE userId = :userId&quot;)</span><br><span class="line">    suspend fun incrementUserAge(userId: String)</span><br><span class="line"></span><br><span class="line">    @Insert</span><br><span class="line">    suspend fun insertUser(user: User)</span><br><span class="line"></span><br><span class="line">    @Update</span><br><span class="line">    suspend fun updateUser(user: User)</span><br><span class="line"></span><br><span class="line">    @Delete</span><br><span class="line">    suspend fun deleteUser(user: User)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>@Transaction</code>声明的方法也可以定义为挂起函数，同时它也可以调用<code>DAO</code>中其他的挂起函数<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//具有事务挂起功能的DAO代码示例</span><br><span class="line">@Dao</span><br><span class="line">abstract class UsersDao &#123;</span><br><span class="line">    </span><br><span class="line">    @Transaction</span><br><span class="line">    open suspend fun setLoggedInUser(loggedInUser: User) &#123;</span><br><span class="line">        deleteUser(loggedInUser)</span><br><span class="line">        insertUser(loggedInUser)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Query(&quot;DELETE FROM users&quot;)</span><br><span class="line">    abstract fun deleteUser(user: User)</span><br><span class="line"></span><br><span class="line">    @Insert</span><br><span class="line">    abstract suspend fun insertUser(user: User)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你也可以在事务中调用不同<code>DAO</code>的挂起函数<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//在一个事务中调用两个不同DAO的挂起函数</span><br><span class="line">class Repository(val database: MyDatabase) &#123;</span><br><span class="line"></span><br><span class="line">    suspend fun clearData()&#123;</span><br><span class="line">        database.withTransaction &#123;</span><br><span class="line">            database.userDao().deleteLoggedInUser() // suspend function</span><br><span class="line">            database.commentsDao().deleteComments() // suspend function</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认情况<code>Room</code>会使用架构组件的<code>IO Executor</code>来执行SQL语句，但我们也可以在构建<code>Room</code>数据库的时候，通过调用<code>setTransactionExecutor</code>和<code>setQueryExecutor</code>这两个方法来自定义执行SQL语句的<code>Executor</code></p>
<h3 id="测试DAO中的挂起函数"><a href="#测试DAO中的挂起函数" class="headerlink" title="测试DAO中的挂起函数"></a>测试DAO中的挂起函数</h3><p>测试<code>DAO</code>中的挂起函数和测试其他普通的挂起函数没有什么不同。   </p>
<p>例如我们要测试用户信息被插入后能够被检索到，我们可以将测试代码块放在<code>runBlock</code>块中：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test </span><br><span class="line">fun insertAndGetUser() = runBlocking &#123;</span><br><span class="line">    // Given a User that has been inserted into the DB</span><br><span class="line">    userDao.insertUser(user)</span><br><span class="line"></span><br><span class="line">    // When getting the Users via the DAO</span><br><span class="line">    val usersFromDb = userDao.getUsers()</span><br><span class="line"></span><br><span class="line">    // Then the retrieved Users matches the original user object</span><br><span class="line">    assertEquals(listOf(user), userFromDb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>为了了解<code>Room</code>支持协程的实现原理，我们来看看<code>Room</code>为同步方法和挂起函数生成的<code>DAO</code>方法实现<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//DAO中同步和挂起函数的定义插入操作</span><br><span class="line"></span><br><span class="line">@Insert</span><br><span class="line">fun insertUserSync(user: User)</span><br><span class="line"></span><br><span class="line">@Insert</span><br><span class="line">suspend fun insertUser(user: User)</span><br></pre></td></tr></table></figure></p>
<p>对于同步插入，生成的代码首先开启了一个事务，接着执行数据插入操作，然后标记事务成功，最后结束事务。生成的代码如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void insertUserSync(final User user) &#123;</span><br><span class="line">  __db.beginTransaction();</span><br><span class="line">  try &#123;</span><br><span class="line">    __insertionAdapterOfUser.insert(user);</span><br><span class="line">    __db.setTransactionSuccessful();</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    __db.endTransaction();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码也可以看出来在任何线程中调用同步插入方法都会在该线程中直接执行插入操作。</p>
<p>接下来让我们来看看使用了<code>suspend</code>关键字修饰的挂起函数生成的代码是什么样的：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object insertUserSuspend(final User user,</span><br><span class="line">    final Continuation&lt;? super Unit&gt; p1) &#123;</span><br><span class="line">  return CoroutinesRoom.execute(__db, new Callable&lt;Unit&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Unit call() throws Exception &#123;</span><br><span class="line">      __db.beginTransaction();</span><br><span class="line">      try &#123;</span><br><span class="line">        __insertionAdapterOfUser.insert(user);</span><br><span class="line">        __db.setTransactionSuccessful();</span><br><span class="line">        return kotlin.Unit.INSTANCE;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        __db.endTransaction();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, p1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的生成代码确保了插入操作不会在<code>UI线程</code>中执行。<br>在生成的<code>suspend</code>函数的中，传入了一个<code>Continuation</code>和待插入的数据，同时它的插入逻辑和同步插入逻辑相同，只是它的插入逻辑被封装在<code>Callable</code>中。</p>
<p>另外我们可以看到，生成的函数一开始会调用<code>CoroutinesRoom.execute</code>函数，实际上该函数会根据数据库是否打开，是否处于事务来决定如何切换上下文。</p>
<p><code>CoroutinesRoom.execute</code>方法实现如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@JvmStatic</span><br><span class="line">suspend fun &lt;R&gt; execute(</span><br><span class="line">   db: RoomDatabase,</span><br><span class="line">   inTransaction: Boolean,</span><br><span class="line">   callable: Callable&lt;R&gt;</span><br><span class="line">): R &#123;</span><br><span class="line">   if (db.isOpen &amp;&amp; db.inTransaction()) &#123;</span><br><span class="line">       return callable.call()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Use the transaction dispatcher if we are on a transaction coroutine, otherwise</span><br><span class="line">   // use the database dispatchers.</span><br><span class="line">   val context = coroutineContext[TransactionElement]?.transactionDispatcher</span><br><span class="line">       ?: if (inTransaction) db.transactionDispatcher else db.queryDispatcher</span><br><span class="line">   return withContext(context) &#123;</span><br><span class="line">       callable.call()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="情况1：数据库打开且处于事务中"><a href="#情况1：数据库打开且处于事务中" class="headerlink" title="情况1：数据库打开且处于事务中"></a>情况1：数据库打开且处于事务中</h4><p>这种情况会直接执行<code>Callable.call()</code>方法，也就是数据库的实际插入操作。</p>
<p>这种情况下<code>Room</code>不会对操作数据库的协程上下文做任何处理，因此调用者需要自己确保调用<code>Room</code>操作的协程上下文环境不是<code>Dispatcher.Main</code></p>
<h4 id="情况2：非事务"><a href="#情况2：非事务" class="headerlink" title="情况2：非事务"></a>情况2：非事务</h4><p>这种情况下<code>Room</code>会确保<code>Callable.call()</code>操作是在后台线程中完成的。</p>
<p>对于事务和查询<code>Room</code>会采用不同的<code>Dispatchers</code>，这些<code>Dispatchers</code>来源于构建<code>Room数据库</code>时我们自己自定义的<code>Dispatchers</code>，或者是系统默认提供的架构组件<code>IO Executor</code>，这和使<code>LiveData</code>处于后台运行的<code>Dispatchers</code>是一样的。</p>
<p>如果有兴趣研究具体的实现原理，可以查看<a href="https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-master-dev/room/ktx/src/main/java/androidx/room/CoroutinesRoom.kt" target="_blank" rel="noopener">CoroutinesRoom.kt</a>和<a href="https://android.googlesource.com/platform/frameworks/support/+/refs/heads/androidx-master-dev/room/ktx/src/main/java/androidx/room/RoomDatabase.kt" target="_blank" rel="noopener">RoomDatabase.kt</a>的源码</p>
<hr>
<p>在你的APP中使用<code>Room</code>和协程吧，保证数据库的操作在<code>non-UI Dispatcher</code>中执行。使用<code>suspend</code>将<code>DAO</code>中的方法定义为挂起函数，并从其他挂起函数或协程中调用他们。</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> 译 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 译 </tag>
            
            <tag> Room </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java多线程之先行发生原则(happens-before)]]></title>
      <url>http://ittiger.cn/Java-Happends-Before.html</url>
      <content type="html"><![CDATA[<p>前面介绍了Java内存模型及内存屏障相关概念，这篇文章接着介绍多线程编程另外一个比较重要的概念：先行发生原则（happens-before）。</p>
<h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>happens-before是判断数据是否存在竞争，线程是否安全的主要依据，通过这个原则，我们可以解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p>
<h3 id="happens-before是什么"><a href="#happens-before是什么" class="headerlink" title="happens-before是什么"></a>happens-before是什么</h3><p>它Java内存模型中针对两项操作定义的偏序关系。例如操作A先行于操作B发生，那么操作B可以观察到操作A所产生的所有影响，这些影响包括修改内存中共享变量的值、发送的消息，调用的方法等。</p>
<a id="more"></a>
<p>举个例子：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//该操作在线程1中执行</span></span><br><span class="line">i = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//该操作在线程2中执行</span></span><br><span class="line">j = i;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//该操作在线程3中执行</span></span><br><span class="line">i = <span class="hljs-number">2</span></span><br></pre></td></tr></table></figure></p>
<p>上述例子中有共享变量i和j，假设线程1中执行的操作“i=1”先于线程2中的操作“j=i”发生，那共享变量j的值肯定为1。</p>
<p>得出这个结论是因为根据happens-before原则：“i=1”操作可以被观察到，而线程3还没有开始。</p>
<p>如果依旧假定操作“i=1”和操作“j=i”的先行发生关系，而线程3开始于线程1和线程2之间，线程3与线程2之间没有先行发生关系，最后变量j的值是多少呢？结果可能是1也可能是2。这种情况线程3对变量i的影响可能会被线程B观察到，也可能不会被观察到，当没有被线程B观察到的时候，线程B就会读取到过期的旧数据，这个时候就出现了多线程安全性问题。</p>
<h3 id="happens-before的8条规则"><a href="#happens-before的8条规则" class="headerlink" title="happens-before的8条规则"></a>happens-before的8条规则</h3><p>Java内存模型中已经存在8条定义好的先行发生规则，这些先行发生规则不需要任何同步操作就已经存在，如果两个操作之间的关系不在这几天规则或则无法通过这几条规则推导出来，那这两个操作就没有顺序保障，虚拟机就可以对他们进行重排。</p>
<p>具体操作如下：</p>
<ol>
<li>程序次序规则：在同一个线程中，按照程序代码顺序，写在前面的操作先行发生与写在后面操作(控制流顺序：分支、循环等)。</li>
<li>锁规则：一个unlock操作先行发生于后面(时间上)对同一个锁的lock操作</li>
<li>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个操作</li>
<li>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测(可以通过Thread.join()等待线程结束、Thread.isAlive()返回值)。</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的检测到中断事件的代码</li>
<li>对象终结规则：一个对象的初始化完成先行发生于对象的finalize()方法的开始</li>
<li>传递性规则：如果操作A先行发生于操作B，操作B先行发生于操作C，那操作A就先行发生于操作C</li>
</ol>
<h4 id="happens-before规则示例"><a href="#happens-before规则示例" class="headerlink" title="happens-before规则示例"></a>happens-before规则示例</h4><p>下面通过一个示例来看看如何通过这些规则来判断操作之间是否具有顺序性，而对于读写共享变量的操作来说，就是现场是否安全。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子是一段很简单的代码，假定有线程1和线程2，线程1先（时间上先）调用”setValue(1)”，然后线程2调用”getValue()”，最后线程2得到的值是多少？</p>
<p>我们根据前面提到的8个规则来分析下：</p>
<ul>
<li>因为两个方法分别在线程1和线程2中执行，不是同一个线程，因此程序次序规则不适用</li>
<li>代码中没有任何同步代码块(锁)，因此锁规则也不适用</li>
<li>代码中value变量为非volatile变量，因此volatile变量规则也不适用</li>
<li>整个执行过程很明显和线程启动、终止、中断、对象终结规则也没有关系</li>
<li>因为没有任何先行发生关系，所以传递性规则也不适用</li>
</ul>
<p>根据上面的分析，虽然线程1在操作时机上先于线程2，但是因为没有任何先行发生关系，所以无法确定线程2中”getValue()”的值，因此这两个线程的操作放在一起是不安全的。</p>
<p>要解决这个问题也很简单，一种是将setValue和getValue两个方法都定义为synchronized方法，这样就可以套用锁规则，另外一种是将value变量定义为volatile变量，而且这里修改value值的时候不依赖value的原值，所以就可以套用volatile变量规则。</p>
<p>通过上面的分析，我们可以知道一个操作“时间上的先发生”不代表这个操作会“先行发生”。</p>
<p>那一个操作“先行发生”是不是“时间上也是先发生”呢，这个其实也是不能保证的，典型的例子就是指令重排，例如下面的例子：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//下面两个操作在同一个线程中执行</span></span><br><span class="line"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;  <span class="hljs-comment">//操作1</span></span><br><span class="line"><span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>;  <span class="hljs-comment">//操作2</span></span><br></pre></td></tr></table></figure></p>
<p>上面的示例中，按照线程次序规则，操作1先行发生于操作2，但是操作2在实际执行过程中很可能因为重排序而被处理器先执行，这样也没有影响先行发生原则的正确性，因为在这个线程中我们无法感知到这种变化。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>时间上的先后顺序与先行发生原则之间没有基本的关系，因此我们在衡量线程安全与否时不要关注时间顺序，而是应该关注先行发生原则。</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
            <category> 多线程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java多线程之volatile关键字及内存屏障]]></title>
      <url>http://ittiger.cn/Java-volatile-memory-barrier.html</url>
      <content type="html"><![CDATA[<p>前面一篇文章在介绍Java内存模型的三大特性(原子性、可见性、有序性)时，在可见性和有序性中都提到了volatile关键字，那这篇文章就来介绍volatile关键字的内存语义以及实现其特性的内存屏障。</p>
<p>volatile是JVM提供的一种最轻量级的同步机制，因为Java内存模型为volatile定义特殊的访问规则，使其可以实现Java内存模型中的两大特性：可见性和有序性。正因为volatile关键字具有这两大特性，所以我们可以使用volatile关键字解决多线程中的某些同步问题。</p>
<h3 id="volatile的可见性"><a href="#volatile的可见性" class="headerlink" title="volatile的可见性"></a>volatile的可见性</h3><p>volatile的可见性是指当一个变量被volatile修饰后，这个变量就对所有线程均可见。白话点就是说当一个线程修改了一个volatile修饰的变量后，其他线程可以立刻得知这个变量的修改，拿到最这个变量最新的值。</p>
<a id="more"></a>
<p>结合前一篇文章提到的Java内存模型中线程、工作内存、主内存的交互关系，我们对volatile的可见性也可以这么理解，定义为volatile修饰的变量，在线程对其进行写入操作时不会把值缓存在工作内存中，而是直接把修改后的值刷新回写到主内存，而当处理器监控到其他线程中该变量在主内存中的内存地址发生变化时，会让这些线程重新到主内存中拷贝这个变量的最新值到工作内存中，而不是继续使用工作内存中旧的缓存。</p>
<p>下面我列举一个利用volatile可见性解决多线程并发安全的示例：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//private static boolean isReady = false;</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> isReady = <span class="hljs-keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">while</span> (!isReady) &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="hljs-string">"ReadyThread finish"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">new</span> ReadyThread().start();</span><br><span class="line">        Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">//sleep 1秒钟确保ReadyThread线程已经开始执行</span></span><br><span class="line">        isReady = <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码运行之后最终会在控制台打印出：<strong>ReadyThread finish</strong>，而当你将变量isReady的volatile修饰符去掉之后再运行则会发现程序一直运行而不结束，而控制台也没有任何打印输出。</p>
<p>我们分析下这个程序：初始时isReady为false，所以ReadyThread线程启动开始执行后，它的while代码块因标志位isReady为false会进入死循环，当用volatile关键字修饰isReady时，main方法所在的线程将isReady修改为true之后，ReadyThread线程会立刻得知并获取这个最新的isReady值，紧接着while循环就会结束循环，所以最后打印出了相关文字。而当未用volatile修饰时，main方法所在的线程虽然修改了isReady变量，但ReadyThread线程并不知道这个修改，所以使用的还是之前的旧值，因此会一直死循环执行while语句。</p>
<h3 id="volatile的有序性"><a href="#volatile的有序性" class="headerlink" title="volatile的有序性"></a>volatile的有序性</h3><p>有序性是指程序代码的执行是按照代码的实现顺序来按序执行的。</p>
<p>volatile的有序性特性则是指禁止JVM指令重排优化。</p>
<p>我们来看一个例子：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-comment">//private static volatile Singleton instance = null;</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//第一次判断</span></span><br><span class="line">        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                    <span class="hljs-comment">//初始化，并非原子操作</span></span><br><span class="line">                    instance = <span class="hljs-keyword">new</span> Singleton(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码是一个很常见的单例模式实现方式，但是上述代码在多线程环境下是有问题的。为什么呢，问题出在instance对象的初始化上，因为<code>instance = new Singleton();</code>这个初始化操作并不是原子的，在JVM上会对应下面的几条指令：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();    //1. 分配对象的内存空间 </span><br><span class="line">ctorInstance(memory);  //2. 初始化对象 </span><br><span class="line">instance =memory;     //3. 设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure></p>
<p>上面三个指令中，步骤2依赖步骤1，但是步骤3不依赖步骤2，所以JVM可能针对他们进行指令重拍序优化，重排后的指令如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();    //1. 分配对象的内存空间 </span><br><span class="line">instance =memory;     //3. 设置instance指向刚分配的内存地址</span><br><span class="line">ctorInstance(memory);  //2. 初始化对象</span><br></pre></td></tr></table></figure></p>
<p>这样优化之后，内存的初始化被放到了instance分配内存地址的后面，这样的话当线程1执行步骤3这段赋值指令后，刚好有另外一个线程2进入getInstance方法判断instance不为null，这个时候线程2拿到的instance对应的内存其实还未初始化，这个时候拿去使用就会导致出错。</p>
<p>所以我们在用这种方式实现单例模式时，会使用volatile关键字修饰instance变量，这是因为volatile关键字除了可以保证变量可见性之外，还具有防止指令重排序的作用。当用volatile修饰instance之后，JVM执行时就不会对上面提到的初始化指令进行重排序优化，这样也就不会出现多线程安全问题了。</p>
<h3 id="volatile使用场景"><a href="#volatile使用场景" class="headerlink" title="volatile使用场景"></a>volatile使用场景</h3><p>volatile的可以在以下场景中使用：   </p>
<ul>
<li>当运算结果不依赖变量当前的值，或者能确保只有单一线程修改变量的值的时候，我们才可以对该变量使用volatile关键字</li>
<li>变量不需要与其他状态变量共同参与不变约束</li>
</ul>
<h3 id="volatile与原子性"><a href="#volatile与原子性" class="headerlink" title="volatile与原子性"></a>volatile与原子性</h3><p>volatile关键字能保证变量的可见性和代码的有序性，但是不能保证变量的原子性，下面我再举一个volatile与原子性的例子：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increase</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="hljs-keyword">new</span> Thread[<span class="hljs-number">20</span>];</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threads.length; i++) &#123;</span><br><span class="line">            threads[i] = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;</span><br><span class="line">                    increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//等待所有累加线程结束</span></span><br><span class="line">        <span class="hljs-keyword">while</span> (Thread.activeCount() &gt; <span class="hljs-number">1</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码创建了20个线程，每个线程对变量count进行1000次自增操作，如果这段代码并发正常的话，结果应该是20000，但实际运行过程中经常会出现小于20000的结果，因为count++这个自增操作不是原子操作。</p>
<p>上面的count++自增操作等价于count=count+1，所以JVM需要先读取count的值，然后在count的基础上给它加1，然后再将新的值重新赋值给count变量，所以这个自增总共需要三步。</p>
<p><img src="/img/java-memory-model/count_increase.png" alt></p>
<p>上图中我将线程对count的自增操作画了个简单的流程，一个线程要对count进行自增时要先读取count的值，然后在当前count值的基础上进行count+1操作，最后将count的新值重新写回到count。</p>
<p>如果线程2在线程1读取count旧值写回count新值期间读取count的值，显然这个时候线程2读取的是count还未更新的旧值，这时两个线程是对同一个值进行了+1操作，这样这两个线程就没有对count实现累加效果，相反这些操作却又没有违反volatile的定义，所以这种情况下使用volatile依然会存在多线程并发安全的问题。</p>
<h3 id="volatile与内存屏障"><a href="#volatile与内存屏障" class="headerlink" title="volatile与内存屏障"></a>volatile与内存屏障</h3><p>前面介绍了volatile的可见性和有序性，那JVM到底是如何为volatile关键字实现的这两大特性呢，Java内存模型其实是通过内存屏障(Memory Barrier)来实现的。</p>
<p>内存屏障其实也是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些内存屏障指令来禁止特定的指令重排序。</p>
<p>另外内存屏障还具有一定的语义：内存屏障之前的所有写操作都要回写到主内存，内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。</p>
<p>下面的表是volatile有关的禁止指令重排的行为：</p>
<table>
<thead>
<tr>
<th>第一个操作</th>
<th>第二个操作：普通读写</th>
<th>第二个操作：volatile读</th>
<th>第二个操作：volatile写</th>
</tr>
</thead>
<tbody>
<tr>
<td>普通读写</td>
<td>可以重排</td>
<td>可以重排</td>
<td>不可以重排</td>
</tr>
<tr>
<td>volatile读</td>
<td>不可以重排</td>
<td>不可以重排</td>
<td>不可以重排</td>
</tr>
<tr>
<td>volatile写</td>
<td>可以重排</td>
<td>不可以重排</td>
<td>不可以重排</td>
</tr>
</tbody>
</table>
<p>从上面的表我们可以得出下面这些结论：   </p>
<ol>
<li>当第二个操作volatile写时，不论第一个操作是什么，都不能重排序。这个规则保证了volatile写之前的操作不会被重排到volatile写之后。</li>
<li>当第一个操作为volatile读时，不论第二个操作是什么，都不能重排。这个操作保证了volatile读之后的操作不会被重排到volatile读之前。</li>
<li>当第一个操作为volatile写，第二个操作为volatile读时，不能重排。</li>
</ol>
<p>JVM中提供了四类内存屏障指令：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LoadLoad</td>
<td>Load1; LoadLoad; Load2</td>
<td>保证load1的读取操作在load2及后续读取操作之前执行</td>
</tr>
<tr>
<td>StoreStore</td>
<td>Store1; StoreStore; Store2</td>
<td>在store2及其后的写操作执行前，保证store1的写操作已刷新到主内存</td>
</tr>
<tr>
<td>LoadStore</td>
<td>Load1; LoadStore; Store2</td>
<td>在stroe2及其后的写操作执行前，保证load1的读操作已读取结束</td>
</tr>
<tr>
<td>StoreLoad</td>
<td>Store1; StoreLoad; Load2</td>
<td>保证store1的写操作已刷新到主内存之后，load2及其后的读操作才能执行</td>
</tr>
</tbody>
</table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>volatile实现了Java内存模型中的可见性和有序性，它的这两大特性则是通过内存屏障来实现的，同时volatile无法保证原子性。</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
            <category> 多线程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java多线程之Java内存模型]]></title>
      <url>http://ittiger.cn/Java-Memory-Model.html</url>
      <content type="html"><![CDATA[<p>在介绍Java内存模型之前，我们先介绍一下计算机硬件的内存模型，因为JVM的并发和物理机器的并发很相似，甚至JVM并发操作中很多设计都是因为计算机系统的设计引发的。</p>
<h3 id="硬件的内存模型"><a href="#硬件的内存模型" class="headerlink" title="硬件的内存模型"></a>硬件的内存模型</h3><p>大家都知道计算机系统处理任务主要是靠处理器(CPU)来进行运算的，而运算中又会涉及到数据，数据在哪呢，数据自然是存储在计算机内存中，所以处理器在运算过程中不可避免的会涉及到与内存的读写交互，比如读取运算所需的数据，存储运算得到的数据结果等。而处理器的运算速度相比物理内存的读写速度要快得多，所以会出现处理器要等待内存数据读写结束后才能进行下一步的运算，因此为了提高计算机的运算速度，现在的计算机系统为处理器添加了一层读写速度尽量接近处理器的高速缓存来缓解内存与处理器之间的性能差异。这样在处理任务时将运算需要的数据复制到缓存中，运算结束后再将数据从缓存中同步写回到内存，这样处理器在运算时就不需要等待内存数据读写结束了。</p>
<a id="more"></a>
<p>处理器、高速缓存、内存之间的交互关系图如下：</p>
<p><img src="/img/java-memory-model/computer_diagram.png" alt></p>
<p>如上图所示，在多处理器系统中因为每个处理器都有自己的高速缓存，所以这就引发了一个新的问题，如果多个处理器的运算任务都涉及同一块内存区域，就可能导致各自的高速缓存数据不一致，那这个时候从高速缓存写回主内存的数据以谁为准呢？这就是引入高速缓存引发的新问题，我们称之为：缓存一致性。</p>
<p>为了解决缓存一致性的问题，现代计算机系统需要各个处理器读写缓存时遵循一些协议（MSI、MESI、MOSI、Synapse、Firefly、DragonProtocal，这些都是缓存协议），按照协议来进行读写访问缓存。</p>
<p>既然这里说的是“硬件的内存模型”，那什么是内存模型呢？</p>
<blockquote>
<p>内存模型可以理解为在特定的操作协议下，对特定的内存和高速缓存进行读写访问的抽象。不同的物理机器，可能有着不同的“内存模型”。</p>
</blockquote>
<p>除了为处理器增加高速缓存之外，处理器还会对输入的代码程序进行乱序执行优化，保证该乱序执行之后的结果和顺序执行的结果一致。举个例子：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 2;</span><br><span class="line">int c = a + b;</span><br></pre></td></tr></table></figure></p>
<p>上面的这段代码将第一行和第二行调换顺序对最终的结果没有任何的影响。而处理器在实际运算过程中为了优化性能，也会对代码的执行顺序进行类似的调换(保证结果不变的前提下)，这种执行顺序的调换称之为指令重排序，而JVM中也存在类似的指令重排序优化功能。至于为什么指令重排序会优化性能，它是如何优化性能的，这就涉及到汇编指令的知识，我也不懂汇编指令，这里就不介绍了，有兴趣的可以自己去了解了解。</p>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>前面说过不同的物理机器，可能有着不同的“内存模型”，而Java虚拟机中定义的内存模型可以屏蔽不同的硬件内存模型，这样就可以保证Java程序在各个平台都能达到一致的内存访问效果，也就是常说的一次编写到处运行，因为内存模型为我们屏蔽掉了不同硬件平台之间的差异。</p>
<h4 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h4><p>Java内存模型中规定所有变量都存储在主内存(虚拟机内存的一部分)中，主要对应Java的堆内存。这里提到的变量实际上是指共享变量，存在线程间竞争的变量，如：实例变量、静态变量和构成数组对象的元素，而局部变量和方法参数因为是线程私有的，所以不存在线程间共享和竞争关系，所以也就不在前面提到的变量范围内。</p>
<p>每个线程有着自己独有的工作内存，工作内存中保存了被该线程使用到的变量，这些变量来自主内存变量的副本拷贝。线程对变量的所有读写操作都必须在工作内存中进行，不能直接读写主内存中的变量。而不同线程间的工作内存也是独立的，一个线程无法访问其他线程的工作内存中的变量。</p>
<p>线程工作时，把需要的变量从主内存中拷贝到自己的工作内存，线程运行结束之后再将自己工作内存中的变量写回到主内存中，而多个线程间对变量的交互只能通过主内存来间接实现。具体的线程、工作内存、主内存的交互关系图如下：</p>
<p><img src="/img/java-memory-model/thread_diagram.png" alt></p>
<p>通过上面的图和前面的介绍，我们就很容易明白我们平常所说的多线程编程时遇到数据状态不一致的问题是怎么产生的。例如：线程1和线程2都需要操作主内存中的共享变量A，当线程1已经在工作内存中修改了共享变量A副本的值但是还没有写回主内存，这时线程2拷贝了主内存中共享变量A到自己的工作内存中，紧接着线程1将自己工作内存中修改过的共享变量A的副本写回到了主内存，很明显线程2加载的共享变量A是之前的旧状态的数据，这样就产生了数据状态不一致的问题。</p>
<h4 id="Java内存模型和硬件内存模型的关系"><a href="#Java内存模型和硬件内存模型的关系" class="headerlink" title="Java内存模型和硬件内存模型的关系"></a>Java内存模型和硬件内存模型的关系</h4><p>大家看前面的Java内存模型交互图和硬件内存模型交互图可以发现两种内存模型其实是很相似的，实际上Java程序在运行过程中，最终还是会映射到具体的硬件处理器内核上，但java内存模型和硬件的内存模型并不完全一致。</p>
<p>对于硬件内存来说只有寄存器、高速缓存、主内存的概念，并没有工作内存(线程私有数据区)和主内存(JVM堆内存)之分，它们只是java内存模型的一种抽象概念并不是实际存在的，因此java内存模型对内存的划分对硬件内存并没有任何影响。</p>
<p>在java内存模型中，无论是工作内存还是主内存，它们都有可能存储到硬件的主内存、高速缓存或者是寄存器中，所以java内存模型和硬件内存模型是是一种抽象概念和真实物理硬件的交叉关系。关系图如下：</p>
<p><img src="/img/java-memory-model/computer_thread_diagram.png" alt></p>
<h4 id="内存交互"><a href="#内存交互" class="headerlink" title="内存交互"></a>内存交互</h4><p>前面说到工作内存与主内存会进行数据读写交互，这个读写交互具体实现细节则是由Java内存模型来控制的，Java内存模型为主内存和工作内存间的变量拷贝及同步写回定义了具体的实现协议，该协议主要由8种操作来完成，不同虚拟机在实现时必须保证每一个基本数据类型的操作都是原子性不可再分的（long，double类型的变量在某些平台可以例外，虽然在JVM规范中没有强制要求long，double类型具有原子性，但是规范建议各JVM实现成具有原子性的，实际上市面上的JVM也基本都实现了原子性），具体8种操作如下：   </p>
<ul>
<li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li>
<li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li>load（载入）：作用于工作内存的变量，它把通过read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作使用。</li>
<li>write（写入）：作用于主内存的变量，它把通过store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>线程、工作内存、主内存对应这8种操作的交互关系图如下：</p>
<p><img src="/img/java-memory-model/thread_diagram_operation.png" alt></p>
<p>按照上面的8种内存交互操作，如果要把一个变量从主内存复制到工作内存，就需要顺序的执行read和load操作，而如果要把一个变量从工作内存同步回主内存，则需要顺序执行store和write操作，这里说的是顺序执行，而不是连续执行，这也就意味着两个操作之间可以插入其他操作，例如对主内存中的变量1和变量2访问时，一种可能的顺序是read 1, read 2, load 2, load 1。</p>
<p>除此之外，Java内存模型对这8中操作还存在着其他的约束：   </p>
<ul>
<li>只允许read和load、store和write这两对操作成对出现。</li>
<li>不允许线程丢弃它的最近的assign操作，即变量在工作内存中改变之后，必须同步回写到主内存。</li>
<li>不允许线程把没有经过assign操作的变量，同步回写到主内存。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中使用未经初始化的变量，即对一个变量进行use、store操作之前，必须先执行过load、assign操作。</li>
<li>一个变量在同一时刻只能被一条线程执行lock操作，一旦lock成功，可以被同一线程重复lock多次，多次执行lock之后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>对一个变量执行lock操作，将会清空工作内存中该变量的值，所以在执行引擎使用这个变量前，需要重新执行load或assign操作对其进行初始化。</li>
<li>对一个变量执行unlock操作之前，必须先把该变量同步回主内存(执行store、write操作)。</li>
<li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许unlock一个被其他线程lock的变量。</li>
</ul>
<h3 id="Java内存模型的3个特征"><a href="#Java内存模型的3个特征" class="headerlink" title="Java内存模型的3个特征"></a>Java内存模型的3个特征</h3><p>Java内存模型其实一直是围绕着并发过程中的如何处理原子性、可见性和有序性这三个特征建立的。</p>
<h4 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h4><p>什么是原子性呢，原子性是指一个操作不可中断，不可分割，在多线程中就是指一旦一个线程开始执行某个操作，就不能被其他线程干扰。</p>
<p>Java内存模型直接用来保证原子性变量的操作包括use、read、load、assign、store、write，我们大致可以认为Java基本数据类型的访问都是原子性的（long，double除外，前面已经介绍过了），如果用户要操作一个更大的范围保证原子性，Java内存模型还提供了lock和unlock来满足这种需求，但是这两种操作没有直接开放给用户，而是提供了两个更高层次的字节码指令：monitorenter 和 moniterexit，这两个指令对应到Java代码中就是synchronized关键字，所以synchronized代码块之间的操作具有原子性。</p>
<h4 id="可见性（Visibility）"><a href="#可见性（Visibility）" class="headerlink" title="可见性（Visibility）"></a>可见性（Visibility）</h4><p>可见性是指当一个线程修改了变量之后，其他线程能立刻得知这个修改。</p>
<p>Java内存模型通过将变量修改后将新值同步写回主内存，在读取前从主内存刷新变量值，所以JVM内存模型是通过主内存作为传递介质来实现可见性的。无论是普通变量还是volatile修饰的变量都是这样的，唯一的区别就是volatile变量在被修改之后会立刻写回主内存，而在读取时都会重新去主内存读取最新的值，而普通变量则在被修改后会先存储在工作内存，之后再从工作内存写回主内存，而读的时候则是从工作内存中读取该变量的副本拷贝。</p>
<p>除了volatile可以实现可见性之外，synchronized和final关键字也能实现可见性。synchronized同步块的可见性是因为对一个变量执行unlock操作之前，必须将变量的改动写回主内存来(store、write两个操作)实现的。而final字段则是因为一旦final字段初始化完成，其他线程就可以访问final字段的值，而且final字段初始化完成之后就不再可变。</p>
<h4 id="有序性（Ordering）"><a href="#有序性（Ordering）" class="headerlink" title="有序性（Ordering）"></a>有序性（Ordering）</h4><p>前面说过处理器在执行运算的时候，会对程序代码进行乱序执行优化，也叫做重排序优化。同样的，在JVM中也存在指令重排序优化，这种优化在单线程中是不会存在问题的，但如果这种优化出现在多线程环境中，就可能会出现多线程安全的问题，因为线程1的指令优化可能影响线程2中某个状态。</p>
<p>Java提供了volatile和synchronized关键字来保证线程间操作的有序性。volatile是因为其本身的禁止指令重排序语义来实现的，而synchronized则是由“同一个变量在同一时刻只能有一个线程对其进行lock操作”这条规则来实现的，这也就是synchronized代码块对同一个锁只能串行进入的原因。</p>
<p>上面介绍了Java内存模型的3中特性，我们可以发现synchronized可以说是万能的，它能实现Java多线程中的这3大特性，所以这也早就了很多人在遇到多线程并发操作事都是直接使用synchronized完成，但使用synchronized内置锁会阻塞需要而又没有获取该内置锁的线程，而Java中的线程与操作系统中的原生线程是一一对应的，所以当synchronized内置锁导致某个线程阻塞后，会导致系统从用户态切换到内核态执行阻塞操作，这个操作是非常耗时的。</p>
<p>关于Java内存模型就暂时介绍到这里，接下来的一篇文章会接着介绍更加轻量级的同步实现：volatile关键字，同时还会介绍volatile实现中涉及到的内存屏障。</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
            <category> 多线程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android模块化开发配置]]></title>
      <url>http://ittiger.cn/android-module-develop-config.html</url>
      <content type="html"><![CDATA[<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><ol>
<li>项目由多个模块组成</li>
<li>每个模块都是一个独立的Feature或组件</li>
<li>业务模块间解耦不相互直接依赖</li>
<li>业务模块与公共组件模块通过aar依赖</li>
<li>每个模块独立开发，独立运行调试</li>
</ol>
<h3 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h3><p>当一个项目越来越大，越来越复杂后，代码量就会变得越来大，难以阅读难以维护，业务之间出现耦合的可能性也会越来越大，同时整个APP编译调试的时间也会越来越长。</p>
<p>而使用模块化开发则可以解决以上问题：</p>
<ol>
<li>项目代码结构清晰，每个Feature和公共组件都是一个独立的Library模块</li>
<li>避免每个Library模块间的直接耦合</li>
<li>提升模块的复用性</li>
<li>单个模块独立编译调试速度更快，节省开发时间</li>
<li>只关注自己所在的模块，从而避免其他Feature的异常block自己的Feature开发</li>
</ol>
<p>但是…这篇文章不是教你如何进行模块化开发，而是介绍如何进行模块化开发的工程配置，以满足模块化开发过程中的多团队协作问题。<br><a id="more"></a></p>
<h3 id="模块化开发配置"><a href="#模块化开发配置" class="headerlink" title="模块化开发配置"></a>模块化开发配置</h3><p>我们先创建一个Android工程，这个工程除了有一个app的主module之外，还有两个library类型的module，工程结构如下图：<br><img src="/img/android-modul-code.png" width="200" hegiht="300"></p>
<p>上图中module1和module2就代表了两个不同的业务module</p>
<p><strong>模块化开发配置需要解决哪些问题呢？</strong></p>
<h4 id="module配置参数化"><a href="#module配置参数化" class="headerlink" title="module配置参数化"></a>module配置参数化</h4><p>大家都知道一个项目的主module存在一个build.gradle文件，里面有如下内容：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line">apply plugin: &apos;kotlin-android&apos;</span><br><span class="line">apply plugin: &apos;kotlin-android-extensions&apos;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 28</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId &quot;xxxxxxxxx&quot;</span><br><span class="line">        minSdkVersion 21</span><br><span class="line">        targetSdkVersion 28</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而工程中的library类型的moudle也有一个build.gradle文件，它的内容如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.library&apos;</span><br><span class="line">apply plugin: &apos;kotlin-android&apos;</span><br><span class="line">apply plugin: &apos;kotlin-android-extensions&apos;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion 28</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion 21</span><br><span class="line">        targetSdkVersion 28</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的配置内容可以发现主module和library类型的module除了plugin不一样之外，主module会比library类型module只多一个applicationId。 </p>
<p>所以如果我们想让某个library类型的module能独立运行调试，我们可以通过参数控制，动态的为该module添加相关配置，具体脚本如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//common-build.gradle</span><br><span class="line">project.ext &#123;</span><br><span class="line">    mainModuleType = &quot;mainModule&quot;//主module</span><br><span class="line">    debugLibraryModuleType = &quot;debugLibraryModule&quot;//可单独运行的library module</span><br><span class="line">    libraryModuleType = &quot;libraryModule&quot;</span><br><span class="line"></span><br><span class="line">    //根据module类型动态添加对应的配置</span><br><span class="line">    configModuleGradleScript = &#123; moduleType -&gt;</span><br><span class="line">        applyPlugin(moduleType)</span><br><span class="line">        applyAndroidDefaultConfig()</span><br><span class="line">        applyApplicationId(moduleType)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //配置module的编译版本相关配置</span><br><span class="line">    applyAndroidDefaultConfig = &#123;</span><br><span class="line">        project.android.compileSdkVersion compileSdkVersion</span><br><span class="line">        project.android.defaultConfig.targetSdkVersion targetSdkVersion</span><br><span class="line">        project.android.defaultConfig.minSdkVersion minSdkVersion</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //根据module类型动态添加对应plugin</span><br><span class="line">    applyPlugin = &#123; moduleType -&gt;</span><br><span class="line">        if(moduleType == libraryModuleType) &#123;</span><br><span class="line">            project.apply plugin: &apos;com.android.library&apos;</span><br><span class="line">            project.description &quot;library&quot;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            project.apply plugin: &apos;com.android.application&apos;</span><br><span class="line">            project.description &quot;app&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        project.apply plugin: &apos;kotlin-android&apos;</span><br><span class="line">        project.apply plugin: &apos;kotlin-android-extensions&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //根据module类型动态添加对应的applicationId</span><br><span class="line">    applyApplicationId = &#123; moduleType -&gt;</span><br><span class="line">        if(moduleType == mainModuleType) &#123;</span><br><span class="line">            project.android.defaultConfig.applicationId applicationId</span><br><span class="line">        &#125; else if(moduleType == debugLibraryModuleType) &#123;</span><br><span class="line">            project.android.defaultConfig.applicationId applicationId + &quot;.&quot; + project.name</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到所有的动态配置脚本我都是通过在<code>project.ext</code>中添加闭包实现的，这样做的好处是在其他脚本文件中也可以引用project.ext中定义的闭包和变量</p>
<p>另外上面的配置中，在配置可单独调试library module时，我对其<code>applicationId</code>添加一个工程名称作为后缀，这样可以对主app的<code>applicationId</code>进行区分。</p>
<p>上面脚本里的注释提到了<code>可单独运行的library module</code>，那这是什么意思呢？<br>我们每个工程打包为apk时只能有唯一一个plugin为<code>com.android.application</code>的主module，而其他需要集成的moudle的plugin均为<code>com.android.library</code>，当开发某个业务module(library类型)时，我们需要该module能单独运行以方便我们调试同时节省编译时间，这时我们就需要通过gradle参数控制，将其plugin暂时变为<code>com.android.application</code>以便使其能独立运行，所以这个时候该module也是一个主module，但为了与apk的主module进行区分，所以我把它叫做可单独运行的library module</p>
<p>那具体如何通过参数控制将某个library module暂时变为可单独编译运行的module，而在集成的时候又设置为library类型的module呢？我们可以在工程根目录的<code>gradle.properties</code>文件中添加参数进行控制<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//gradle.properties文件</span><br><span class="line">debugLibraryModules=[module1]</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>debugLibraryModules</code>参数将module名称为<code>module1</code>的module设置为可单独运行的library module，这个参数是一个数组，可以配置多个module。当这个数组为空的时候就代表不设置任何library module。</p>
<p>通过这个参数我们就可以在每个module工程加载脚本时判断当前module是否为可单独编译运行的module，判断方法如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">project.ext &#123;</span><br><span class="line">    //通过module的名称进行判断</span><br><span class="line">    isDebugLibraryModule = &#123; projectName -&gt;</span><br><span class="line">        def debugLibraryModuleList = debugLibraryModules</span><br><span class="line">        return project.hasProperty(&apos;debugLibraryModules&apos;) &amp;&amp; debugLibraryModuleList.indexOf(projectName) != -1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，我们的参数化动态配置脚本的基础已经完成了，接着要针对主module和library module进行具体的工程配置。</p>
<h4 id="配置app的主module"><a href="#配置app的主module" class="headerlink" title="配置app的主module"></a>配置app的主module</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//main-module-build.gradle</span><br><span class="line">configModuleGradleScript(mainModuleType)</span><br><span class="line"></span><br><span class="line">getRootProject().getSubprojects().each &#123;item -&gt;</span><br><span class="line">    if(item.name != project.name &amp;&amp; !isDebugLibraryModule(item.name)) &#123;</span><br><span class="line">        project.dependencies.add(&quot;implementation&quot;, project(&quot;:$item.name&quot;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为app的主module是不可能变的，所以该module的moduleType肯定是<code>mainModuleType</code></p>
<p>另外app在集成其他library module时必须要将其他library module添加为主module的工程依赖，所以上述脚本中使用<code>getRootProject().getSubprojects()</code>先找到工程的所有module,然后将library module都动态添加为主module的工程依赖</p>
<p>主module的<code>build.gradle</code>内容如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apply from: &quot;$&#123;rootProject.rootDir&#125;/buildScript/common-build.gradle&quot;</span><br><span class="line">apply from: &quot;$&#123;rootProject.rootDir&#125;/buildScript/main-module-build.gradle&quot;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android-optimize.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在该工程的主module动态添加工程源码依赖时，也可以通过参数来控制某个module到底是采用工程源码依赖，还是采用远程仓库的aar依赖，以此来满足不同的业务需要。这篇文章就不介绍了，相信看懂这篇文章的同学应该能自己实现这个需求。</p>
<h4 id="配置library-module"><a href="#配置library-module" class="headerlink" title="配置library module"></a>配置library module</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//library-module-build.gradle</span><br><span class="line">def getModuleType() &#123;</span><br><span class="line">    if(isDebugLibraryModule(project.name)) &#123;</span><br><span class="line">        return debugLibraryModuleType</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return libraryModuleType</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">configModuleGradleScript(getModuleType())</span><br></pre></td></tr></table></figure>
<p>在配置library module时，要先判断当前library moduel是否已经通过参数设置为可单独运行的module，如果是的话则该module调用闭包<code>configModuleGradleScript</code>的参数为<code>debugLibraryModuleType</code>，否则则为<code>libraryModuleType</code></p>
<p>library module的<code>build.gradle</code>内容如下<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">apply from: &quot;$&#123;rootProject.rootDir&#125;/buildScript/common-build.gradle&quot;</span><br><span class="line">apply from: &quot;$&#123;rootProject.rootDir&#125;/buildScript/library-module-build.gradle&quot;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        versionCode 1</span><br><span class="line">        versionName &quot;1.0&quot;</span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android-optimize.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            if(isDebugLibraryModule(project.name)) &#123;</span><br><span class="line">                manifest.srcFile &apos;src/debug/AndroidManifest.xml&apos;</span><br><span class="line">                java.srcDirs = [&apos;src/debug/java&apos;, &apos;src/main/java&apos;]</span><br><span class="line">                res.srcDirs = [&apos;src/debug/res&apos;,&apos;src/main/res&apos;]</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                manifest.srcFile &apos;src/main/AndroidManifest.xml&apos;</span><br><span class="line">                resources &#123;</span><br><span class="line">                    //排除java/debug文件夹下的所有文件</span><br><span class="line">                    exclude &apos;src/debug/*&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述脚本在配置可单独运行的library module时，虽然已经动态将其plugin设置为<code>com.android.application</code>也添加了<code>applicationId</code>，但是该module依旧还不能单独运行，因为我们一开始创建的library module中的<code>AndroidManifest.xml</code>文件没有配置也不能配置启动<code>Activity</code>,所以需要在library module的<code>buld.gradle</code>脚本中添加如下脚本：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            if(isDebugLibraryModule(project.name)) &#123;</span><br><span class="line">                manifest.srcFile &apos;src/debug/AndroidManifest.xml&apos;</span><br><span class="line">                java.srcDirs = [&apos;src/debug/java&apos;, &apos;src/main/java&apos;]</span><br><span class="line">                res.srcDirs = [&apos;src/debug/res&apos;,&apos;src/main/res&apos;]</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                manifest.srcFile &apos;src/main/AndroidManifest.xml&apos;</span><br><span class="line">                resources &#123;</span><br><span class="line">                    //排除java/debug文件夹下的所有文件</span><br><span class="line">                    exclude &apos;src/debug/*&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的脚本先检查当前module是否为可单独运行的library module，如果是则采用<code>src/debug/AndroidManifest.xml</code>文件。要注意的是该文件必须要包含’src/main/AndroidManifest.xml’文件的所有内容，同时还要设置启动<code>Activity</code>。</p>
<p>到这里，模块化开发的工程配置介绍完了，有兴趣的同学可以在这<a href="https://github.com/huyongli/AndroidModuleDesign" target="_blank" rel="noopener">https://github.com/huyongli/AndroidModuleDesign</a>查看完整代码</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android中用Kotlin Coroutine(协程)和Retrofit进行网络请求和取消请求]]></title>
      <url>http://ittiger.cn/Kotlin-Coroutine-For-Android-Network.html</url>
      <content type="html"><![CDATA[<p>Kotlin Coroutine(协程)系列：<br><a href="http://ittiger.cn/Kotlin-Coroutine-Guide.html">1. Kotlin Coroutine(协程) 简介</a><br><a href="http://ittiger.cn/Kotlin-Coroutine-Basic-Knowledge.html">2. Kotlin Coroutine(协程) 基本知识</a><br><a href="http://ittiger.cn/Kotlin-Coroutine-For-Android-Network.html">3. Android中用Kotlin Coroutine(协程)和Retrofit进行网络请求和取消请求</a>   </p>
<p>前面两篇文章介绍了协程的一些基本概念和基本知识，这篇则介绍在<code>Android</code>中如何使用协程配合<code>Retrofit</code>发起网络请求，同时介绍在使用协程时如何优雅的取消已经发起的网络请求。<br><a id="more"></a><br>此篇文章的Demo地址<a href="https://github.com/huyongli/AndroidKotlinCoroutine" target="_blank" rel="noopener">：https://github.com/huyongli/AndroidKotlinCoroutine</a></p>
<h3 id="创建CoroutineScope"><a href="#创建CoroutineScope" class="headerlink" title="创建CoroutineScope"></a>创建CoroutineScope</h3><p>在前面的文章中我写到<code>CoroutineScope.launch</code>方法是一个很常用的协程构建器。因此使用协程必须先得创建一个<code>CoroutineScope</code>对象，代码如下：<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CoroutineScope(Dispatchers.Main + Job())</span><br></pre></td></tr></table></figure></p>
<p>上面的代码创建了一个<code>CoroutineScope</code>对象，为其协程指定了在主线程中执行，同时分配了一个<code>Job</code>   </p>
<p>在demo中我使用的是MVP模式写的，所以我将<code>CoroutineScope</code>的创建放到了<code>BasePresenter</code>中，代码如下：<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MvpView</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MvpPresenter</span>&lt;<span class="hljs-type">V: MvpView</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@UiThread</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">attachView</span><span class="hljs-params">(view: <span class="hljs-type">V</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@UiThread</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">detachView</span><span class="hljs-params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePresenter</span>&lt;<span class="hljs-type">V: MvpView</span>&gt; : <span class="hljs-type">MvpPresenter</span>&lt;<span class="hljs-type">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> view: V</span><br><span class="line">    <span class="hljs-keyword">val</span> presenterScope: CoroutineScope <span class="hljs-keyword">by</span> lazy &#123;</span><br><span class="line">        CoroutineScope(Dispatchers.Main + Job())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">attachView</span><span class="hljs-params">(view: <span class="hljs-type">V</span>)</span></span> &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.view = view</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">detachView</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        presenterScope.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用CoroutineScope-cancel-取消协程"><a href="#使用CoroutineScope-cancel-取消协程" class="headerlink" title="使用CoroutineScope.cancel()取消协程"></a>使用CoroutineScope.cancel()取消协程</h3><p>大家应该可以看到上面<code>BasePresenter.detachView</code>中调用了<code>presenterScope.cancel()</code>，那这个方法有什么作用呢，作用就是取消掉<code>presenterScope</code>创建的所有协程和其子协程。</p>
<p>前面的文章我也介绍过使用<code>launch</code>创建协程时会返回一个<code>Job</code>对象，通过<code>Job</code>对象的<code>cancel</code>方法也可以取消该任务对应的协程，那我这里为什么不使用这种方式呢？</p>
<p>很明显，如果使用<code>Job.cancel()</code>方式取消协程，那我创建每个协程的时候都必须保存返回的<code>Job</code>对象，然后再去取消，显然要更复杂点，而使用<code>CoroutineScope.cancel()</code>则可以一次性取消该协程上下文创建的所有协程和子协程，该代码也可以很方便的提取到基类中，这样后面在写业务代码时也就不用关心协程与View的生命周期的问题。</p>
<p>其实大家看源码的话也可以发现<code>CoroutineScope.cancel()</code>最终使用的也是<code>Job.cancel()</code>取消协程</p>
<h3 id="扩展Retrofit-Call适配协程"><a href="#扩展Retrofit-Call适配协程" class="headerlink" title="扩展Retrofit.Call适配协程"></a>扩展Retrofit.Call适配协程</h3><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApiService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@GET(<span class="hljs-meta-string">"data/iOS/2/1"</span>)</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getIOSGank</span><span class="hljs-params">()</span></span>: Call&lt;GankResult&gt;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GET(<span class="hljs-meta-string">"data/Android/2/1"</span>)</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAndroidGank</span><span class="hljs-params">()</span></span>: Call&lt;GankResult&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiSource</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;</span><br><span class="line">        <span class="hljs-meta">@JvmField</span></span><br><span class="line">        <span class="hljs-keyword">val</span> instance = Retrofit.Builder()</span><br><span class="line">            .baseUrl(<span class="hljs-string">"http://gank.io/api/"</span>)</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .build().create(ApiService::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家可以看到上面的api接口定义应该很熟悉，我们可以通过下面的代码发起异步网络请求<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ApiSource.instance.getAndroidGank().enqueue(<span class="hljs-keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, t: <span class="hljs-type">Throwable</span>)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, response: <span class="hljs-type">Response</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>前面的文章介绍过协程可以让异步代码像写同步代码那样方便，那上面这段异步代码能不能使用协程改造成类似写同步代码块那样呢？很显然是可以的，具体改造代码如下：<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//扩展Retrofit.Call类，为其扩展一个await方法，并标识为挂起函数</span></span><br><span class="line"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Call<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">await</span><span class="hljs-params">()</span></span>: T &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> suspendCoroutine &#123;</span><br><span class="line">        enqueue(<span class="hljs-keyword">object</span> : Callback&lt;T&gt; &#123;</span><br><span class="line">            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, t: <span class="hljs-type">Throwable</span>)</span></span> &#123;</span><br><span class="line">                <span class="hljs-comment">//请求失败，抛出异常，手动结束当前协程</span></span><br><span class="line">                it.resumeWithException(t)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>&lt;<span class="hljs-type">T</span>&gt;, response: <span class="hljs-type">Response</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(response.isSuccessful) &#123;</span><br><span class="line">                   <span class="hljs-comment">//请求成功，将请求结果拿到并手动恢复所在协程</span></span><br><span class="line">                   it.resume(response.body()!!)</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span>&#123;</span><br><span class="line">                   <span class="hljs-comment">//请求状态异常，抛出异常，手动结束当前协程</span></span><br><span class="line">                   it.resumeWithException(Throwable(response.toString()))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码扩展了一个挂起函数<code>await</code>，执行该方法时，会执行<code>Retrofit.Call</code>的异步请求同时在协程中挂起该函数，直到异步请求成功或者出错再重新恢复所在协程。</p>
<h3 id="suspendCoroutine"><a href="#suspendCoroutine" class="headerlink" title="suspendCoroutine"></a>suspendCoroutine</h3><p>全局函数，此函数可以获取当前方法所在协程上下文，并将当前协程挂起，直到某个时机再重新恢复协程执行，但是这个时机其实是由开发者自己控制的，就像上面代码中的<code>it.resume</code>和<code>it.resumeWithException</code>。</p>
<h3 id="发起请求，写法一"><a href="#发起请求，写法一" class="headerlink" title="发起请求，写法一"></a>发起请求，写法一</h3><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//使用CoroutineScope.launch创建一个协程，此协程在主线程中执行</span></span><br><span class="line">presenterScope.launch &#123;</span><br><span class="line">    <span class="hljs-keyword">val</span> time = System.currentTimeMillis()</span><br><span class="line">    view.showLoadingView()</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">val</span> ganks = queryGanks()</span><br><span class="line">        view.showLoadingSuccessView(ganks)</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">        view.showLoadingErrorView()</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="hljs-string">"耗时：<span class="hljs-subst">$&#123;System.currentTimeMillis() - time&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">queryGanks</span><span class="hljs-params">()</span></span>: List&lt;Gank&gt; &#123;</span><br><span class="line">    <span class="hljs-comment">//此方法执行线程和调用者保持一致，因此也是在主线程中执行</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-comment">//先查询Android列表，同时当前协程执行流程挂起在此处</span></span><br><span class="line">        <span class="hljs-keyword">val</span> androidResult = ApiSource.instance.getAndroidGank().await()</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">//Android列表查询完成之后恢复当前协程，接着查询IOS列表，同时将当前协程执行流程挂起在此处</span></span><br><span class="line">        <span class="hljs-keyword">val</span> iosResult = ApiSource.instance.getIOSGank().await()</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//Android列表和IOS列表都查询结束后，恢复协程，将两者结果合并，查询结束</span></span><br><span class="line">        <span class="hljs-keyword">val</span> result = mutableListOf&lt;Gank&gt;().apply &#123;</span><br><span class="line">            addAll(iosResult.results)</span><br><span class="line">            addAll(androidResult.results)</span><br><span class="line">        &#125;</span><br><span class="line">        result</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">        <span class="hljs-comment">//处理协程中的异常，否则程序会崩掉</span></span><br><span class="line">        e.printStackTrace()</span><br><span class="line">        <span class="hljs-keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码大家可以发现，协程中对异常的处理使用的是<code>try-catch</code>的方式，初学，我也暂时只想到了这种方式。所以在使用协程时，最好在业务的适当地方使用<code>try-catch</code>捕获异常，否则一旦协程执行出现异常，程序就崩掉了。</p>
<p>另外上面的代码的写法还有一个问题，因为挂起函数执行时会挂起当前协程，所以上述两个请求是依次顺序执行，因此上面的<code>queryGanks()</code>方法其实是耗费了两次网络请求的时间，因为请求Android列表和请求ios列表两个请求不是并行的，所以这种写法肯定不是最优解。</p>
<h3 id="发起请求，写法二"><a href="#发起请求，写法二" class="headerlink" title="发起请求，写法二"></a>发起请求，写法二</h3><p>下面我们再换另外一种写法。<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">queryGanks</span><span class="hljs-params">()</span></span>: List&lt;Gank&gt; &#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 此方法执行线程和调用者保持一致，因此也在主线程中执行</span></span><br><span class="line"><span class="hljs-comment">     * 因为网络请求本身是异步请求，同时async必须在协程上下文中执行，所以此方法实现中采用withContext切换执行线程到主线程，获取协程上下文对象</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">return</span> withContext(Dispatchers.Main) &#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-comment">//在当前协程中创建一个新的协程发起Android列表请求，但是不会挂起当前协程</span></span><br><span class="line">            <span class="hljs-keyword">val</span> androidDeferred = async &#123;</span><br><span class="line">                <span class="hljs-keyword">val</span> androidResult = ApiSource.instance.getAndroidGank().await()</span><br><span class="line">                androidResult</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//发起Android列表请求后，立刻又在当前协程中创建了另外一个子协程发起ios列表请求，也不会挂起当前协程</span></span><br><span class="line">            <span class="hljs-keyword">val</span> iosDeferred = async &#123;</span><br><span class="line">                <span class="hljs-keyword">val</span> iosResult = ApiSource.instance.getIOSGank().await()</span><br><span class="line">                iosResult</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">val</span> androidResult = androidDeferred.await().results</span><br><span class="line">            <span class="hljs-keyword">val</span> iosResult = iosDeferred.await().results</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//两个列表请求并行执行，等待两个请求结束之后，将请求结果进行合并</span></span><br><span class="line">            <span class="hljs-comment">//此时当前方法的执行时间实际上两个请求中耗时时间最长的那个，而不是两个请求所耗时间的总和，因此此写法优于上面一种写法</span></span><br><span class="line">            <span class="hljs-keyword">val</span> result = mutableListOf&lt;Gank&gt;().apply &#123;</span><br><span class="line">                addAll(iosResult)</span><br><span class="line">                addAll(androidResult)</span><br><span class="line">            &#125;</span><br><span class="line">            result</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">            <span class="hljs-keyword">throw</span> e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种写法与前一种写法的区别是采用<code>async</code>构建器创建了两个子协程分别去请求Android列表和IOS列表，同时因为<code>async</code>构建器执行的时候不会挂起当前协程，所以两个请求是并行执行的，因此效率较上一个写法要高很多。</p>
<h3 id="发起请求，写法三"><a href="#发起请求，写法三" class="headerlink" title="发起请求，写法三"></a>发起请求，写法三</h3><p>第三个写法就是在<code>Retorfit</code>的<code>CallAdapter</code>上做文章，通过自定义实现<code>CallAdapterFactory</code>，将api定义时的结果<code>Call</code>直接转换成<code>Deferred</code>,这样就可以同时发起Android列表请求和IOS列表请求，然后通过<code>Deferred.await</code>获取请求结果，这种写法是写法一写法二的结合。</p>
<p>这种写法<code>JakeWharton</code>大神早已为我们实现了，地址在这<a href="https://github.com/JakeWharton/retrofit2-kotlin-coroutines-adapter" target="_blank" rel="noopener">https://github.com/JakeWharton/retrofit2-kotlin-coroutines-adapter</a></p>
<p>这里我就不说这种方案的具体实现了，感兴趣的同学可以去看其源码。</p>
<p>写法三的具体代码如下：<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">val</span> instance = Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="hljs-string">"http://gank.io/api/"</span>)</span><br><span class="line">        .addCallAdapterFactory(CoroutineCallAdapterFactory())</span><br><span class="line">        .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">        .build().create(CallAdapterApiService::<span class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span></span><br><span class="line">        </span><br><span class="line"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">queryGanks</span><span class="hljs-params">()</span></span>: List&lt;Gank&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> withContext(Dispatchers.Main) &#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">val</span> androidDeferred = ApiSource.callAdapterInstance.getAndroidGank()</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">val</span> iosDeferred = ApiSource.callAdapterInstance.getIOSGank()</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">val</span> androidResult = androidDeferred.await().results</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">val</span> iosResult = iosDeferred.await().results</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">val</span> result = mutableListOf&lt;Gank&gt;().apply &#123;</span><br><span class="line">                addAll(iosResult)</span><br><span class="line">                addAll(androidResult)</span><br><span class="line">            &#125;</span><br><span class="line">            result</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">            <span class="hljs-keyword">throw</span> e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的第三种写法看起来更简洁，也是并行请求，耗时为请求时间最长的那个请求的时间，和第二种差不多。</p>
<p>具体实现demo的地址见文章开头，有兴趣的可以看看。</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Kotlin </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Coroutine </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kotlin Coroutine(协程) 基本知识]]></title>
      <url>http://ittiger.cn/Kotlin-Coroutine-Basic-Knowledge.html</url>
      <content type="html"><![CDATA[<p>Kotlin Coroutine(协程)系列：<br><a href="http://ittiger.cn/Kotlin-Coroutine-Guide.html">1. Kotlin Coroutine(协程) 简介</a><br><a href="http://ittiger.cn/Kotlin-Coroutine-Basic-Knowledge.html">2. Kotlin Coroutine(协程) 基本知识</a><br><a href="http://ittiger.cn/Kotlin-Coroutine-For-Android-Network.html">3. Android中用Kotlin Coroutine(协程)和Retrofit进行网络请求和取消请求</a><br>这篇文章主要介绍协程中的一些基本概念。</p>
<h3 id="挂起函数-suspend关键字"><a href="#挂起函数-suspend关键字" class="headerlink" title="挂起函数(suspend关键字)"></a>挂起函数(suspend关键字)</h3><a id="more"></a>
<p><code>Kotlin</code>中提供了关键字<code>suspend</code>用来描述一个函数为挂起函数，写法如下：<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//官方提供的函数</span></span><br><span class="line"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">delay</span><span class="hljs-params">(timeMillis: <span class="hljs-type">Long</span>)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上写法就代表<code>delay</code>函数为一个挂起函数。</p>
<p>在前面一篇文章<a href="https://blog.csdn.net/huyongl1989/article/details/89287132" target="_blank" rel="noopener">Kotlin Coroutine(协程) 简介</a>中我提到过挂起函数只会挂起当前协程，不会挂起阻塞当前协程所处的线程。事实上，想要执行协程就至少需要一个挂起函数，因此挂起函数是协程中一个非常重要的概念。</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>挂起函数能用普通函数的方式获取参数和返回值</li>
<li>调用挂起函数时，可能会挂起当前协程(如果挂起函数的相关调用已经有结果，那么系统可能会选择不挂起)，而不会挂起所在的线程。</li>
<li>挂起函数执行结束后，协程会自动恢复执行，此时才能继续执行挂起函数后续的代码</li>
<li>挂起函数只能在协程或其他挂起函数中调用，否则会编译报错</li>
<li><code>suspend</code>可以将普通函数、扩展函数、lambda表达式均标记为挂起函数</li>
</ol>
<h3 id="CoroutineScope"><a href="#CoroutineScope" class="headerlink" title="CoroutineScope"></a>CoroutineScope</h3><p>官方描述：为协程定义了一个范围</p>
<blockquote>
<p>Defines a scope for new coroutines.   </p>
</blockquote>
<p>也可以理解为协程的上下文环境，更通俗点你可以将其看作为一个协程。</p>
<p>我们再来看下官方源码中的定义：<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoroutineScope</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * Context of this scope.</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过这个代码我们可以看到<code>CoroutineScope</code>初始定义中只有一个协程上下文<code>CoroutineContext</code>对象，所以协程的上下文对象其实是由<code>CoroutineContext</code>决定的，因此将<code>CoroutineScope</code>看作协程更好理解。</p>
<h3 id="CoroutineContext"><a href="#CoroutineContext" class="headerlink" title="CoroutineContext"></a>CoroutineContext</h3><p>协程上下文，包含了协程中的一些元素，主要有<code>Job</code>和<code>CoroutineDispatcher</code></p>
<h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>协程的后台任务，它有自己的生命周期，该任务可以被取消。   </p>
<p><code>Job</code>可以有父<code>Job</code>，当父<code>Job</code>被取消时，其所有子<code>Job</code>也会被取消。   </p>
<p><code>Job</code>有三种状态:</p>
<ol>
<li><code>isActive</code> 是否处于活动状态</li>
<li><code>isCompleted</code> 是否完成</li>
<li><code>isCancelled</code> 是否被取消</li>
</ol>
<p>可参考下表：<br><strong>State</strong> | [isActive] | [isCompleted] | [isCancelled]<br> ——————————– | ———- | ————- | ————- |<br> <em>New</em> (optional initial state)   | <code>false</code>    | <code>false</code>       | <code>false</code>       |<br> <em>Active</em> (default initial state) | <code>true</code>     | <code>false</code>       | <code>false</code>       |<br> <em>Completing</em> (transient state)   | <code>true</code>     | <code>false</code>       | <code>false</code>       |<br> <em>Cancelling</em> (transient state)   | <code>false</code>    | <code>false</code>       | <code>true</code>        |<br> <em>Cancelled</em> (final state)        | <code>false</code>    | <code>true</code>        | <code>true</code>        |<br> <em>Completed</em> (final state)        | <code>false</code>    | <code>true</code>        | <code>false</code>       |</p>
<p>当创建协程开始执行并获取到<code>Job</code>对象后，如果想等该协程执行结束再执行其他的业务逻辑，那么可以调用<code>Job.join()</code>方法，该方法会等待该协程任务执行结束，该方法为挂起函数。</p>
<h3 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred"></a>Deferred</h3><p>它是<code>Job</code>的子类，与<code>Job</code>不同的是它可以有返回值，而<code>Job</code>是没有返回值的。</p>
<p>通过调用<code>Deferred</code>的<code>await()</code>方法即可拿到返回值，而<code>await()</code>方法也是一个挂起函数，因此调用该方法时会挂起当前协程，直到拿到返回值协程重新恢复执行。</p>
<p><code>Android</code>中协程结合<code>Retrofit</code>发起网络请求可以考虑使用该类获取请求结果</p>
<h3 id="CoroutineDispatcher"><a href="#CoroutineDispatcher" class="headerlink" title="CoroutineDispatcher"></a>CoroutineDispatcher</h3><p>协程调度器，它可以将协程的执行局限在指定的线程中，它有四个默认的实现：</p>
<ol>
<li><code>Dispatchers.Default</code> 默认调度器，在使用<code>launch</code>和<code>async</code>等协程构造器创建协程时，如果不指定调度器则会使用此默认调度器，该调度器会让协程在<code>JVM</code>提供的共享线程池中执行</li>
<li><code>Dispatchers.Main</code> 主线程调度器，让协程在主线程即UI线程中执行</li>
<li><code>Dispatchers.IO</code> 让协程在IO线程(子线程)中执行，该调度器会与<code>Dispatchers.Default</code>调度器共享同一个线程池</li>
<li><code>Dispatchers.Unconfined</code> 该调度器不指定协程在某个线程中执行。设置了该调度器的协程会在调用者线程中启动执行直到第一个挂起点，挂起后，它将在挂起函数执行的线程中恢复，恢复的线程完全取决于该挂起函数在哪个线程执行。</li>
<li><code>newSingleThreadContext</code> 这是<code>Kotlin</code>另外提供的一个调度器，它会为协程启动一个新的线程。一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 close 函数，或存储在一个顶级变量中使它在整个应用程序中被重用。</li>
</ol>
<p>另外需要注意的是：协程调度器默认承袭外部协程的调度器。</p>
<h3 id="GlobalScope"><a href="#GlobalScope" class="headerlink" title="GlobalScope"></a>GlobalScope</h3><p>这是一个全局的<code>CoroutineScope</code>不会受任何Job约束，通过它创建的是全局协程，它会在整个应用的生命周期中运行，不能被取消</p>
<h3 id="launch函数"><a href="#launch函数" class="headerlink" title="launch函数"></a>launch函数</h3><p>这是一个扩展的<code>CoroutineScope</code>实例方法，同时也是一个很常用的协程构建器。   </p>
<p>通过其默认参数会创建一个不会阻塞当前线程且会立即执行的协程，该方法会返回一个<code>Job</code>对象，该方法默认承袭所在的<code>CoroutineScope</code>对象的调度器。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val scope = CoroutineScope(Dispatchers.Main + Job())</span><br><span class="line">scrope.launch &#123;</span><br><span class="line">    //协程实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码通过<code>launch</code>创建的协程会在UI线程中执行</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val scope = CoroutineScope(Dispatchers.Main + Job())</span><br><span class="line">scrope.launch(Dispatchers.IO) &#123;</span><br><span class="line">    //协程实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码通过<code>launch</code>创建的协程会在IO线程中执行</p>
<h3 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h3><p>这是一个全局的协程构建器，可以在任何地方调用。</p>
<p>该构建器会创建一个阻塞当前线程的协程，所以该构建器不建议使用在协程内。</p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>和<code>launch</code>函数一样，也是<code>CoroutineScope</code>的扩展实例方法，它也是一个常用的协程构建器，不同是它创建协程时返回的是<code>Deferred</code>,通过<code>Deferred</code>可以拿到执行结果<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">val</span> a = async &#123;</span><br><span class="line">    log(<span class="hljs-string">"I'm computing a piece of the answer"</span>)</span><br><span class="line">    <span class="hljs-number">6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">val</span> b = async &#123;</span><br><span class="line">    log(<span class="hljs-string">"I'm computing another piece of the answer"</span>)</span><br><span class="line">    <span class="hljs-number">7</span></span><br><span class="line">&#125;</span><br><span class="line">log(<span class="hljs-string">"The answer is <span class="hljs-subst">$&#123;a.await() * b.await()&#125;</span>"</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h3><p>全局函数</p>
<ol>
<li>让协程休眠指定时间，类似于Java中的Thread.sleep的作用</li>
<li>delay是一个挂起函数，调用后不会阻塞挂起当前线程</li>
<li>当协程的休眠时间到了之后，当前所处协程会重新恢复执行</li>
</ol>
<h3 id="withContext"><a href="#withContext" class="headerlink" title="withContext"></a>withContext</h3><p>切换协程上下文，一般主要用来切换协程所在的线程环境，如从主线程切换到IO线程。</p>
<p>调用该方法不会创建新的协程，同时是一个挂起函数</p>
<p>该方法会有一个返回值，其返回值为<code>withContext</code>中lambda表达式的返回值</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Kotlin </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Coroutine </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kotlin Coroutine(协程) 简介]]></title>
      <url>http://ittiger.cn/Kotlin-Coroutine-Guide.html</url>
      <content type="html"><![CDATA[<p>Kotlin Coroutine(协程)系列：<br><a href="http://ittiger.cn/Kotlin-Coroutine-Guide.html">1. Kotlin Coroutine(协程) 简介</a><br><a href="http://ittiger.cn/Kotlin-Coroutine-Basic-Knowledge.html">2. Kotlin Coroutine(协程) 基本知识</a><br><a href="http://ittiger.cn/Kotlin-Coroutine-For-Android-Network.html">3. Android中用Kotlin Coroutine(协程)和Retrofit进行网络请求和取消请求</a>   </p>
<h3 id="协程介绍"><a href="#协程介绍" class="headerlink" title="协程介绍"></a>协程介绍</h3><a id="more"></a>
<p>协程是可挂起计算的实例。</p>
<p>它在概念上类似于线程，在这个意义上，它需要一个代码块运行，并具有类似的生命周期，它可以被创建和启动，但它不绑定到任何特定的线程。</p>
<p>它可以在一个线程中挂起其执行，并在另一个线程中恢复。而且，像future 或 promise那样，它在完结时可能伴随着某种结果（值或异常）</p>
<p>协程开发人员这样描述协程：</p>
<blockquote>
<p>协程就像非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。</p>
</blockquote>
<p>如上面所说，协程是由开发者自己控制的，因此在使用协程时我们一定要记住一点，我们必须知道我们使用的协程在何时挂起，它又在何时重新恢复执行，如果没法知道这两点，那就意味着我们无法控制协程，这个时候要慎用协程。   </p>
<h3 id="为什么使用协程"><a href="#为什么使用协程" class="headerlink" title="为什么使用协程"></a>为什么使用协程</h3><h5 id="使用协程可以提高线程的利用率。"><a href="#使用协程可以提高线程的利用率。" class="headerlink" title="使用协程可以提高线程的利用率。"></a>使用协程可以提高线程的利用率。</h5><p>通常我们在<code>Android</code>中发起一个网络请求都会经历如下几步：</p>
<ol>
<li>在主线程中创建一个请求任务，如：<code>Retrofit.Call</code></li>
<li>为这个任务分配一个子线程去执行请求任务，如：调用<code>Retrofit.Call.enqueue(callback)</code>方法</li>
<li>子线程发起请求后将会阻塞等待网络请求的返回结果，拿到结果后会将数据转换成我们需要的实体对象</li>
<li>在主线程中执行回调接口，执行余下的业务操作   </li>
</ol>
<p>上面的流程中为请求任务分配子线程一般都会配合线程池去做，以防止不断创建线程而产生系统开销，但在线程真正执行过程中经常会遇到因磁盘IO或者是网络请求等操作而导致线程阻塞，而此时当前线程只能阻塞等待，无法做任何事情，在等待的这段时间里线程相当于白白了浪费了自身资源，导致线程自身利用率低下。</p>
<p>在<code>Android</code>中改用协程发起网络请求流程如下：</p>
<ol>
<li>在主线程中创建一个协程，在协程中创建网络请求任务</li>
<li>为协程分配一个子线程去发起网络请求</li>
<li>挂起子线程中的协程，此时仅仅是协程挂起，该子线程并没有挂起阻塞</li>
<li>协程等待请求结果回来之后，会在子线程中重新恢复协程执行</li>
<li>在主线程中执行某个回调，拿到请求数据执行余下的业务操作</li>
</ol>
<p>在上述流程步骤3中挂起协程后子线程并不会阻塞，此时该子线程可以被系统分配去做其他的事情，当协程挂起结束时重新在子线程中恢复执行。这样该线程就不会存在因阻塞导致的空闲浪费，提高了线程利用率。</p>
<p><strong>总的来说，使用协程可以最大程度的复用线程，通过让线程满载运行，从而达到充分的利用CPU提高系统性能。</strong></p>
<h5 id="告别回调地狱"><a href="#告别回调地狱" class="headerlink" title="告别回调地狱"></a>告别回调地狱</h5><p>使用协程另外一个好处就是可以让开发者们告别异步编程中的回调地狱，简化异步编程，让写异步代码和写同步代码一样简单，增强了代码的可读性、可理解性和可维护性。</p>
<p><strong>举个例子</strong><br>假定有个登录有如下流程：</p>
<ol>
<li>发请求获取用户token</li>
<li>根据token获取用户信息</li>
</ol>
<p>常用实现方式代码如下：<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">login</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    requestToken &#123; token -&gt;</span><br><span class="line">        requestUserInfo(token) &#123; user -&gt;</span><br><span class="line">            Log.i(<span class="hljs-string">"tag"</span>, user.toString())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子是<code>Android</code>开发中经常会遇到的问题，一个请求依赖前一个请求的结果，这个时候经常会出现这样的写法，在第一个请求的成功回调中根据请求结果发起第二个网络请求。这里还只存在两层的嵌套，试想一下，如果嵌套层次出现4次，5次，甚至更多会出现怎样的情况，估计开发者自己写起来都会崩溃。</p>
<p>使用RxJava实现代码如下：<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Single.fromCallable &#123; requestToken() &#125;</span><br><span class="line">    .map &#123; token -&gt; requestUserInfo(tokenm) &#125;</span><br><span class="line">    .subscribe(</span><br><span class="line">        &#123; user -&gt; Log.i(<span class="hljs-string">"tag"</span>, user.toString()) &#125;, <span class="hljs-comment">// onSuccess</span></span><br><span class="line">        &#123; e -&gt; e.printStackTrace() &#125;  <span class="hljs-comment">// onError</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p>
<p>使用<code>RxJava</code>的实现方式虽然将回调嵌套改成了链式写法，阅读起来要稍微好点，但是依然存在回调而且增加了实现的复杂度，对不熟悉<code>RxJava</code>的人来说更少增加了难度。</p>
<p>使用协程实现方式代码如下：<br><figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">login</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">    <span class="hljs-keyword">val</span> token = requestToken()</span><br><span class="line">    <span class="hljs-keyword">val</span> user = requestUserInfo(token)</span><br><span class="line">    Log.i(<span class="hljs-string">"tag"</span>, user.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>怎么样，使用协程的写法是不是简便很多，而且看起来非常符合人们的阅读和理解习惯。</p>
<h3 id="Android中使用协程示例"><a href="#Android中使用协程示例" class="headerlink" title="Android中使用协程示例"></a>Android中使用协程示例</h3><p>自己写了一个<code>Android</code>使用协程配合<code>Retrofit</code>发起网络请求的<code>Demo</code>，主要包含了如下内容：   </p>
<ol>
<li>如何将Kotlin Coroutine(协程)和Retrofit结合使用</li>
<li>如何在Kotlin Coroutine(协程)切换协程所在线程</li>
<li>如何在Kotlin Coroutine(协程)中将两个请求结果进行合并</li>
<li>Kotlin Coroutine(协程)中如何实现并发请求</li>
<li>MVP开发模式中如何在Presenter生命周期结束时优雅的取消协程</li>
<li>如何将一个普通异步操作改造为协程中的挂起函数</li>
</ol>
<p>代码地址：<a href="https://github.com/huyongli/AndroidKotlinCoroutine" target="_blank" rel="noopener">https://github.com/huyongli/AndroidKotlinCoroutine</a></p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Kotlin </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Coroutine </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Flutter实战之封装一个LinearLayout]]></title>
      <url>http://ittiger.cn/Flutter-For-LinearLayout.html</url>
      <content type="html"><![CDATA[<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>在<code>APP</code>开发过程中，经常遇到需要添加背景、设置边距、动态显示和隐藏某个组件。 </p>
<p>但是在<code>Flutter</code>中，能同时具有添加背景、设置边距、阴影、边框、圆角的布局只有<code>Container</code>(参考我上一篇文章的介绍<a href="https://blog.csdn.net/huyongl1989/article/details/83745871" target="_blank" rel="noopener">Flutter入门之Row、Column、Container布局</a>)，这个已经算是业务功能比较多的组件了，而要想实现组件的显示和隐藏则需要用到另外一个组件<code>Offstage</code>，水平的线性布局则需要用到组件<code>Row</code>，垂直的线性布局则需要用到组件<code>Column</code>，而<code>Row</code>和<code>Column</code>这两个布局都不具备直接设置背景、边距、显示和隐藏等功能。<br><a id="more"></a><br>在开发过程中这种需求又很常见，不可能每个地方都把这些代码重复一遍，所以对这几个组件封装一下，实现了一个类似<code>Android</code>中<code>LinearLayout</code>布局的组件很有必要。</p>
<h3 id="封装LinearLayout"><a href="#封装LinearLayout" class="headerlink" title="封装LinearLayout"></a>封装LinearLayout</h3><p>封装成<code>LinearLayout</code>其实很简单，就是将<code>Row</code>、<code>Column</code>、<code>Offstage</code>、<code>Container</code>四个组件合理的组合在一起就可以了。</p>
<ol>
<li>首先要暴露一个参数确定是水平的线性布局还是垂直的线性布局</li>
<li>将<code>Container</code>经常用到的背景、边距参数暴露出来</li>
<li>将<code>Row</code>、<code>Column</code>中用到的主轴、交叉轴的对齐方式暴露出来</li>
<li>将<code>Row</code>、<code>Column</code>中主轴size的适配方式暴露出来</li>
<li>暴露出一个方法用来动态改变组件的显示和隐藏</li>
</ol>
<p>代码如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line">import &apos;package:flutter_library/common/util.dart&apos;;</span><br><span class="line"></span><br><span class="line">enum LayoutOrientation &#123; horizontal, vertical &#125;</span><br><span class="line"></span><br><span class="line">class LinearLayout extends StatefulWidget &#123;</span><br><span class="line">  final LayoutOrientation orientation;</span><br><span class="line">  final bool isVisible;</span><br><span class="line">  final Decoration background;</span><br><span class="line">  final EdgeInsetsGeometry padding;</span><br><span class="line">  final EdgeInsetsGeometry margin;</span><br><span class="line">  final List&lt;Widget&gt; children;</span><br><span class="line"></span><br><span class="line">  final MainAxisAlignment mainAxisAlignment;</span><br><span class="line">  final MainAxisSize mainAxisSize;</span><br><span class="line">  final CrossAxisAlignment crossAxisAlignment;</span><br><span class="line"></span><br><span class="line">  LinearLayout(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    this.orientation,</span><br><span class="line">    this.isVisible = true,</span><br><span class="line">    this.background,</span><br><span class="line">    this.padding,</span><br><span class="line">    this.margin,</span><br><span class="line">    this.children = const &lt;Widget&gt;[],</span><br><span class="line">    this.mainAxisAlignment = MainAxisAlignment.start,</span><br><span class="line">    this.mainAxisSize = MainAxisSize.min,</span><br><span class="line">    this.crossAxisAlignment = CrossAxisAlignment.center,</span><br><span class="line">  &#125;) : super(key: key);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  LinearLayoutState createState() &#123;</span><br><span class="line">    return LinearLayoutState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LinearLayoutState extends State&lt;LinearLayout&gt; &#123;</span><br><span class="line">  bool _isVisible = true;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    _isVisible = widget.isVisible;</span><br><span class="line">    super.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return isNotNull(_isVisible)</span><br><span class="line">        ? Offstage(</span><br><span class="line">            offstage: !_isVisible,</span><br><span class="line">            child: _buildLayoutWidget(),</span><br><span class="line">          )</span><br><span class="line">        : _buildLayoutWidget();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _buildLayoutWidget() &#123;</span><br><span class="line">    if (_isNeedContainerWidget()) &#123;</span><br><span class="line">      return _buildContainerWidget();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return _buildOrientationWidget();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool _isNeedContainerWidget() &#123;</span><br><span class="line">    return isNotNull(widget.background) ||</span><br><span class="line">        isNotNull(widget.padding) ||</span><br><span class="line">        isNotNull(widget.margin);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _buildContainerWidget() &#123;</span><br><span class="line">    return Container(</span><br><span class="line">      decoration: widget.background,</span><br><span class="line">      padding: widget.padding,</span><br><span class="line">      margin: widget.margin,</span><br><span class="line">      child: _buildOrientationWidget(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _buildOrientationWidget() &#123;</span><br><span class="line">    if (widget.orientation == LayoutOrientation.horizontal) &#123;</span><br><span class="line">      return _buildHorizontalWidget();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return _buildVerticalWidget();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _buildVerticalWidget() &#123;</span><br><span class="line">    return Column(</span><br><span class="line">      mainAxisSize: widget.mainAxisSize,</span><br><span class="line">      mainAxisAlignment: widget.mainAxisAlignment,</span><br><span class="line">      crossAxisAlignment: widget.crossAxisAlignment,</span><br><span class="line">      children: widget.children,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget _buildHorizontalWidget() &#123;</span><br><span class="line">    return Row(</span><br><span class="line">      mainAxisSize: widget.mainAxisSize,</span><br><span class="line">      mainAxisAlignment: widget.mainAxisAlignment,</span><br><span class="line">      crossAxisAlignment: widget.crossAxisAlignment,</span><br><span class="line">      children: widget.children,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool isVisible() &#123;</span><br><span class="line">    return _isVisible;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void setVisible(bool isVisible) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _isVisible = isVisible;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>package:flutter_library/common/util.dart文件代码如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool isNull(dynamic obj) &#123;</span><br><span class="line">  return obj == null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool isNotNull(dynamic obj) &#123;</span><br><span class="line">  return obj != null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="LinearLayout使用"><a href="#LinearLayout使用" class="headerlink" title="LinearLayout使用"></a>LinearLayout使用</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class LinearLayoutSampleWidget extends StatefulWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  State&lt;StatefulWidget&gt; createState() &#123;</span><br><span class="line">    return LinearLayoutSampleState();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LinearLayoutSampleState extends State&lt;LinearLayoutSampleWidget&gt; &#123;</span><br><span class="line">  GlobalKey&lt;LinearLayoutState&gt; _key = GlobalKey&lt;LinearLayoutState&gt;();</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(&apos;LinearLayout Sample&apos;),</span><br><span class="line">      ),</span><br><span class="line">      body:</span><br><span class="line">        LinearLayout(</span><br><span class="line">          background: BoxDecoration(color: Colors.blue),</span><br><span class="line">          orientation: LayoutOrientation.vertical,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            LinearLayout(</span><br><span class="line">              key: _key,</span><br><span class="line">              background: BoxDecoration(color: Colors.red),</span><br><span class="line">              orientation: LayoutOrientation.horizontal,</span><br><span class="line">              mainAxisSize: MainAxisSize.min,</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                Icon(Icons.list),</span><br><span class="line">                Text(&apos;线性布局&apos;)</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">            FlatButton(</span><br><span class="line">              onPressed: () &#123;</span><br><span class="line">                bool isVisible = _key.currentState.isVisible();</span><br><span class="line">                _key.currentState.setVisible(!isVisible);</span><br><span class="line">              &#125;,</span><br><span class="line">              child: Text(&apos;切换显示&apos;),</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        )  </span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里重点说一下Demo中的<code>GlobalKey&lt;LinearLayoutState&gt; _key = GlobalKey&lt;LinearLayoutState&gt;()</code>这段代码，这个就是用来给<code>LinearLayout</code>设定一个唯一标识符，这样才能在后面点击按钮的时候调用<code>setVisible</code>方法来显示和隐藏。而泛型<code>LinearLayoutState</code>则是我封装的代码中的一个类，因为我的<code>setVisible</code>方法暴露在此State中。</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Flutter </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Flutter入门之Row、Column、Container布局]]></title>
      <url>http://ittiger.cn/Flutter-Row-Column-Container.html</url>
      <content type="html"><![CDATA[<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>写过<code>Android</code>的都知道<code>Android</code>中有个很常用布局<code>LinearLayout</code>，它可以实现线性的横向或纵向的布局结构。对于学习<code>Flutter</code>的<code>Android</code>开发者来说，肯定也想知道<code>Flutter</code>中该如何实现线性布局结构。</p>
<p>在<code>Flutter</code>中线性布局结构的实现是通过两个不同的<code>widget</code>分别来实现横向和纵向布局结构的。组件<code>Row</code>用来实现横向的线性布局，而组件<code>Column</code>则用来实现纵向的线性布局，而<code>Container</code>则是用来设置背景、设置大小、设置边距(padding)的布局。<br><a id="more"></a><br>下面来分别介绍三个组件的相关属性：</p>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p><code>Container</code>的构造函数如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Container(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    this.alignment,</span><br><span class="line">    this.padding,</span><br><span class="line">    Color color,</span><br><span class="line">    Decoration decoration,</span><br><span class="line">    this.foregroundDecoration,</span><br><span class="line">    double width,</span><br><span class="line">    double height,</span><br><span class="line">    BoxConstraints constraints,</span><br><span class="line">    this.margin,</span><br><span class="line">    this.transform,</span><br><span class="line">    this.child,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ol>
<li><code>key</code>: 该属性代表当前<code>widget</code>的唯一标识符(类似于<code>Android</code>中的id)，在程序运行过程中，如果想调用该<code>widget</code>的某个方法，那就需要设置该属性值，该属性不是必须值</li>
<li><code>alignment</code>: 子元素的对齐方式，官方已经提供了几种常用的对齐方式</li>
<li><code>padding</code>: 这个比较好理解，跟<code>Android</code>中的是一个意思，内边距</li>
<li><code>color</code>: 设置组件的背景色</li>
<li><code>decoration</code>: 与<code>color</code>属性功能一样，都是设置背景，不过<code>decoration</code>功能更强大，它可以设置背景图片、圆角、渐变、阴影、边框等</li>
<li><code>width</code> &amp; <code>height</code>: 组件的宽高</li>
<li><code>constraints</code>: 组件的宽高限制</li>
<li><code>margin</code>: 外边距</li>
<li><code>transform</code>: 矩阵转换</li>
<li><code>child</code>: 子元素</li>
</ol>
<p>另外在使用过程中，<code>Container</code>如果作为应用的根节点的话，它的宽高会自动填充为屏幕大小。</p>
<h3 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h3><p><code>Row</code>的构造函数如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Row(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,</span><br><span class="line">    MainAxisSize mainAxisSize = MainAxisSize.max,</span><br><span class="line">    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,</span><br><span class="line">    TextDirection textDirection,</span><br><span class="line">    VerticalDirection verticalDirection = VerticalDirection.down,</span><br><span class="line">    TextBaseline textBaseline,</span><br><span class="line">    List&lt;Widget&gt; children = const &lt;Widget&gt;[],</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="关键属性"><a href="#关键属性" class="headerlink" title="关键属性"></a>关键属性</h4><ol>
<li><code>key</code>: 该属性代表当前<code>widget</code>的唯一标识符(类似于<code>Android</code>中的id)，在程序运行过程中，如果想调用该<code>widget</code>的某个方法，那就需要设置该属性值，该属性不是必须值</li>
<li><code>mainAxisAlignment</code>: 子元素在主轴的对齐方式，<code>Row</code>的主轴即为水平方向</li>
<li><code>mainAxisSize</code>: 主轴方向大小适配方式，只有两种取值方式：<ul>
<li><code>MainAxisSize.max</code> 主轴方向大小(在<code>Row</code>中指宽度)与父容器大小相同(即<code>Android</code>中的<code>match_parent</code>)</li>
<li><code>MainAxisSize.min</code> 主轴方向大小(在<code>Row</code>中指宽度)由子元素决定(即<code>Android</code>中的<code>wrap_content</code>)</li>
</ul>
</li>
<li><code>crossAxisAlignment</code>: 子元素在交叉轴(垂直方向)的对齐方式</li>
<li><code>children</code>: 子元素列表</li>
</ol>
<h3 id="Column"><a href="#Column" class="headerlink" title="Column"></a>Column</h3><p><code>Column</code>的构造函数<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Column(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,</span><br><span class="line">    MainAxisSize mainAxisSize = MainAxisSize.max,</span><br><span class="line">    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,</span><br><span class="line">    TextDirection textDirection,</span><br><span class="line">    VerticalDirection verticalDirection = VerticalDirection.down,</span><br><span class="line">    TextBaseline textBaseline,</span><br><span class="line">    List&lt;Widget&gt; children = const &lt;Widget&gt;[],</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>
<h4 id="关键属性-1"><a href="#关键属性-1" class="headerlink" title="关键属性"></a>关键属性</h4><ol>
<li><code>key</code>: 该属性代表当前<code>widget</code>的唯一标识符(类似于<code>Android</code>中的id)，在程序运行过程中，如果想调用该<code>widget</code>的某个方法，那就需要设置该属性值，该属性不是必须值</li>
<li><code>mainAxisAlignment</code>: 子元素在主轴的对齐方式，<code>Column</code>的主轴即为垂直方向</li>
<li><code>mainAxisSize</code>: 主轴方向大小适配方式，只有两种取值方式：<ul>
<li><code>MainAxisSize.max</code> 主轴方向大小(在<code>Column</code>中指高度)与父容器大小相同(即<code>Android</code>中的<code>match_parent</code>)</li>
<li><code>MainAxisSize.min</code> 主轴方向大小(在<code>Column</code>中指高度)由子元素决定(即<code>Android</code>中的<code>wrap_content</code>)</li>
</ul>
</li>
<li><code>crossAxisAlignment</code>: 子元素在交叉轴(水平方向)的对齐方式</li>
<li><code>children</code>: 子元素列表</li>
</ol>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Flutter </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Flutter实战之Gank Demo实践]]></title>
      <url>http://ittiger.cn/Flutter-Gank-Demo.html</url>
      <content type="html"><![CDATA[<p>初学Flutter，看了两天文档，花了两天时间利用gank.io提供的api接口实践了下Flutter，写了个Demo.</p>
<p>主要实践了Flutter的如下几个知识点：<br><a id="more"></a></p>
<ol>
<li>如何使用<code>dio</code>框架发起网络请求</li>
<li>如何实现常用布局，如：<ul>
<li>水平布局: <code>Row</code></li>
<li>垂直布局: <code>Column</code></li>
<li>层叠布局: <code>Stack</code></li>
<li>如何设置间距: <code>Padding</code></li>
</ul>
</li>
<li>如何显示网络图片<code>Image</code></li>
<li>如何使用下拉刷新组件: <code>RefreshIndicator</code></li>
<li>如何使用<code>ListView</code>组件，以及添加上拉加载更多功能</li>
<li>如何给普通<code>widget</code>添加事件监听: <code>GestureDetector</code></li>
<li>如何实现水波纹效果: <code>InkWell</code></li>
<li>如何使用<code>Card</code>实现卡片式布局</li>
<li>在Flutter中如何使用<code>WebView</code></li>
<li>如何创建<code>Material Design</code>风格的应用以及自定义其主题样式</li>
<li>如何使用<code>AppBar</code>组件同时给其添加<code>TabBarView</code>组件和<code>BottomNavigationBar</code></li>
<li>如何进行页面跳转: <code>Navigator</code></li>
</ol>
<p>Demo代码地址<a href="https://github.com/huyongli/FlutterGank" target="_blank" rel="noopener">请戳这这这</a></p>
<p>Demo效果如如下：<br><img src="/img/Flutter/gank-demo1" width="240" height="480" alt><img src="/img/Flutter/gank-demo2" width="240" height="480" alt><br><img src="/img/Flutter/gank-demo3" width="240" height="480" alt><img src="/img/Flutter/gank-demo4" width="240" height="480" alt></p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Flutter </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Flutter入门之Could not find lint-gradle-api.jar]]></title>
      <url>http://ittiger.cn/Flutter-For-Start-Build-Error.html</url>
      <content type="html"><![CDATA[<p>这两天在学习<code>Flutter</code>，学习过程中尝试着写了个Demo，然后在Android平台运行想看下效果，结果直接<code>gradle</code>都没过，错误提示如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Where: Build file &apos;PROJECTPATH/android/app/build.gradle&apos; line: 25</span><br><span class="line">What went wrong: A problem occurred evaluating project &apos;:app&apos;.</span><br><span class="line">Could not resolve all files for configuration &apos;classpath&apos;. Could not find lint-gradle-api.jar (com.android.tools.lint:lint-gradle-api:26.1.2). Searched in the following locations: https://jcenter.bintray.com/com/android/tools/lint/lint-gradle-api/26.1.2/lint-gradle-api-26.1.2.jar</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>看到这个错误第一反应是这个库在仓库里没找到，然后看了下Android工程根目录下的<code>build.gradle</code>文件，其配置如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我又给了加了个<code>mavenCentral()</code>，结果运行依旧是这个错误，而且我的网络是没有任何问题的。</p>
<p>前面的方式无法解决后，就在<code>flutter</code>的github里的issue中看了半天，然后发了一种说法：</p>
<blockquote>
<p>在你的flutter安装目录下找到文件：flutter/packages/flutter_tools/gradle/flutter.gradle</p>
</blockquote>
<p>打开该文件将文件中如下脚本内容：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    jcenter()</span><br><span class="line">    maven &#123;</span><br><span class="line">        url &apos;https://dl.google.com/dl/android/maven2&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改成：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">    maven &#123;</span><br><span class="line">        url &apos;https://dl.google.com/dl/android/maven2&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    jcenter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是将maven和jcenter调换一个顺序。</p>
<p>我使用这种方式解决了编译错误的问题，当然还有个前提条件是你的网络可以成功访问google。我没有试过国内网络的环境，不过按照这种方式国内网络环境可以将仓库地址改为国内镜像地址，至于具体镜像地址，大家可以在网上找。</p>
<p>我代码中使用的flutter版本为：<code>sdk: &quot;&gt;=2.0.0-dev.68.0 &lt;3.0.0&quot;</code></p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Flutter </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[多线程之：Synchronized与ReentrantLock]]></title>
      <url>http://ittiger.cn/Java-Synchronized-ReentrantLock.html</url>
      <content type="html"><![CDATA[<h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><ol>
<li>保证多线程环境下共享的、可修改的状态的正确性。(这里的状态在程序中可以看作为数据)</li>
<li>反着来说则是如果状态非共享、不可修改，也就不存在线程安全的问题<a id="more"></a>
<h3 id="保证线程安全的两种方法"><a href="#保证线程安全的两种方法" class="headerlink" title="保证线程安全的两种方法"></a>保证线程安全的两种方法</h3></li>
<li><strong>封装</strong>，通过封装将对象内部状态隐藏、保护起来</li>
<li><strong>不可变</strong>，将状态改为不可变,例如将状态定义为<code>final</code></li>
</ol>
<h3 id="线程安全要保证的基本特性"><a href="#线程安全要保证的基本特性" class="headerlink" title="线程安全要保证的基本特性"></a>线程安全要保证的基本特性</h3><ol>
<li><strong>原子性</strong><br> 相关操作不会在中途被其他线程所干扰，一般通过同步机制实现</li>
<li><strong>可见性</strong><br> 一个行程修改了某个共享变量，其新状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的</li>
<li><strong>有序性</strong><br>  保证线程内串行语义，避免指令重排</li>
</ol>
<h3 id="Synchronized与ReentrantLock"><a href="#Synchronized与ReentrantLock" class="headerlink" title="Synchronized与ReentrantLock"></a>Synchronized与ReentrantLock</h3><h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><p><code>synchronized</code>可以很方便的解决多线程间资源共享同步的问题，也就是我们平常所说的线程安全问题。   </p>
<p>它可以修饰方法和代码块，无法是用作何种修饰，<code>synchronized</code>获取的锁都是对象。</p>
<p>关于<code>synchronized</code>的使用这里就不说了。</p>
<h5 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h5><p><code>ReentrantLock</code>一般称为再入锁,是Lock的实现类，是一个互斥的同步器。</p>
<p>再入锁通过代码直接调用 <code>lock()</code> 方法获取，代码书写也更加灵活。同时<code>ReentrantLock</code> 提供了很多实用的方法，能够实现很多<code>synchronized</code> 无法做到的细节控制，比如可以控制 fairness，也就是公平性，或者利用条件定义等。</p>
<p>但是，编码中也需要注意，必须要明确调用 unlock() 方法释放，不然就会一直持有该锁。</p>
<h6 id="条件变量-Condition"><a href="#条件变量-Condition" class="headerlink" title="条件变量(Condition)"></a>条件变量(Condition)</h6><p><code>ReentrantLock</code>配合条件变量（<code>java.util.concurrent.locks.Condition</code>），可以将复杂而晦涩的同步操作转变为直观可控的对象行为。</p>
<p>条件变量最为典型的应用场景就是标准类库中的 <code>ArrayBlockingQueue</code>等，看下源码：</p>
<p>通过再入锁获取条件变量:<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/** Condition for waiting puts */</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity, <span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">	<span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)</span><br><span class="line">    	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();</span><br><span class="line">	<span class="hljs-keyword">this</span>.items = <span class="hljs-keyword">new</span> Object[capacity];</span><br><span class="line">	lock = <span class="hljs-keyword">new</span> ReentrantLock(fair);</span><br><span class="line">	notEmpty = lock.newCondition();</span><br><span class="line">	notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个条件变量是从<strong>同一再入锁</strong>创建出来，然后使用在特定操作中，如下面的 take 方法，判断和等待条件满足:<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;</span><br><span class="line">	lock.lockInterruptibly();</span><br><span class="line">	<span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    	<span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)</span><br><span class="line">        	notEmpty.await();</span><br><span class="line">    	<span class="hljs-keyword">return</span> dequeue();</span><br><span class="line">	&#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">    	lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当队列为空时，试图take获取元素的线程会等待其他元素入队操作的发生，而不是直接返回，这是 BlockingQueue 的语义，使用条件 notEmpty 就可以优雅地实现这一逻辑。</p>
<p>那么，怎么保证入队触发后续 take 操作呢？请看 enqueue 实现：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(E e)</span> </span>&#123;</span><br><span class="line">	<span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">this</span>.items;</span><br><span class="line">	items[putIndex] = e;</span><br><span class="line">	<span class="hljs-keyword">if</span> (++putIndex == items.length) putIndex = <span class="hljs-number">0</span>;</span><br><span class="line">	count++;</span><br><span class="line">	notEmpty.signal(); <span class="hljs-comment">// 通知等待的线程，非空条件已经满足</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过 signal/await 的组合，完成了条件判断和通知等待线程，非常顺畅就完成了状态流转。注意，signal 和 await 成对调用非常重要，不然假设只有 await 动作，线程会一直等待直到被打断（interrupt）</p>
<h5 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h5><p><code>synchronized</code> 和 <code>ReentrantLock</code> 的性能不能一概而论，早期版本 <code>synchronized</code> 在很多场景下性能相差较大，在后续版本进行了较多改进。</p>
<p>在低竞争场景中<code>synchronized</code>表现可能优于 <code>ReentrantLock</code></p>
<p>而在多线程高竞争条件下，<code>ReentrantLock</code>比<code>synchronized</code>有更加优异的性能表现。</p>
<h5 id="高竞争"><a href="#高竞争" class="headerlink" title="高竞争"></a>高竞争</h5><p>如果大部分情况，每个线程都不需要真的获取锁，就是低竞争；反之，大部分都要获取锁才能正常工作，就是高竞争</p>
<h5 id="用法比较"><a href="#用法比较" class="headerlink" title="用法比较"></a>用法比较</h5><ol>
<li>Lock使用起来比较灵活，但是必须有释放锁的配合动作</li>
<li>Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁</li>
<li>Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等</li>
</ol>
<h5 id="特性比较"><a href="#特性比较" class="headerlink" title="特性比较"></a>特性比较</h5><p><code>ReentrantLock</code>的优势体现在：   </p>
<ol>
<li>具备尝试非阻塞地获取锁的特性：当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁</li>
<li>能被中断地获取锁的特性：与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放</li>
<li>超时获取锁的特性：在指定的时间范围内获取锁；如果截止时间到了仍然无法获取锁，则返回</li>
<li>可以控制线程的竞争公平性</li>
</ol>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>在使用<code>ReentrantLock</code>类的时，一定要注意三点：</p>
<ol>
<li>在finally中释放锁，目的是保证在获取锁之后，最终能够被释放</li>
<li>不要将获取锁的过程写在try块内，因为如果在获取锁时发生了异常，异常抛出的同时，也会导致锁无故被释放。</li>
<li><code>ReentrantLock</code>提供了一个<code>newCondition</code>的方法，以便用户在同一锁的情况下可以根据不同的情况执行等待或唤醒的动作。</li>
</ol>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[React Native学习问题记录]]></title>
      <url>http://ittiger.cn/RN-Problem-Record.html</url>
      <content type="html"><![CDATA[<p>最近做了一个RN的项目，RN小白，自然遇到了不少问题，这里记录一下。<br><a id="more"></a></p>
<ol>
<li><p>命令行下启动IOS版本时出现如下错误：</p>
 <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun: error: unable to find utility &quot;instruments&quot;, not a developer tool or</span><br></pre></td></tr></table></figure>
<p> 这个是装完xcode后模拟器无法识别的问题，解决办法是在终端下执行如下命令：</p>
 <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	sudo xcode-select -s /Applications/Xcode.app/Contents/Developer/</span><br><span class="line">	```	</span><br><span class="line"></span><br><span class="line">2. 终端命令启动某个APP时，出现红屏错误，而上面显示的错误信息表明加载代码的路径与当前要运行的代码路径不相符。这个错误应该是你上一次运行了另外一个APP，而当你再次运行第二个不同的APP时没有把上一个APP的终端监听给关掉。此时只需要关闭react-native start的监听终端即可，然后重启APP</span><br><span class="line">3. 在使用`react-devtools`查看APP的布局结构时，出现如下信息而无法链接上APP</span><br></pre></td></tr></table></figure>
<p> Waiting for React to connect</p>
 <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在终端下执行如下命令，然后重启`react-devtools`即可</span><br></pre></td></tr></table></figure>
<p> adb reverse tcp:8097 tcp:8097</p>
 <figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4. `ScrollView`中`TextInput`的焦点问题。当`ScrollView`中存在`TextInput`时，当输入完文字后，`TextInput`会还占用焦点，导致`ScrollView`内的其他元素需要点击两次才能起作用，这时需要设置`ScrollView`的如下属性：`keyboardShouldPersistTaps=&quot;handled&quot;`即可</span><br><span class="line">5. 针对软键盘遮挡问题，我试了几种方案，发现下面两种方案比较简单有效：</span><br><span class="line">	- RN官方提供的`KeyboardAvoidingView`方案最简单有效</span><br><span class="line">	- 另外一种方案是自己监听软键盘的打开与关闭然后结合`Animated`动画来实现软键盘的遮挡问题，这种方案比较灵活</span><br><span class="line">6. IOS启动指定版本模拟器: `react native run-ios --simulator &quot;iPhone X&quot;`</span><br><span class="line">7. Android打包失败，信息如下：</span><br></pre></td></tr></table></figure>
<ul>
<li><p>What went wrong:<br>Execution failed for task ‘:app:bundleReleaseJsAndAssets’.</p>
<blockquote>
<p>A problem occurred starting process ‘command ‘node’’</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个错误的可能原因是gradle deamon的缓存问题，关掉cradle deamon，重新再执行一次就可以解决</span><br></pre></td></tr></table></figure>
</blockquote>
<p>./gradlew –stop<br><code>`</code></p>
</li>
</ul>
</li>
</ol>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> React Native </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[整洁代码的理解]]></title>
      <url>http://ittiger.cn/Thinking-Code-Clean.html</url>
      <content type="html"><![CDATA[<p>前段时间看了<code>《代码整洁之道》</code>这本书，书中的一些观点讲的很不错，这些观点很容易让人对号入座，也很容易让人知道自己写的代码是否漂亮、是否整洁。通过这篇文章记录下读后感和书中的一些观点。</p>
<a id="more"></a>
<h3 id="为什么要整洁代码"><a href="#为什么要整洁代码" class="headerlink" title="为什么要整洁代码"></a>为什么要整洁代码</h3><ul>
<li>很多时候我们修复bug或开发新功能时都会先看看周边的相关代码(开发过程中经常碰到前面写的代码到后面就忘了，回看代码是常事)，如果想要bug或新功能写的轻松那自然就要求代码阅读也轻松。不整洁的代码阅读起来会轻松吗。</li>
<li>相信很多人都不愿意去接手别人写的二手代码，为什么呢，因为很多人写的代码质量很一般，让其他的人阅读他的代码很是困难。所以整洁的代码也能帮助其他人轻松的理解自己的代码。</li>
</ul>
<h3 id="整洁代码核心思想"><a href="#整洁代码核心思想" class="headerlink" title="整洁代码核心思想"></a>整洁代码核心思想</h3><p><strong><em>如何在意代码</em></strong><br>这跟生活是一个道理，当你真正在意某件事情的时候，在意到什么程度，事情在意程度不一样，对事情的处理态度和方式也不一样。所以只有你真正的在意你写的代码，你才会去关注代码的质量，写出整洁漂亮的代码。</p>
<p>我有一个Android开发的QQ群，经常在群里听到有人说公司领导不在乎代码质量和实现过程，只关注结果，所以他们也不关注自己写的代码是否漂亮是否整洁，只求赶快完成功能交差。我相信有很多这样的程序员都是这样，只追求功能实现，从来不管代码写的怎么样，因为他们不注重自己写的代码怎么样，他们只看重自己能不能在规定时间内向领导交差。</p>
<h3 id="天敌：后面再优化"><a href="#天敌：后面再优化" class="headerlink" title="天敌：后面再优化"></a>天敌：后面再优化</h3><p>很多程序员都有一个习惯，经常会说：先实现目前的功能，等后面有时间了再来优化代码。其实大家也知道结果了，基本上大部分的人后面都不会去做什么代码优化，前面的说辞也变成了说说而已。</p>
<p>所以写代码的时候如果当时能写出更好的代码就当时一次性写好，不要想着以后再去优化，这基本是不可能的了。时间长了就会在不知不觉中养成习惯，如果每次都想着以后再优化，那每次写代码基本上都不会去关注代码的质量，相反每次编码都尽自己最大努力去写好，时间长了你的代码质量和要求自然就上去了。</p>
<h3 id="什么样的代码是整洁代码"><a href="#什么样的代码是整洁代码" class="headerlink" title="什么样的代码是整洁代码"></a>什么样的代码是整洁代码</h3><ul>
<li>代码逻辑一目了然，很清楚方法、类、模块做的是什么事情</li>
<li>整洁的代码只专注于做好一件事(不论是方法、类还是模块)，处理的事情多了，自然就会让逻辑变的复杂</li>
<li>让代码块小，小块的代码便于阅读和理解</li>
<li>尽量减少依赖，让代码便于维护</li>
<li>性能调至最优，省得引诱做没规矩的优化，搞出一堆混乱代码来</li>
<li>依据某种分层战略完善错误处理代码</li>
</ul>
<h3 id="如何写出整洁代码"><a href="#如何写出整洁代码" class="headerlink" title="如何写出整洁代码"></a>如何写出整洁代码</h3><h4 id="减少重复代码"><a href="#减少重复代码" class="headerlink" title="减少重复代码"></a>减少重复代码</h4><p>当代码中一段代码多次出现的时候，就表示某种想法没有在代码中得到良好的体现。所以减少重复代码以提高代码表达力，尽早构建简单抽象。</p>
<h4 id="使用异常代替错误码"><a href="#使用异常代替错误码" class="headerlink" title="使用异常代替错误码"></a>使用异常代替错误码</h4><p>错误码通常是枚举或者是常量，而这样的错误码就像磁铁一样，导致所有用到这些错误码类都需要导入引用它，一旦错误码需要修改就需要修改所有的这些类。而使用异常则不会存在这些问题，新异常可以从异常类里直接派生出来，而不需要修改已有代码。</p>
<h4 id="有意义的命名"><a href="#有意义的命名" class="headerlink" title="有意义的命名"></a>有意义的命名</h4><h5 id="命名要名副其实"><a href="#命名要名副其实" class="headerlink" title="命名要名副其实"></a>命名要名副其实</h5><p>选一个好的名称是比较耗费时间的，但是一旦选对了名称那省下的时间是很可观的。类名、变量名、方法名应该就可以答复大部分的问题，例如它做了什么事，怎么做。如果名称需要注释来补充，那就不算名副其实。</p>
<h5 id="避免误导"><a href="#避免误导" class="headerlink" title="避免误导"></a>避免误导</h5><ol>
<li>例如：字母l和数字1，字母o和数字0，这两种就很容易让人傻傻分不清</li>
<li>不要使用外形太像的命名方式，比如：ControllerForEfficientHandlingOfStrings和ControllerForEfficientStorageOfStrings，这种名称很长又只有细微差别的命名方式很容易迷惑</li>
<li>不要使用有特殊意义的字符串来命名。<h5 id="做有意义的区分"><a href="#做有意义的区分" class="headerlink" title="做有意义的区分"></a>做有意义的区分</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void copyChars(char a1[], char a2[]) &#123;</span><br><span class="line">	for(int i = 0; i &lt; a1.length; a1++) &#123;</span><br><span class="line">		a2[i] = a1[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的代码虽然很简单，但是命名方式还是很有问题的，如果把参数名分别改为source和destination对整个方法的实现来说就要清晰很多</p>
<h5 id="使用读得出来的名称"><a href="#使用读得出来的名称" class="headerlink" title="使用读得出来的名称"></a>使用读得出来的名称</h5><p>命名的时候尽量使用大众熟知的单词，不要使用自造词、拼音单词混用或是自己偷懒将单词进行简写之类，这样的命名只会增加代码的阅读负担，让人看的云里雾里。</p>
<h5 id="使用可搜索的名称"><a href="#使用可搜索的名称" class="headerlink" title="使用可搜索的名称"></a>使用可搜索的名称</h5><p>在阅读代码的过程中常用的功能就是搜索，所以一个方便搜索的名称还是很重要的。<br>比如一个字符串最大长度只允许为7，代码中有好几个地方需要做这种判断，但是经常就有人偷懒直接使用数字7进行判断，那在代码搜索的时候是搜索7容易还是搜索MAX_LENGTH_SEVEN容易，答案很明显了。</p>
<p>对于搜索来说，长名称胜于短名称，搜得到的名称胜于用自造编码代写的名称。</p>
<h5 id="类名、函数名"><a href="#类名、函数名" class="headerlink" title="类名、函数名"></a>类名、函数名</h5><ol>
<li>类是对一类具有共同特征的事物的抽象，所以类和对象名应该是名称或名词短语，而不应该是动词</li>
<li>方法通常是完成了一件什么事，所以方法名应当是动词或动词短语。</li>
</ol>
<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><blockquote>
<p>让函数表达其意图，该给函数赋予哪些属性，好让读者一看就知道函数是什么样的程序</p>
</blockquote>
<ol>
<li><strong>函数第一规则就是要短小、尽量的短小</strong><ul>
<li>很多人在看别人的代码的时候一旦遇上很长的函数，心理就开始打退堂鼓了，为什么呢？其实很重要的一个原因就是因为长函数的实现逻辑都弄的比较复杂，而且这个函数可能做了好几件事，阅读起来会让人很吃力。而短小的函数一眼看上去逻辑就比较清晰简单，至少阅读的人心理上就要好受很多。</li>
</ul>
</li>
<li><strong>函数只做一件事</strong><ul>
<li>每个函数应该只做一件事，如果一个函数实现里做了多件事，那势必会让这个函数变的比较长。</li>
</ul>
</li>
<li><strong>函数参数尽量少</strong></li>
<li><strong>输出参数比输入更难以理解，尽量以返回值作为输出</strong><ul>
<li>很多人在方法实现的时候喜欢将List作为方法参数输入而方法返回类型为void(在Android开发中尤其多)，然后在方法实现里修改List的元素，后面直接用这个List作为修改后的List。这种写法稍不注意就会引发bug，而且不容易被发现。</li>
</ul>
</li>
<li><strong>不要用标记参数(boolean)</strong><ul>
<li>使用标记参数会增加函数的理解度和复杂度。一旦使用标记参数，就意味着你的函数实现里其实是做了两件不同的事。</li>
</ul>
</li>
<li><strong>将多个参数封装成一个类</strong><ul>
<li>如果一个函数有多个参数的话，就需要考虑将这些参数封装成一个类，使用对象作为参数输入了。</li>
</ul>
</li>
<li><strong>不要在函数中做函数名以外的事情</strong></li>
<li><strong>抽离try-catch代码块</strong><ul>
<li>处理错误异常也是一件事，所以要抽离</li>
</ul>
</li>
<li><strong>将被调用函数的实现直接定义在调用者的下方</strong><ul>
<li>使用这种方式方便阅读，避免阅读过程中来回的代码切换。</li>
<li>在web开发中jslint有条规则是将方法安装字母顺序进行排序，我个人不太认可这种方式，我认为将被调用函数的实现直接定义在调用者的下方这种方式比较好。</li>
</ul>
</li>
</ol>
<h4 id="避免急于求成"><a href="#避免急于求成" class="headerlink" title="避免急于求成"></a>避免急于求成</h4><p>编码的时候先按照思路实现，然后再斟酌打磨，按照规则打磨出整洁的代码。要想一次就写出完美的代码是不太可能的。先按思路实现，等你实现完可能就会发现有更好的实现方式，或者是更好的命名，这时慢慢的斟酌，慢慢的修改。</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Other </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Thinking </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hashtable、HashMap、TreeMap]]></title>
      <url>http://ittiger.cn/Java-HashMap-Hashtable-TreeMap.html</url>
      <content type="html"><![CDATA[<p>Hashtable、HashMap、TreeMap都是比较常见的一些Map实现，它们都是<code>key-value</code>键值对的形式存储和操作数据的容器类，同时他们的元素中不能有重复的key,一个key也只能映射一个value值。</p>
<p>下面我从不同的维度来分别说说这三个集合，文章中涉及到的源码版本是<code>JDK8</code></p>
<a id="more"></a>
<h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><ul>
<li><code>Hashtable</code>和<code>HashMap</code>底层都是采用数组存储数据</li>
<li><code>TreeMap</code>底层是采用红黑树存储数据</li>
</ul>
<h2 id="元素特性"><a href="#元素特性" class="headerlink" title="元素特性"></a>元素特性</h2><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><p><code>Hashtable</code>中存储的<code>key</code>和<code>value</code>都不能为<code>null</code>，这个从它的源码实现是可以看出来的<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public synchronized V put(K key, V value) &#123;</span><br><span class="line">    // Make sure the value is not null</span><br><span class="line">    if (value == null) &#123;</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Makes sure the key is not already in the hashtable.</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    int hash = key.hashCode();</span><br><span class="line">    ...//省略部分</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是<code>Hashtable</code>添加元素的源码实现，从开头的if判断就可以发现它的<code>value</code>值是不允许为<code>null</code>的，而它的<code>key</code>虽然没有显式判断，但是在执行<code>int hash = key.hashCode();</code>这句代码时，如果<code>key</code>为<code>null</code>的话，代码执行到这里程序就崩了，所以从侧面也反应出<code>key</code>也不能为<code>null</code></p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p><code>HashMap</code>中存储的<code>key</code>和<code>value</code>都允许为<code>null</code>，这个依然是从源码中看出来的。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//HashMap的put方法具体实现比较复杂代码比较多，这里我只贴出添加元素时涉及到key和value的相关代码</span><br><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    return new Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    return new TreeNode&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//TreeNode最终还是继承自Node，所以这里就不贴出TreeNode的构造函数了</span><br></pre></td></tr></table></figure></p>
<p>从上面的几段代码中可以看到在将<code>key-value</code>添加到<code>HashMap</code>中时没有任何地方会使用它们，因此<code>key</code>和<code>value</code>都是可以为<code>null</code>的</p>
<p>但是一个<code>HashMap</code>中只能有一个<code>key</code>为<code>null</code>，但是可以有多个<code>value</code>为<code>null</code></p>
<h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><p><code>TreeMap</code>中如果用户未实现<code>Comparator</code>接口，则<code>key</code>不能为<code>null</code>，如果实现了<code>Comparator</code>接口，那么<code>key</code>能否为<code>null</code>则需要根据<code>Comparator</code>接口的具体实现有关。<code>value</code>则是可以为<code>null</code>。至于原因，我们依然通过源码来寻求答案<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    ...</span><br><span class="line">    Comparator&lt;? super K&gt; cpr = comparator;</span><br><span class="line">    if (cpr != null) &#123;</span><br><span class="line">        do &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            if (cmp &lt; 0)</span><br><span class="line">                t = t.left;</span><br><span class="line">            else if (cmp &gt; 0)</span><br><span class="line">                t = t.right;</span><br><span class="line">            else</span><br><span class="line">                return t.setValue(value);</span><br><span class="line">        &#125; while (t != null);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (key == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span><br><span class="line">        do &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            if (cmp &lt; 0)</span><br><span class="line">                t = t.left;</span><br><span class="line">            else if (cmp &gt; 0)</span><br><span class="line">                t = t.right;</span><br><span class="line">            else</span><br><span class="line">                return t.setValue(value);</span><br><span class="line">        &#125; while (t != null);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码可以很明显的看到当成员变量<code>comparator</code>为空时(<code>Comparator</code>接口未实现)，有明显的<code>key</code>的非空判断，而当实现了该接口后，这会通过<code>Comparator</code>接口的<code>compare</code>方法比较当前<code>key</code>与<code>TreeMap</code>中已存在的<code>key</code>是否相等，所以这个时候<code>key</code>能否为<code>nul</code>就跟<code>Comparator</code>接口的<code>compare</code>方法具体实现有关了。</p>
<p><strong><em>注意这段代码</em></strong><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmp = k.compareTo(t.key);</span><br><span class="line">if (cmp &lt; 0)</span><br><span class="line">    t = t.left;</span><br><span class="line">else if (cmp &gt; 0)</span><br><span class="line">    t = t.right;</span><br><span class="line">else</span><br><span class="line">    return t.setValue(value);</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码中我们还可以看出<code>TreeMap</code>的<code>key</code>是有序的，而且当前节点的<code>key</code>比其左子树节点的<code>key</code>要大，而比右子树节点的<code>key</code>要小。</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><ul>
<li><code>Hashtable</code>和<code>HashMap</code>都是无序的</li>
<li><code>TreeMap</code>的<code>key</code>是有序的，有序的原因在前面分析其<code>put</code>源码的时候已经说过了。要注意的是这里是<code>key</code>是有序的，而不是其<code>value</code>是有序的，而且其默认是升序排序方式(深度优先搜索)，对于其排序方式，可以自定义实现<code>Comparator</code>接口来自定义排序规则</li>
</ul>
<h2 id="初始化和扩容方式"><a href="#初始化和扩容方式" class="headerlink" title="初始化和扩容方式"></a>初始化和扩容方式</h2><h4 id="Hashtable-1"><a href="#Hashtable-1" class="headerlink" title="Hashtable"></a>Hashtable</h4><ol>
<li>默认初始化容量为11个</li>
<li>容量阈值默认为当前容量的0.75倍，当集合数据大于等于阈值时就会进行扩容</li>
<li>不要求底层数组的容量一定为2的幂次方</li>
<li>扩容时会将容量变为原来的2倍加1</li>
<li>在初始化时就会创建底层数组</li>
<li>扩容时会创建一个扩容后的新数组，然后将原来数组的数据拷贝到新数组中<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void addEntry(int hash, K key, V value, int index) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (count &gt;= threshold) &#123;//数据个数大于等于阈值时进行扩容</span><br><span class="line">        rehash();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">//扩容函数</span><br><span class="line">protected void rehash() &#123;</span><br><span class="line">    int oldCapacity = table.length;</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line">    </span><br><span class="line">    //此处将oldCapacity左移一位，即将其扩大一倍</span><br><span class="line">    int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123;</span><br><span class="line">        if (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            return;</span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    //重新计算容量阈值</span><br><span class="line">    threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">    table = newMap;</span><br><span class="line">    //拷贝数据</span><br><span class="line">    for (int i = oldCapacity ; i-- &gt; 0 ;) &#123;</span><br><span class="line">        for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line"></span><br><span class="line">            int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;</span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap"></a>HashMap</h4><ol>
<li>默认初始化容量为16个</li>
<li>容量阈值默认为当前容量的0.75倍，当集合数据大于等于阈值时就会进行扩容</li>
<li>底层数据的容量要求一定是2的幂次方</li>
<li>扩容时会将容量变为原来的2倍</li>
<li>初始化时不会创建底层数组，而是在调用put方法添加数据时再创建底层数据</li>
<li>扩容时会创建一个扩容后的新数组，然后将原来数组的数据拷贝到新数组中<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;//初始化创建底层数组</span><br><span class="line">    ...</span><br><span class="line">    if (++size &gt; threshold)//元素个数大于等于阈值则进行扩容</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">//初始化或扩容函数</span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;//MAXIMUM_CAPACITY=2^30</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)//此处的newCap = oldCap &lt;&lt; 1则是进行数组扩容一倍</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);//重新计算新的阈值</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    ....</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="TreeMap-1"><a href="#TreeMap-1" class="headerlink" title="TreeMap"></a>TreeMap</h4><ol>
<li>因为<code>TreeMap</code>是树结构，所以不存在容量和扩容的问题</li>
<li>初始化时不会创建其根节点，而是在调用put方法添加数据时才会创建其根节点</li>
</ol>
<h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h2><h4 id="Hashtable-2"><a href="#Hashtable-2" class="headerlink" title="Hashtable"></a><code>Hashtable</code></h4><p>其方法都采用了<code>synchronized</code>修饰，因此是线程安全的，不会出现两个线程同时对数据进行操作的情况，它保证了线程安全性。但也因为这样导致其在多线程环境下使用此集合效率低下，因为一个线程访问其同步方法时，其他访问<code>Hashtable</code>的线程都会处于阻塞状态，现在已不推荐使用此集合。</p>
<h4 id="HashMap-2"><a href="#HashMap-2" class="headerlink" title="HashMap"></a><code>HashMap</code></h4><p><code>HashMap</code>的方法没有采用<code>synchronized</code>修饰，所以是非线程安全的，在程序中任一时刻可能会存在多个线程同时修改其数据，从而导致数据不一致。</p>
<p>在多线程环境下，我们可以使用下面两种方式使用<code>HashMap</code></p>
<ol>
<li>使用<code>Collections.synchronizedMap()</code>方法将<code>HashMap</code>转换为线程安全的<code>SynchronizedMap</code>包装类,其内部也是使用<code>synchronized</code>来达到同步效果，只不过此时锁住的是一个<code>Object</code>类型的成员变量,和锁住<code>HashMap</code>对象本身效果是一样，效率也比较低下，仅仅适合用在并发度不高的情景。</li>
<li>使用<code>ConcurrentHashMap</code>集合，相较于<code>Hashtable</code>锁住的是对象整体， <code>ConcurrentHashMap</code>基于<code>lock</code>实现锁分段技术。首先将<code>Map</code>存放的数据分成一段一段的存储方式，然后给每一段数据分配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。<code>ConcurrentHashMap</code>不仅保证了多线程运行环境下的数据访问安全性，而且性能上有长足的提升</li>
</ol>
<h4 id="TreeMap-2"><a href="#TreeMap-2" class="headerlink" title="TreeMap"></a><code>TreeMap</code></h4><p><code>HashMap</code>的方法没有采用<code>synchronized</code>修饰，所以<code>TreeMap</code>也是非线程安全的。</p>
<p>在多线程环境下建议使用<code>ConcurrentSkipListMap</code>代替</p>
<h2 id="HashMap的哈希冲突"><a href="#HashMap的哈希冲突" class="headerlink" title="HashMap的哈希冲突"></a>HashMap的哈希冲突</h2><p><code>HashMap</code>采用<strong>链地址法</strong>来解决哈希冲突，对哈希冲突或链地址法不了解的同学请参考我的另外一篇文章<a href="https://blog.csdn.net/huyongl1989/article/details/82220920" target="_blank" rel="noopener">Hash冲突解决方法</a></p>
<p>但是在<code>HashMap</code>中对链地址法采用了一点点变化，对于哈希冲突导致出现同义词元素显示采用单链表存放，当这个链表大小超过一个阈值(TREEIFY_THRESHOLD=8)且<code>HashMap</code>的大小大于等于另一个容量阈值(MIN_TREEIFY_CAPACITY = 64),就会把这个单链表该造为树形结构。</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    //此处判断链表的大小是否超过阈值</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">   ...</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">    int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        //HashMap的元素大小大于等于MIN_TREEIFY_CAPACITY则将该单链表改造成红黑树</span><br><span class="line">        //树改造逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么要改造呢，我的理解是这样的：</p>
<ul>
<li>因为单链表适合数据的插入和删除，而对于查询来说其效率要低一点，在单链表数据量小的时候，查询遍历的效率可能影响不太大，而当单链表数据量变大之后，其查询带来的性能影响就没法忽略了，所以这里就对单链表改造为红黑树，这样其<code>key</code>是有序的，查询的时候性能就要提高很多。</li>
<li>还有一种说法是因为安全性。因为构造哈希冲突的数据难度不大，会有人利用恶意代码产生大量这种数据与服务器交互，导致服务器CPU资源被大量占用，这样就会导致哈希碰撞拒绝服务器攻击。</li>
</ul>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hash冲突解决方法]]></title>
      <url>http://ittiger.cn/Java-hash-conflict.html</url>
      <content type="html"><![CDATA[<h2 id="何为Hash冲突"><a href="#何为Hash冲突" class="headerlink" title="何为Hash冲突"></a>何为Hash冲突</h2><p>假设Hash表大小为5(即5个槽位)，现在要把2,5,6,7,8这几个数存储到Hash表中，假设hash函数为<code>hash(num)=num % size</code></p>
<p>简单计算下，第一个数2的hash值为2所以放到第三个槽中，第二个数5的hash值为0放到第一个槽中，第三个数6的hash值为1放到第二个槽中，如下图所示：</p>
<table>
<thead>
<tr>
<th>1号槽</th>
<th>2号槽</th>
<th>3号槽</th>
<th>4号槽</th>
<th>5号槽</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>6</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>第四个数7的hash值也为2，应该放到第二个槽位，但是第二个槽位中已经放有数据了，这种情况就属于hash冲突。<br>简单来说，就是两个不同的数据经过hash函数计算之后得到了相同的hash值，这就叫做hash冲突。</p>
<h2 id="如何解决冲突"><a href="#如何解决冲突" class="headerlink" title="如何解决冲突"></a>如何解决冲突</h2><h3 id="开放地址法"><a href="#开放地址法" class="headerlink" title="开放地址法"></a>开放地址法</h3><p>开放地址法也称为再散列法</p>
<h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p>当关键字key的哈希地址 <code>p=hash(key)</code>出现冲突时，以hash值p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，然后将相应元素存入其中</p>
<h5 id="基本公式"><a href="#基本公式" class="headerlink" title="基本公式"></a>基本公式</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = hash(key)</span><br><span class="line">h = (p + di) % m</span><br></pre></td></tr></table></figure>
<p>上面的公公式中：</p>
<ol>
<li><code>hash(key)</code>是根据关键字key计算得到的hash值p</li>
<li><code>di</code>是一个增量序列，根据这个增量序列取值的区分，开放地址法也有不同的区分</li>
<li><code>m</code>是hash表的表长(表大小)</li>
</ol>
<h5 id="线性探测再散列"><a href="#线性探测再散列" class="headerlink" title="线性探测再散列"></a>线性探测再散列</h5><p>当上述公式中的增量序列<code>di</code>的取值为递增顺序取值时即为<code>线性探测再散列</code><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">di = 1,2,3,4,5 ... n-1,n   (n &lt;= m - 1)</span><br></pre></td></tr></table></figure></p>
<p>这种方式在发生hash冲突时，会逐步向后移动一个位置，顺序的查看下一个槽位，一直到找出下一个空的槽位或是直到查遍全表</p>
<p>当hash值p出现冲突时，则将数据放到<code>(p + 1) % m</code>处，如果此时还存在冲突，则将数据放到<code>(p + 2) % m</code>处，如果再次存在冲突，则将数据放到<code>(p + 3) % m</code>处，依次类推</p>
<h5 id="二次探测再散列"><a href="#二次探测再散列" class="headerlink" title="二次探测再散列"></a>二次探测再散列</h5><p>当<code>di</code>的取值规则如下时则称为<code>二次探测再散列</code><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1*1,-1*1, 2*2,-2*2, 3*3,-3*3, ..., k*k,-k*k   (k &lt;= m/2)</span><br></pre></td></tr></table></figure></p>
<p>当hash值p出现冲突时，则将数据放到<code>(p + 1) % m</code>处，如果此时还存在冲突，则将数据放到<code>(p - 1) % m</code>处，如果再次存在冲突，则将数据放到<code>(p + 4) % m</code>处，如果依然存在冲突，则将数据放到<code>(p - 4) % m</code>处，依次类推</p>
<h5 id="伪随机探测再散列"><a href="#伪随机探测再散列" class="headerlink" title="伪随机探测再散列"></a>伪随机探测再散列</h5><p>当<code>di</code>的取值是随机数序列时则称为<code>伪随机探测再散列</code><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">di = 随机数序列</span><br><span class="line">//假设有个随机数序列：2，8，3，5，11，6，7</span><br></pre></td></tr></table></figure></p>
<p>当hash值p出现冲突时，则将数据放到<code>(p + 2) % m</code>处，如果此时还存在冲突，则将数据放到<code>(p + 8) % m</code>处，如果再次存在冲突，则将数据放到<code>(p + 3) % m</code>处，如果依然存在冲突，则将数据放到<code>(p + 5) % m</code>处，依次类推</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>对开放地址法构造的哈希表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点</li>
<li>开放地址法要求哈希表空间大于或等于装填数据数目</li>
</ul>
<h3 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h3><p>这种方式是构造多个不同的哈希函数<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hi = RHi(key)     i=1,2,3,...,k</span><br></pre></td></tr></table></figure></p>
<p>当哈希值<code>hi = RH1(key)</code>发生冲突时，再计算<code>hi = RH2(key)</code>….一直到不产生冲突为止。</p>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>这种方式不容易产生聚集，但是增加了计算时间</p>
<h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>这种方法的原理是将所有哈希值为i而导致冲突的元素构成一个同义词单链表，并将单链表的头指针存在哈希表的第i个槽位中。因此对哈希值为i的元素的查找、添加、删除都是在此单链表中进行。结构如下图<br><img src="/img/Java-Basic/java-hash.jpeg" alt="这里写图片描述"></p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li>处理冲突简单，无堆积现象，即非同义词不会产生冲突，平均查找路径较短</li>
<li>链地址法中各链表的节点空间都是动态申请的，因此链地址法比较适合构造Hash表前无法确定表长的业务场景</li>
<li>链地址法构造的哈希表删除操作比较容易实现，只需要简单的删除链表上对应的节点即可</li>
</ol>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><p>链地址法的指针需要额外的空间</p>
<h3 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h3><p>这种方法的原理是将哈希表分为基本表和溢出表两部分，凡是和基本表中元素发生冲突的元素均存入溢出表</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[final、finally、finalize]]></title>
      <url>http://ittiger.cn/Java-final-finally-finalize.html</url>
      <content type="html"><![CDATA[<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><ol>
<li>final可以用来修饰类、方法、变量，修饰对象不同所代表的意义也不同<ul>
<li>修饰类则代表该类不可继承扩展</li>
<li>修饰方法则代表该方法不可重写</li>
<li>修饰变量则代表该变量某种程度不可更改。为什么说是某种程度呢，因为这需要根据变量的类型来区分<ul>
<li>如果修饰的变量是基本类型，则该变量赋值一次之后就无法修改，这是final就是不可变的标志</li>
<li>如果修饰的变量是引用类型，那么该变量赋值一次之后，就无法修改该变量的引用，但是该引用对象的属性还是可以更改的，比较常见的就是变量引用了一个<code>List</code>,虽说用了final修饰，但是依然可以对该<code>List</code>的元素进行各种操作</li>
</ul>
</li>
</ul>
</li>
<li>将变量或参数使用final修饰可以清楚的避免意外赋值导致的编码错误</li>
<li>因为final修饰变量产生了某种程度的不可变的特性，所以它可以保护只读数据，因此在并发编程中使用final修饰变量有利于减少额外的同步开销，也可以省去一些防御性拷贝必要，从而提升性能<a id="more"></a>
<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2>finally是java保证重点代码一定要被执行的一种机制。我们可以使用<code>try-finally</code>或<code>try-catch-finally</code>来进行类型关闭JDBC链接、保证unlock锁等操作</li>
</ol>
<h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h2><p>finalize 是基础类<code>java.lang.Object</code>的一个方法,它的作用是保证对象在被垃圾收集器收集前完成特定资源的回收。finalize机制现在已经不推荐使用，并且在JDK9开始被标记为deprecated。</p>
<p>如果调用了finalize方法，则会导致该对象称为“特殊公民”，JVM需要对它进行额外的处理。这样反而导致了finalize成为了快速回收的阻碍者，它可能导致你的对象经过多个垃圾收集周期才能被回收。</p>
<p>在实践中因为finalize拖慢垃圾收集，导致大量对象堆积，也是一种典型的导致OOM的原因。</p>
<p>因为我们要确保回收资源就是因为资源都是有限的，垃圾收集的时间不可预测，可能会极大加剧资源占用。所以对于消耗非常高频的资源，千万不要指望finalize去承担资源释放的职责。</p>
<p>资源用完立刻显示释放，或者利用资源池尽量重用</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Exception与Error]]></title>
      <url>http://ittiger.cn/Java-Exception-Error.html</url>
      <content type="html"><![CDATA[<p><img src="/img/Java-Basic/java-exception-error.png" alt="这里写图片描述"></p>
<h1 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h1><p><code>Exception</code>和<code>Error</code>都是继承自<code>Throwable</code>，在Java中只有<code>Throwable</code>的实例才可以被抛(<code>throw</code>)出或捕获(<code>catch</code>)，它是java异常处理机制的基本组成类型。</p>
<p><code>Exception</code>和<code>Error</code>体现了Java平台设计者对不同异常情况的分类<br><a id="more"></a></p>
<h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><ol>
<li><code>Exception</code>是程序正常运行中，可以预料的意外情况，可能并且应该被捕获从而进行相应的处理</li>
<li><code>Exception</code>又分为编译器异常和运行期异常。<ul>
<li>编译器异常在代码中必须显示的进行捕获处理，这也是编译期检查的一部分。</li>
<li>运行期异常就是在程序运行过程中，由于程序逻辑等原因导致的运行异常，比如：<code>NullPointerException</code>,<code>ArrayIndexOutOfBoundsException</code>之类，这类异常通常都是可以通过编码避免的逻辑错误，具体根据需要来判断是非需要补货，并不会在编译期强制要求</li>
</ul>
</li>
</ol>
<h1 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h1><p><code>Error</code>是指在正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序(比如JVM自身)处于正常、不可恢复的状态。所以既然是非正常情况，那么也不便于也不需要捕获，常见的比如<code>OutOfMemoryError</code>之类，都是Error的子类。</p>
<h1 id="ClassNotFoundException-amp-amp-NoClassDefFoundError"><a href="#ClassNotFoundException-amp-amp-NoClassDefFoundError" class="headerlink" title="ClassNotFoundException &amp;&amp; NoClassDefFoundError"></a>ClassNotFoundException &amp;&amp; NoClassDefFoundError</h1><h3 id="ClassNotFoundException"><a href="#ClassNotFoundException" class="headerlink" title="ClassNotFoundException"></a>ClassNotFoundException</h3><p>在程序运行过程中通过某个类的字符串名称加载该类时，如果没有找到具有指定名称的类的定义的时候就会抛出<code>ClassNotFoundException</code>异常。通过字符串限定类名加载类主要有如下三种方式：</p>
<ol>
<li><code>Class.forName(java.lang.String)</code></li>
<li><code>ClassLoader.findSystemClass(java.lang.String)</code></li>
<li><code>ClassLoader.loadClass(java.lang.String, boolean)</code></li>
</ol>
<h3 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h3><p>如果<code>JVM</code>或者<code>ClassLoader</code>实例尝试加载（可以通过正常的方法调用，也可能是使用new来创建新的对象）类的时候却找不到类的定义。要查找的类在编译的时候是存在的，运行的时候却找不到了。这个时候就会导致<code>NoClassDefFoundError</code> </p>
<p>造成该问题的原因可能是打包过程漏掉了部分类，或者jar包出现损坏或者篡改。解决这个问题的办法是查找那些在开发期间存在于类路径下但在运行期间却不在类路径下的类。</p>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ol>
<li>在开发过程中尽量不要捕获类似Exception这样的通用异常，而是应该捕获特定异常，因为特定异常可以尽可能多的告知我们错误信息，而通用异常则会隐藏一些信息</li>
<li>程序中不要捕获不希望被捕获的异常，有些时候我们可能更希望<code>RuntimeException</code>扩散出来，而不是被捕获</li>
<li>不要吞掉异常。很多人经常写出这样的代码，因为这样会导致程序出现问题的时候，我们很难定位和发现错误<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//下面就是一个吞掉异常的例子</span><br><span class="line">try &#123;</span><br><span class="line">    //业务逻辑。。。</span><br><span class="line">&#125; catch(IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h1><p>在处理java异常的方法中<code>try-catch-finally</code>是最常用的方式，但是在使用该代码块的时候会有一些隐藏的问题，主要是在方法返回值的问题上。</p>
<p>按照一般的惯性认知：当遇到return语句的时候，执行函数会立刻返回。但是在java中遇到finally的时候就有会例外。</p>
<p>除了return语句，try代码块中的break和continue语句也可能使控制权进入finally代码块。</p>
<p>当函数返回值是引用类型同时存在finally语句块时要特别注意，如果在finally块中对返回的引用对象属性进行了更改，这时即使没有在finally块中显示调用return语句，这个更改也会作用在返回值上。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public User getUser() &#123;</span><br><span class="line">    User user = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        user = new User(&quot;user&quot;);</span><br><span class="line">        //其他业务逻辑。。。</span><br><span class="line">        return user;</span><br><span class="line">    &#125; catch(IOException e) &#123;</span><br><span class="line">        //...</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if(user != null) &#123;</span><br><span class="line">            user.setName(&quot;user1&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码中该函数最终返回的User对象的name属性其实为user1</p>
<p>产生上述问题的原因是因为JVM会保证在return语句执行之前，先执行finally语句</p>
<h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>另外一个使用<code>try-catch</code>要注意的点是<code>try-catch</code>代码段会产生额外的性能开销，它往往会影响JVM对代码进行优化，所以建议仅捕获有必要的代码段，不要一个<code>try-catch</code>包住大段的代码。因此使用异常控制代码流程也不是一个好注意，它远比通常意义上的条件语句(<code>if/else</code>,<code>swich</code>)要低效</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[强引用、软引用、弱引用、虚引用]]></title>
      <url>http://ittiger.cn/Java-Reference.html</url>
      <content type="html"><![CDATA[<p>在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。</p>
<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>特点：我们平常典型编码<code>Object obj = new Object()</code>中的obj就是强引用。</p>
<p>通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出<code>OutOfMemoryError</code>运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。</p>
<a id="more"></a>
<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>特点：软引用通过SoftReference类实现。 </p>
<p>软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 <code>OutOfMemoryError</code> 之前，清理软引用指向的对象。</p>
<p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。</p>
<p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>弱应用同样可用于内存敏感的缓存。</p>
<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>特点：虚引用也叫幻象引用，通过PhantomReference类来实现。</p>
<p>无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue queue = new ReferenceQueue ();</span><br><span class="line">PhantomReference pr = new PhantomReference (object, queue);</span><br></pre></td></tr></table></figure></p>
<p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。</p>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><p>可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[String、StringBuffer与StringBuilder]]></title>
      <url>http://ittiger.cn/Java-String-StringBuffer-StringBuilder.html</url>
      <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h3 id="String的创建机制"><a href="#String的创建机制" class="headerlink" title="String的创建机制"></a>String的创建机制</h3><p>因为String在Java中使用过于频繁，Java为了避免在系统中产生大量的String对象，引入了字符串常量池的概念。 </p>
<p>其运行机制是：</p>
<ul>
<li>创建一个字符串时，首先检查池中是否有值相同的字符串对象(equals决定)，如果有则不需要创建而是直接从常量池中找到的该字符串对象的引用；</li>
<li>如果没有则新建一个字符串对象，返回该对象引用，并且将新创建的字符串对象放入池中<a id="more"></a>
但是通过new方法创建的String对象是不检查字符串池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入池中。</li>
</ul>
<p><strong>举例：</strong><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//通过直接量赋值方式，放入字符串常量池</span><br><span class="line">String str1 = &quot;123&quot;; </span><br><span class="line">//通过new方式赋值方式，不放入字符串常量池</span><br><span class="line">String str2 = new String(“123”);</span><br><span class="line">//此时的str1 != str2</span><br><span class="line"></span><br><span class="line">String str3 = &quot;1&quot; + &quot;2&quot; + &quot;3&quot;;</span><br><span class="line">//str3 == str1 是成立的</span><br></pre></td></tr></table></figure></p>
<p>上述代码中在编译期的时候，str3即被编译成”123”字符串，而此时常量池中已经存在该字符串，所以str3与str1是相等的</p>
<h3 id="String的特性"><a href="#String的特性" class="headerlink" title="String的特性"></a>String的特性</h3><h5 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h5><p>String对象一旦生成，则不能再对它的值进行改变，这里的不可变指这个字符串对象无法改变，而我们平时定义的字符串变量虽然可以改变，但是实质上它是改变了这个变量的引用，相当于将这个变量指向了另外一个字符串对象，而一开始的字符串对象还是没有变的。</p>
<p>不可变的主要作用在于当一个对象需要被多线程共享，并且访问频繁时，可以省略同步和锁等待的时间，从而大幅度提高系统性能。</p>
<p>不可变模式是一个可以提高多线程程序的性能，降低多线程程序复杂度的设计模式。</p>
<h5 id="针对常量池的优化"><a href="#针对常量池的优化" class="headerlink" title="针对常量池的优化"></a>针对常量池的优化</h5><p>当2个String对象拥有相同的值时，他们只引用常量池中的同一个拷贝。当同一个字符串反复出现时，这个技术可以大幅度节省内存空间。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;123&quot;;</span><br><span class="line">String str2 = &quot;123&quot;;</span><br><span class="line">//此时的str1 == str2是成立的</span><br></pre></td></tr></table></figure></p>
<h5 id="为什么不可变"><a href="#为什么不可变" class="headerlink" title="为什么不可变"></a>为什么不可变</h5><p>我们看String的源码可以发现String底层是采用字符数组(<code>char[]</code>)来存储字符串值，该数组的定义如下<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final char value[];</span><br></pre></td></tr></table></figure></p>
<p>这个数组定义为<code>private final</code>，在java中数组也是对象，所以当String对象一旦初始化完成，其内部变量<code>value</code>的引用就无法改变，顶多只能改变数组中元素的值，但是在看遍String的所有方法后，发现String中根本没有一个方法可以改变<code>value</code>这个char数组里面的元素，所以在String初始化完成后即不可变。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;abcde&quot;;</span><br><span class="line">a = a.subString(1);//这时a=&quot;bcde&quot;</span><br></pre></td></tr></table></figure></p>
<p>虽然我们在编码过程中经常会调用String的<code>toLowerCase</code>,<code>substring</code>等方法，如上面的例子中虽然a最终被改变成了<code>&quot;bcde&quot;</code>，但是实际上这是生成的一个新字符串对象，只是将变量a的引用指向了这个新对象，而没有改变原有字符串对象<code>&quot;abcde&quot;</code>的值。</p>
<h1 id="StringBuffer-amp-StringBuilder"><a href="#StringBuffer-amp-StringBuilder" class="headerlink" title="StringBuffer &amp; StringBuilder"></a>StringBuffer &amp; StringBuilder</h1><p><code>StringBuffer</code>和<code>StringBuilder</code>都实现了<code>AbstractStringBuilder</code>抽象类，拥有几乎一致对外提供的调用接口；</p>
<p>其底层在内存中的存储方式与String相同，都是采用char数组存储数据，只是这个char数组没被final修饰，因此这个char数组的引用可以改变且该数组中的元素也可以改变，所以<code>StringBuffer/StringBuilder</code>对象的值是可以改变的。</p>
<p>而<code>StringBuffer/StringBuilder</code>在改变char数组过程中是在该对象自身内部进行的，所以对象本身的引用还是同一个。因此定义一个<code>StringBuffer/StringBuilder</code>变量，修改其值之后，其引用还是同一个，不会改变。</p>
<p>两者对象在构造过程中，首先按照默认大小申请一个字符数组，由于会不断加入新数据，当超过默认大小后，会创建一个更大的数组，并将原先的数组内容复制过来，再丢弃旧的数组。因此，对于较大对象的扩容会涉及大量的内存复制操作，如果能够预先评估大小，可提升性能。</p>
<p>唯一需要注意的是：StringBuffer是线程安全的，但是StringBuilder是线程不安全的。可参看Java标准类库的源代码，StringBuffer类中方法定义前面都会有synchronize关键字。为此，StringBuffer的性能要远低于StringBuilder。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>在字符串内容不经常发生变化的业务场景优先使用String类。例如：常量声明、少量的字符串拼接操作等。如果有大量的字符串内容拼接，避免使用String与String之间的“+”操作，因为这样会产生大量无用的中间对象，耗费空间且执行效率低下（新建对象、回收对象花费大量时间）。</li>
<li>在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在多线程环境下，建议使用StringBuffer，例如XML解析、HTTP参数解析与封装。</li>
<li>在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在单线程环境下，建议使用StringBuilder，例如SQL语句拼装、JSON封装等。</li>
</ul>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微信小程序之页面数据绑定及页面跳转传参]]></title>
      <url>http://ittiger.cn/weixin-xcx-data-binding-and-params-transfer.html</url>
      <content type="html"><![CDATA[<p>在写前面的小程序入门项目时，发现有两个很常用而且觉得也算比较重要的知识点，这里记录下：</p>
<h3 id="页面数据绑定"><a href="#页面数据绑定" class="headerlink" title="页面数据绑定"></a>页面数据绑定</h3><p>比如你的页面需要显示一个<code>Hello</code>字符串，这个这个字符串可能会根据某些情况会动态变化，这个时候就需要进行数据绑定展示了</p>
<p>在wxml文件布局如下：<br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>在js中设置好变量如下：</p>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">	data: &#123;</span><br><span class="line">		message: <span class="hljs-string">"Hello"</span>,</span><br><span class="line">		number: <span class="hljs-number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>就这样data里面的message属性就可以通过view组件展示出来了，看了上面的写法，也很容易明白，组件展示数据信息时是通过<br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;属性名称&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这的写法与data里面的属性进行绑定的。</p>
<p>如果在数据信息展示出来后，后面要更新这个属性信息的展示的话，就不能简单的通过<code>this.data.message=&quot;Hello World&quot;来实现，因为这样是无法达到改变数据信息的目的的。小程序中改变数据信息要求使用函数</code>setData()<code>函数来实现。例如上面我们修改</code>message`的值的话需要进行如下操作：</p>
<!--mroe-->
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">this</span>.setData(&#123;</span><br><span class="line">	message: <span class="hljs-string">"Hello World"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过该函数更新之后，页面上会自动的更新展示，而不需要我们去进行额外的操作，微信将数据的展示与更新进行了分离，只要你使用特定的方法修改属性值，界面就会自动更新，这样的实方式比起android中的手动通知更新要方便很多</p>
<h3 id="页面跳转参数"><a href="#页面跳转参数" class="headerlink" title="页面跳转参数"></a>页面跳转参数</h3><p>小程序中从一个页面跳转到另外一个页面有几种方式，这里我以<code>wx.navigateTo()</code>跳转进行说明：<br>我从<code>index</code>页面跳转到<code>logs</code>页面，很简单</p>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.navigateTo(&#123;</span><br><span class="line">	url: <span class="hljs-string">'../log/logs</span></span><br><span class="line"><span class="hljs-string">&#125;)</span></span><br></pre></td></tr></table></figure>
<p>那如果我在跳转的同时要向<code>logs</code>页面传递参数该怎么办呢，也很简单，直接在url后拼接相关参数即可(与http中的get请求的传参方式是一样的)</p>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.navigateTo(&#123;</span><br><span class="line">	url: <span class="hljs-string">'../video/video?message='</span> + <span class="hljs-keyword">this</span>.data.message + <span class="hljs-string">"&amp;number="</span> + <span class="hljs-keyword">this</span>.data.number</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>参数是传过去了，那在<code>logs</code>页面中该如何获取这些参数呢？其实也很简单：</p>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onLoad: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>&#123;</span><br><span class="line">	<span class="hljs-keyword">var</span> message = options.message;</span><br><span class="line">	<span class="hljs-keyword">var</span> number = options.number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，我们在新页面的<code>onLoad</code>函数中就可以直接获取到传递过来的参数信息。</p>
<h3 id="点击View传参"><a href="#点击View传参" class="headerlink" title="点击View传参"></a>点击View传参</h3><p>在我前面的文章<a href="http://ittiger.cn/weixin-xcx-first-project.html"> 微信小程序之入门项目</a>中点击视频列表中的某一项跳转到视频播放页面，而在点击列表中的某一项时，需要获取当前项的数据信息，如果我想通过点击事件就将这些数据信息作为参数传递过去该怎么做呢？代码如下：</p>
<figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">"&#123;&#123;tab.videos&#125;&#125;"</span> <span class="hljs-attr">wx:for-item</span>=<span class="hljs-string">"video"</span> <span class="hljs-attr">data-video</span>=<span class="hljs-string">"&#123;&#123;video&#125;&#125;"</span> <span class="hljs-attr">wx:key</span>=<span class="hljs-string">"*this"</span> <span class="hljs-attr">bindtap</span>=<span class="hljs-string">"onItemClick"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码通过for循环实现了一个列表，并为每一项绑定了点击事件，而<code>view</code>组件实现中有一个属性是微信没有提供的：<code>data-video</code>，这个属性是我们手动添加上去的，微信中如果要在wxml中传递参数到点击事件中的话则可以通过<code>data-**</code>的形式进行传参(**号即为参数名称)，此处是将每一项数据<code>video</code>作为参数进行传递，同时参数名称为<code>video</code></p>
<p>接下来再来看看点击事件中如何获取该<code>video</code>信息：</p>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onItemClick: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> video = event.currentTarget.dataset.video;</span><br><span class="line">    <span class="hljs-keyword">var</span> url = video.url;</span><br><span class="line">    <span class="hljs-keyword">var</span> title = video.title;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>没错，就像代码中写的，在点击事件中我们可以通过<code>event.currentTarget.dataset</code>获取传过来的<code>video</code>信息，这个参数在调试的时候也是可以通过event对象看到的</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> 小程序 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微信小程序之Tab切换]]></title>
      <url>http://ittiger.cn/weixin-xcx-tabbar-switch.html</url>
      <content type="html"><![CDATA[<p>做过<code>android</code>的都知道在<code>android</code>里面实现<code>Tab切换</code>非常简单，使用<code>android</code>提供的<code>TabLayout+ViewPager</code>很容器就实现了<code>Tab切换</code>的效果。</p>
<p>但是小程序中是没有提供类似可以直接使用的组件，因此想要实现此功能需要我们自己去编码实现。在<a href="http://ittiger.cn/weixin-xcx-first-project.html">上一篇</a>文章中我提到的小程序练手项目就实现了<code>Tab切换</code>效果，具体效果图可以参考文章<a href="http://ittiger.cn/weixin-xcx-first-project.html">微信小程序入门项目</a>。</p>
<a id="more"></a>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>翻看小程序的文档可以发现，微信为我们提供了一个<code>swiper</code>组件，通过该组件可以实现<code>view</code>的滑动切换，它的功能与<code>android</code>中的<code>ViewPager</code>是类似的。因此实现<code>Tab切换</code>现在只需要实现头部的<code>Tabbar</code>即可，对于该功能我们可以采用多个横向排列的<code>view</code>组件构成一个<code>Tabbar</code>，每个<code>view</code>组件作为一个<code>Tab</code>项，然后再将其点击事件与<code>swiper</code>进行关联即可实现<code>Tab</code>的点击和滑动切换功能。而对于<code>Tabbar</code>的当前<code>Tab</code>项下面的指示器我们可以采用<code>border-bottom</code>样式实现，也可以单独使用一个<code>view</code>组件作为指示器，我这里采用的是第二种方式实现指示器。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>实现代码如下：</p>
<h4 id="页面布局代码"><a href="#页面布局代码" class="headerlink" title="页面布局代码"></a>页面布局代码</h4><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"page"</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar"</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">block</span> <span class="hljs-attr">wx:for</span>=<span class="hljs-string">"&#123;&#123;tabs&#125;&#125;"</span> <span class="hljs-attr">wx:key</span>=<span class="hljs-string">"*this"</span>&gt;</span></span><br><span class="line">          <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"&#123;&#123;index&#125;&#125;"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar__item &#123;&#123;activeIndex == index ? 'navbar__item_on' : ''&#125;&#125;"</span> <span class="hljs-attr">bindtap</span>=<span class="hljs-string">"navTabClick"</span>&gt;</span></span><br><span class="line">            <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar__title"</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="line">          <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;/<span class="hljs-name">block</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar__slider"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width: &#123;&#123;sliderWidth&#125;&#125;px; transform: translateX(&#123;&#123;sliderOffset&#125;&#125;px); -webkit-transform: translateX(&#123;&#123;sliderOffset&#125;&#125;px);"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="line">  <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"position: absolute;top: 68rpx;width: 100%;height:&#123;&#123;contentHeight&#125;&#125;px"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">swiper</span> <span class="hljs-attr">current</span>=<span class="hljs-string">"&#123;&#123;activeIndex&#125;&#125;"</span> <span class="hljs-attr">duration</span>=<span class="hljs-string">"300"</span> <span class="hljs-attr">bindchange</span>=<span class="hljs-string">"bindChange"</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>热门视频<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>比赛集锦<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>你懂专栏<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;<span class="hljs-name">swiper-item</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>天下足球<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;/<span class="hljs-name">swiper-item</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">swiper</span>&gt;</span> </span><br><span class="line">  <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="布局样式代码"><a href="#布局样式代码" class="headerlink" title="布局样式代码"></a>布局样式代码</h4><figure class="highlight css hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-selector-tag">view</span> , <span class="hljs-selector-tag">page</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0px</span>;</span><br><span class="line">  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-class">.page</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-class">.navbar</span> &#123;</span><br><span class="line">    <span class="hljs-attribute">display</span>: flex;</span><br><span class="line">    <span class="hljs-attribute">position</span>: absolute;</span><br><span class="line">    <span class="hljs-attribute">z-index</span>: <span class="hljs-number">500</span>;</span><br><span class="line">    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-class">.navbar__item</span> &#123;</span><br><span class="line">    <span class="hljs-attribute">position</span>: relative;</span><br><span class="line">    <span class="hljs-attribute">display</span>: block;</span><br><span class="line">    <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">10</span>rpx <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-attribute">text-align</span>: center;</span><br><span class="line">    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-attribute">height</span>: <span class="hljs-number">48</span>rpx;</span><br><span class="line">    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">48</span>rpx;</span><br><span class="line">    &lt;!-- NavBar的总高度为：height + padding-top + padding-bottom = 68rpx --&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-class">.navbar__item_on</span> &#123;</span><br><span class="line">    <span class="hljs-attribute">color</span>: <span class="hljs-number">#16B13A</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-class">.navbar__slider</span> &#123;</span><br><span class="line">    <span class="hljs-attribute">position</span>: absolute;</span><br><span class="line">    <span class="hljs-attribute">display</span>: block;</span><br><span class="line">    <span class="hljs-attribute">content</span>: <span class="hljs-string">" "</span>;</span><br><span class="line">    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-attribute">height</span>: <span class="hljs-number">3px</span>;</span><br><span class="line">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#16B13A</span>;</span><br><span class="line">    <span class="hljs-attribute">transition</span>: transform .<span class="hljs-number">3s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-class">.navbar__title</span>&#123;</span><br><span class="line">    <span class="hljs-attribute">display</span>: inline-block;</span><br><span class="line">    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">15px</span>;</span><br><span class="line">    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">8em</span>;</span><br><span class="line">    <span class="hljs-attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-tag">swiper</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-selector-tag">swiper-item</span>&#123;</span><br><span class="line">  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="line">  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">20</span>rpx;</span><br><span class="line">  <span class="hljs-attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="js代码"><a href="#js代码" class="headerlink" title="js代码"></a>js代码</h4><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> tabs = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="hljs-string">"热门视频"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="hljs-string">"比赛集锦"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="hljs-string">"你懂专栏"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="hljs-string">"天下足球"</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">   * 页面的初始数据</span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    tabs: tabs,     <span class="hljs-comment">//展示的数据</span></span><br><span class="line">    slideOffset: <span class="hljs-number">0</span>,<span class="hljs-comment">//指示器每次移动的距离</span></span><br><span class="line">    activeIndex: <span class="hljs-number">0</span>,<span class="hljs-comment">//当前展示的Tab项索引</span></span><br><span class="line">    sliderWidth: <span class="hljs-number">96</span>,<span class="hljs-comment">//指示器的宽度,计算得到</span></span><br><span class="line">    contentHeight: <span class="hljs-number">0</span><span class="hljs-comment">//页面除去头部Tabbar后，内容区的总高度，计算得到</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">   * 生命周期函数--监听页面加载</span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br><span class="line">  onLoad: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;</span><br><span class="line">    wx.getSystemInfo(&#123;</span><br><span class="line">      success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">        <span class="hljs-comment">//计算相关宽度</span></span><br><span class="line">          sliderWidth: res.windowWidth / that.data.tabs.length,</span><br><span class="line">          sliderOffset: res.windowWidth / that.data.tabs.length * that.data.activeIndex,</span><br><span class="line">          contentHeight: res.windowHeight - res.windowWidth / <span class="hljs-number">750</span> * <span class="hljs-number">68</span><span class="hljs-comment">//计算内容区高度，rpx -&gt; px计算</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  bindChange: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> current = e.detail.current;</span><br><span class="line">    <span class="hljs-keyword">this</span>.setData(&#123;</span><br><span class="line">      activeIndex: current,</span><br><span class="line">      sliderOffset: <span class="hljs-keyword">this</span>.data.sliderWidth * current</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"bindChange:"</span> + current);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  navTabClick: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.setData(&#123;</span><br><span class="line">      sliderOffset: e.currentTarget.offsetLeft,</span><br><span class="line">      activeIndex: e.currentTarget.id</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"navTabClick:"</span> + e.currentTarget.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面的布局代码和js代码其实写起来都不难，关键在于css样式的编写，对于不熟悉CSS的人来说调样式太痛苦了。这个效果也是我调了好半天，参考了好多代码之后写出来的，真o(╯□╰)o，看来想写好小程序还得好好学学CSS样式。</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> 小程序 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微信小程序之入门项目]]></title>
      <url>http://ittiger.cn/weixin-xcx-first-project.html</url>
      <content type="html"><![CDATA[<p>最近在学习微信小程序，尝试着写了一个足球视频播放的小程序，先放效果截图吧</p>
<a id="more"></a>
<p><img src="/img/weixin-xcx/1.jpg" width="400"></p>
<p><img src="/img/weixin-xcx/2.jpg" width="400"></p>
<p><img src="/img/weixin-xcx/3.jpg" width="400"></p>
<hr>
<p>通过这个小程序的练习熟悉小程序中网络加载，页面编写和配置，页面跳转及传参，页面展示时的数据绑定以及独立模块的引用等知识点。</p>
<p>当然写小程序最重要的一点是必须要熟悉CSS样式的编写，对于我这种对CSS不熟的人来说真是太困难了。一个界面效果都需要调上半天。</p>
<p>项目代码地址如下：<br><a href="https://github.com/huyongli/WXSoccerVideo" target="_blank" rel="noopener">https://github.com/huyongli/WXSoccerVideo</a></p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> 小程序 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TextSwitcher与ViewSwitcher学习笔记]]></title>
      <url>http://ittiger.cn/TextSwitcher-ViewSwitcher.html</url>
      <content type="html"><![CDATA[<p><code>TextSwitcher</code>和<code>ViewSwitcher</code>是什么，有什么用呢？</p>
<p>其实大家从名字就可以看出来其大概意思，<code>TextSwitcher</code>是用来切换文本显示的，而<code>ViewSwitcher</code>是用来切换视图显示的，实际上他们也的确是用来做这个的，只不过他们在切换视图显示的时候允许添加切换的动画效果。<code>TextSwitcher</code>其实也是<code>ViewSwitcher</code>的子类实现。</p>
<h3 id="TextSwitcher使用"><a href="#TextSwitcher使用" class="headerlink" title="TextSwitcher使用"></a>TextSwitcher使用</h3><p>我们先来看看<code>TextSwitcher</code>的用法：<br><a id="more"></a><br>关键布局代码如下：<br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/button"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">"change"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">TextSwitcher</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/switcher"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Java代码如下：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//设置显示Text文本的View创建工厂</span></span><br><span class="line"><span class="hljs-comment">//这是通过代码的方式创建显示文本的视图，也可以直接在布局中设置显示文本的视图，这个在讲ViewSwitcher的用法的时候再说</span></span><br><span class="line">mTextSwitcher.setFactory(<span class="hljs-keyword">new</span> ViewSwitcher.ViewFactory() &#123;</span><br><span class="line">     <span class="hljs-meta">@Override</span></span><br><span class="line">     <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">makeView</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         TextView t = <span class="hljs-keyword">new</span> TextView(TextSwitcherActivity.<span class="hljs-keyword">this</span>);</span><br><span class="line">         t.setGravity(Gravity.TOP | Gravity.CENTER_HORIZONTAL);</span><br><span class="line">         t.setTextAppearance(TextSwitcherActivity.<span class="hljs-keyword">this</span>, android.R.style.TextAppearance_Large);</span><br><span class="line">         <span class="hljs-keyword">return</span> t;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> Animation in = AnimationUtils.loadAnimation(<span class="hljs-keyword">this</span>,</span><br><span class="line">         android.R.anim.fade_in);</span><br><span class="line"> Animation out = AnimationUtils.loadAnimation(<span class="hljs-keyword">this</span>,</span><br><span class="line">         android.R.anim.fade_out);</span><br><span class="line"> mTextSwitcher.setInAnimation(in);<span class="hljs-comment">//设置文本出现动画</span></span><br><span class="line"> mTextSwitcher.setOutAnimation(out);<span class="hljs-comment">//设置文本消失动画</span></span><br><span class="line"> mTextSwitcher.setCurrentText(String.valueOf(mCount));<span class="hljs-comment">//设置初始值，初始值不显示动画</span></span><br><span class="line"> </span><br><span class="line"> <span class="hljs-keyword">int</span> mCount = <span class="hljs-number">0</span>;</span><br><span class="line"> mButton.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;</span><br><span class="line">	    mCount++;</span><br><span class="line">		mTextSwitcher.setText(String.valueOf(mCount));<span class="hljs-comment">//更新文本显示值，会出现动画     </span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>当你点击界面上的按钮的时候，会不断的更新<code>TextSwitcher</code>的显示值，而在更新过程中文本会出现一个淡入淡出的效果，这个效果就是通过动画产生的。</p>
<h3 id="ViewSwitcher使用"><a href="#ViewSwitcher使用" class="headerlink" title="ViewSwitcher使用"></a>ViewSwitcher使用</h3><p>接着我们再来看看<code>ViewSwitcher</code>的使用<br>布局代码：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">    android:id=&quot;@+id/button2&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_marginTop=&quot;20dp&quot;</span><br><span class="line">    android:text=&quot;change&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;ViewSwitcher</span><br><span class="line">    android:id=&quot;@+id/viewSwitcher&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;&gt;</span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:layout_width=&quot;300dp&quot;</span><br><span class="line">        android:layout_height=&quot;300dp&quot;</span><br><span class="line">        android:src=&quot;@drawable/image1&quot;/&gt;</span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:layout_width=&quot;300dp&quot;</span><br><span class="line">        android:layout_height=&quot;300dp&quot;</span><br><span class="line">        android:src=&quot;@drawable/image2&quot;/&gt;</span><br><span class="line">&lt;/ViewSwitcher&gt;</span><br></pre></td></tr></table></figure>
<p>上面的布局中我们给<code>ViewSwitcher</code>添加了两个子视图，注意这里只能添加两个直接子视图，否则初始化会出现异常，至于原因后面接着说。前面说过<code>TextSwitcher</code>也可以通过布局设置文本显示视图，它的设置方式与<code>ViewSwitcher</code>其实也是一样的。</p>
<p>ok，接着上Java代码</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//因为我们已经通过布局的方式设置了要切换的视图，所以就不需要再设置Factory去生成切换视图了</span></span><br><span class="line">Animation slide_in_left = AnimationUtils.loadAnimation(<span class="hljs-keyword">this</span>,</span><br><span class="line">                android.R.anim.slide_in_left);</span><br><span class="line">Animation slide_out_right = AnimationUtils.loadAnimation(<span class="hljs-keyword">this</span>,</span><br><span class="line">       android.R.anim.slide_out_right);</span><br><span class="line">mViewSwitcher.setInAnimation(slide_in_left);<span class="hljs-comment">//设置图片出现动画</span></span><br><span class="line">mViewSwitcher.setOutAnimation(slide_out_right);<span class="hljs-comment">//设置图片消失动画</span></span><br><span class="line">mButton2.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;</span><br><span class="line">		mViewSwitcher.showNext();     </span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面就是<code>ViewSwitcher</code>的使用方式，其实用起来还是很简单的。通过自定义动画，我们可以为两个View切换时添加更多漂亮有趣的动画效果</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>在Android开发中视图切换显示还是很常见的，比如应用加载数据时显示加载动画视图数据视图隐藏，而加载成功后加载动画视图隐藏数据视图显示，这个场景使用<code>ViewSwitcher</code>来实现应该会更简单，更方便。</p>
<h3 id="源码探究"><a href="#源码探究" class="headerlink" title="源码探究"></a>源码探究</h3><ul>
<li>前面说到过<code>ViewSwitcher</code>只能存在两个直接子视图，否则会初始化失败，这是为什么呢？通过源码我们可以找到答案</li>
</ul>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addView(View child, int index, ViewGroup.LayoutParams params) &#123;</span><br><span class="line">   if (getChildCount() &gt;= 2) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Can&apos;t add more than 2 views to a ViewSwitcher&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">   super.addView(child, index, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在前面<code>ViewSwitcher</code>的使用中我们点击按钮的时候直接调用了<code>mViewSwitcher.showNext();</code>，既然只能有两个子视图，那我们每次点击都<code>showNext()</code>怎么会没出现越界异常呢？ok，我们还是看看源码中是怎么实现的</li>
</ul>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@android.view.RemotableViewMethod</span><br><span class="line">public void showNext() &#123;</span><br><span class="line">   setDisplayedChild(mWhichChild + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@android.view.RemotableViewMethod</span><br><span class="line">public void setDisplayedChild(int whichChild) &#123;</span><br><span class="line">    mWhichChild = whichChild;</span><br><span class="line">    if (whichChild &gt;= getChildCount()) &#123;</span><br><span class="line">        mWhichChild = 0;</span><br><span class="line">    &#125; else if (whichChild &lt; 0) &#123;</span><br><span class="line">        mWhichChild = getChildCount() - 1;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean hasFocus = getFocusedChild() != null;</span><br><span class="line">    // This will clear old focus if we had it</span><br><span class="line">    showOnly(mWhichChild);</span><br><span class="line">    if (hasFocus) &#123;</span><br><span class="line">        // Try to retake focus if we had it</span><br><span class="line">        requestFocus(FOCUS_FORWARD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的实现我们可以看到当其显示的child索引出现越界之后，会自动的进行循环显示，这也是为什么一直调用<code>showNext()</code>没出现越界异常的原因</p>
<h4 id="切换原理"><a href="#切换原理" class="headerlink" title="切换原理"></a>切换原理</h4><p>我们再来看看其切换显示过程中视图的显示和隐藏及动画是如何实现的<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void showOnly(int childIndex, boolean animate) &#123;</span><br><span class="line">    final int count = getChildCount();</span><br><span class="line">    for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        final View child = getChildAt(i);</span><br><span class="line">        if (i == childIndex) &#123;</span><br><span class="line">            if (animate &amp;&amp; mInAnimation != null) &#123;</span><br><span class="line">                child.startAnimation(mInAnimation);</span><br><span class="line">            &#125;</span><br><span class="line">            child.setVisibility(View.VISIBLE);</span><br><span class="line">            mFirstTime = false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (animate &amp;&amp; mOutAnimation != null &amp;&amp; child.getVisibility() == View.VISIBLE) &#123;</span><br><span class="line">                child.startAnimation(mOutAnimation);</span><br><span class="line">            &#125; else if (child.getAnimation() == mInAnimation)</span><br><span class="line">                child.clearAnimation();</span><br><span class="line">            child.setVisibility(View.GONE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码实现也很简单，当显示指定索引的child时，将其设置为可见并执行<code>mInAnimation</code>，其他视图在设置为不可见并执行<code>mOutAnimation</code>动画</p>
<h4 id="Factory作用原理"><a href="#Factory作用原理" class="headerlink" title="Factory作用原理"></a>Factory作用原理</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void setFactory(ViewFactory factory) &#123;</span><br><span class="line">    mFactory = factory;</span><br><span class="line">    obtainView();</span><br><span class="line">    obtainView();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private View obtainView() &#123;</span><br><span class="line">    View child = mFactory.makeView();</span><br><span class="line">    LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">    if (lp == null) &#123;</span><br><span class="line">        lp = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);</span><br><span class="line">    &#125;</span><br><span class="line">    addView(child, lp);</span><br><span class="line">    return child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过源码实现我们可以知道<code>mTextSwitcher.setFactory(mFactory)</code>设置完成之后，<code>ViewSwitcher</code>会立刻生成两个视图作为其子视图作为切换显示用。</p>
<p>示例代码在这里：<a href="https://github.com/huyongli/AndroidDemo/blob/master/app/src/main/java/cn/ittiger/demo/activity/TextSwitcherActivity.java" target="_blank" rel="noopener">https://github.com/huyongli/AndroidDemo</a></p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> View </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于媒体浏览器服务(MediaBrowserService)]]></title>
      <url>http://ittiger.cn/MediaBrowserService.html</url>
      <content type="html"><![CDATA[<p>今天说的这个主题与媒体播放有关，尤其是音乐播放，说到音乐播放大家应该都用过音乐App。<br>通常一个音乐App的实现主要涉及如下几点：</p>
<ol>
<li>从服务器获取音乐数据</li>
<li>播放音乐时播放器的各种播放状态以及不同状态下的UI展示</li>
<li>播放过程中通过UI界面控制播放器的各种状态</li>
<li>UI控制如何与播放服务进行关联并进行状态同步</li>
<li>如何保证后台播放过程中播放服务不被杀死</li>
</ol>
<p>对于上面的这几点，其实<code>Android</code>已经为我们提供了一套完整的解决方案，它已经很好的将这些操作进行了封装，我们只需要关注数据的获取和歌曲的播放即可。<code>Android</code>提供的这套API在<code>support-v4</code>中提供了兼容版本，因此在使用的过程中最好使用该版本以兼容低版本系统。</p>
<p>关键类主要有如下几个：</p>
<ol>
<li><code>MediaBrowserServiceCompat</code> 媒体浏览器服务</li>
<li><code>MediaBrowserCompat</code> 媒体浏览器</li>
<li><code>MediaControllerCompat</code> 媒体控制器</li>
<li><code>MediaSessionCompat</code> 媒体会话<br>我们一个个来说。</li>
</ol>
<a id="more"></a>
<h3 id="MediaBrowserServiceCompat"><a href="#MediaBrowserServiceCompat" class="headerlink" title="MediaBrowserServiceCompat"></a>MediaBrowserServiceCompat</h3><p>该类有两个作用：</p>
<ol>
<li>音乐播放后台服务</li>
<li>客户端中获取音乐数据的服务，所有的音乐数据都通过该服务与服务端进行交互获取(或者直接获取手机中的本地音乐数据)</li>
</ol>
<p>既然知道该类是<code>Service</code>的子类实现，所以说它是音乐播放的后台服务也好理解，但是该类作为一个后台播放服务却不是通过其自身直接实现的，而是通过<code>MediaSessionCompat</code>媒体会话这个类来实现的。在使用过程中媒体会话会与该服务关联起来，所有的播放操作都交由<code>MediaSessionCompat</code>实现。</p>
<p>而对于获取数据，则是通过<code>MediaBrowserServiceCompat</code>的如下两个方法来进行控制：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> BrowserRoot <span class="hljs-title">onGetRoot</span><span class="hljs-params">(@NonNull String clientPackageName, <span class="hljs-keyword">int</span> clientUid,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                             Bundle rootHints)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 在返回数据之前，可以进行黑白名单控制，以控制不同客户端浏览不同的媒体资源</span></span><br><span class="line"><span class="hljs-comment">     * */</span></span><br><span class="line">    <span class="hljs-keyword">if</span>(!PackageUtil.isCallerAllowed(<span class="hljs-keyword">this</span>, clientPackageName, clientUid)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BrowserRoot(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//此方法只在服务连接的时候调用</span></span><br><span class="line">    <span class="hljs-comment">//返回一个rootId不为空的BrowserRoot则表示客户端可以连接服务，也可以浏览其媒体资源</span></span><br><span class="line">    <span class="hljs-comment">//如果返回null则表示客户端不能流量媒体资源</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BrowserRoot(BrowserRootId.MEDIA_ID_ROOT, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLoadChildren</span><span class="hljs-params">(@NonNull String parentId, @NonNull Result&lt;List&lt;MediaItem&gt;&gt; result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/***</span></span><br><span class="line"><span class="hljs-comment">     * 此方法中的parentId与上面的方法onGetRoot中返回的RootId没有关系</span></span><br><span class="line"><span class="hljs-comment">     * 客户端连接后，它可以通过重复调用MediaBrowserCompat.subscribe() 方法来发起数据获取请求。</span></span><br><span class="line"><span class="hljs-comment">     * 而每次调用subscribe() 方法都会发送一个onLoadChildren（）回调到该service中，然后返回一个MediaBrowser.MediaItem(音乐数据) 对象列表</span></span><br><span class="line"><span class="hljs-comment">     *</span></span><br><span class="line"><span class="hljs-comment">     * 每个MediaItem 都有唯一的ID字符串，它其实是一个隐式的token。</span></span><br><span class="line"><span class="hljs-comment">     * 当客户想打开子菜单或播放一个item时，它就将ID传入。</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">if</span>(BrowserRootId.MEDIA_ID_MUSIC_LIST_REFRESH.equals(parentId)) &#123;</span><br><span class="line">        <span class="hljs-comment">//在当前方法执行结束返回之前必须要调用result.detach(),否则无法发起请求</span></span><br><span class="line">        result.detach();</span><br><span class="line">        MusicProvider.getInstance().requestMusic(result);</span><br><span class="line">        <span class="hljs-comment">//如果想要通过http请求来获取数据，则必须按照上面说的必须要先调用result.detach();方法，否则会出现异常。http请求结束之后则通过调用result.sendResult(mMetadataCompatList);将数据返回,返回的数据在注册的接口MediaBrowserCompat.SubscriptionCallback中通过回调拿到在界面上进行展示</span></span><br><span class="line">        <span class="hljs-comment">//而且此处返回的数据类型必须是MediaBrowser.MediaItem</span></span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        result.detach();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="MediaBrowserCompat"><a href="#MediaBrowserCompat" class="headerlink" title="MediaBrowserCompat"></a>MediaBrowserCompat</h3><p>前面说过<code>MediaBrowserServiceCompat</code>(媒体浏览服务)是作为数据请求服务来获取数据的，因此相应的会有一个媒体浏览客户端来发起媒体数据的获取请求，该类就是这个客户端。<br>前面已经介绍过通过调用<code>MediaBrowserCompat.subscribe()</code>方法来发起数据请求，而在调用此方法之前，必须保证<code>MediaBrowserCompat</code>连接上媒体浏览服务，连接方式如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//通过如下代码连接MediaBrowserServiceCompat，连接成功后获取媒体会话token</span></span><br><span class="line"><span class="hljs-comment">//通过媒体会话token创建MediaControllerCompat </span></span><br><span class="line"><span class="hljs-comment">//这时就将MediaControllerCompat与媒体会话MediaSessionCompat关联起来了</span></span><br><span class="line">MediaBrowserCompat mediaBrowser = <span class="hljs-keyword">new</span> MediaBrowserCompat(<span class="hljs-keyword">this</span>,</span><br><span class="line">                <span class="hljs-keyword">new</span> ComponentName(<span class="hljs-keyword">this</span>, MusicService.class), mConnectionCallback, <span class="hljs-keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//连接媒体浏览服务成功后的回调接口</span></span><br><span class="line"><span class="hljs-keyword">final</span> MediaBrowserCompat.ConnectionCallback mConnectionCallback =</span><br><span class="line">    <span class="hljs-keyword">new</span> MediaBrowserCompat.ConnectionCallback() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onConnected</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">	            <span class="hljs-comment">//获取与MediaBrowserServiceCompat关联的媒体会话token</span></span><br><span class="line">	            MediaSessionCompat.Token token = mMediaBrowser.getSessionToken();</span><br><span class="line">	            <span class="hljs-comment">//通过媒体会话token创建媒体控制器并与之关联</span></span><br><span class="line">	            <span class="hljs-comment">//关联之后媒体控制器就可以控制播放器的各种播放状态了</span></span><br><span class="line">                MediaControllerCompat mediaController = <span class="hljs-keyword">new</span> MediaControllerCompat(<span class="hljs-keyword">this</span>, token);</span><br><span class="line">                <span class="hljs-comment">//将媒体控制器与当前上下文Context进行关联</span></span><br><span class="line">                <span class="hljs-comment">//此处关联之后，我们在界面上操作某些UI的时候就可以通过当前上下文Context来获取当前的MediaControllerCompat</span></span><br><span class="line">                <span class="hljs-comment">//MediaControllerCompat controller = MediaControllerCompat.getMediaController((Activity) context);</span></span><br><span class="line">		        MediaControllerCompat.setMediaController(<span class="hljs-keyword">this</span>, mediaController);</span><br><span class="line">		        <span class="hljs-comment">//为媒体控制器注册回调接口	        mediaController.registerCallback(mMediaControllerCallback);</span></span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                onMediaControllerConnectedFailed();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//媒体控制器控制播放过程中的回调接口</span></span><br><span class="line"><span class="hljs-keyword">final</span> MediaControllerCompat.Callback mMediaControllerCallback =</span><br><span class="line">   <span class="hljs-keyword">new</span> MediaControllerCompat.Callback() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPlaybackStateChanged</span><span class="hljs-params">(@NonNull PlaybackStateCompat state)</span> </span>&#123;</span><br><span class="line">			<span class="hljs-comment">//播放状态发生改变时的回调</span></span><br><span class="line">            onMediaPlayStateChanged(state);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMetadataChanged</span><span class="hljs-params">(MediaMetadataCompat metadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span>(metadata == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">//播放的媒体数据发生变化时的回调</span></span><br><span class="line">            onPlayMetadataChanged(metadata);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//发起数据请求</span></span><br><span class="line"> <span class="hljs-comment">//先解除订阅</span></span><br><span class="line"> mediaBrowser.unsubscribe(BrowserRootId.MEDIA_ID_MUSIC_LIST_REFRESH);</span><br><span class="line"> <span class="hljs-comment">//重新对BrowserRootId进行订阅</span></span><br><span class="line"> <span class="hljs-comment">//调用此方法后，会接着执行MusicService中的onGetRoot方法和onLoadChildren方法</span></span><br><span class="line"> <span class="hljs-comment">//onGetRoot方法(只会调用一次)决定是否允许当前客户端连接服务和获取媒体数据</span></span><br><span class="line"> <span class="hljs-comment">//如果允许连接服务同时也允许获取媒体数据，则会接着调用onLoadChildren方法开始获取数据</span></span><br><span class="line"> <span class="hljs-comment">//数据获取成功后会调用订阅的回调接口将数据返回回来</span></span><br><span class="line"> mediaBrowser.subscribe(BrowserRootId.MEDIA_ID_MUSIC_LIST_REFRESH, mSubscriptionCallback);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//向媒体流量服务发起媒体浏览请求的回调接口</span></span><br><span class="line"><span class="hljs-keyword">final</span> MediaBrowserCompat.SubscriptionCallback mSubscriptionCallback =</span><br><span class="line">    <span class="hljs-keyword">new</span> MediaBrowserCompat.SubscriptionCallback() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onChildrenLoaded</span><span class="hljs-params">(@NonNull String parentId,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">                                     @NonNull List&lt;MediaBrowserCompat.MediaItem&gt; children)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-comment">//数据获取成功后的回调</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(@NonNull String id)</span> </span>&#123;</span><br><span class="line">	        <span class="hljs-comment">//数据获取失败的回调</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="MediaSessionCompat"><a href="#MediaSessionCompat" class="headerlink" title="MediaSessionCompat"></a>MediaSessionCompat</h3><p>前面说过<code>MediaBrowserServiceCompat</code>的媒体播放其实是通过关联的<code>MediaSessionCompat</code>来实现的，而其关联方式也很简单：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">MediaSessionCompat mSession = <span class="hljs-keyword">new</span> MediaSessionCompat(<span class="hljs-keyword">this</span>, <span class="hljs-string">"MusicService"</span>);</span><br><span class="line">setSessionToken(mSession.getSessionToken());</span><br><span class="line">mSession.setCallback(<span class="hljs-keyword">new</span> MediaSessionCompat.Callback());</span><br><span class="line">mSession.setFlags(MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS | MediaSessionCompat.FLAG_HANDLES_TRANSPORT_CONTROLS);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//MediaSessionCompat的播放控制则又全部是通过接口MediaSessionCompat.Callback来实现的</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPlay</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//点击播放按钮时触发</span></span><br><span class="line"><span class="hljs-comment">//通过MediaControllerCompat .getTransportControls().play();触发</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="hljs-meta">@Override</span></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSkipToQueueItem</span><span class="hljs-params">(<span class="hljs-keyword">long</span> queueId)</span> </span>&#123;</span><br><span class="line">     <span class="hljs-comment">//播放指定对列媒体时触发</span></span><br><span class="line">     <span class="hljs-comment">//通过MediaControllerCompat .getTransportControls().onSkipToQueueItem(queueId);触发</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="hljs-meta">@Override</span></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSeekTo</span><span class="hljs-params">(<span class="hljs-keyword">long</span> position)</span> </span>&#123;</span><br><span class="line">     <span class="hljs-comment">//设置到指定进度时触发</span></span><br><span class="line">     <span class="hljs-comment">//MediaControllerCompat.getTransportControls().seekTo(position);</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="hljs-meta">@Override</span></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPlayFromMediaId</span><span class="hljs-params">(String mediaId, Bundle extras)</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//播放指定媒体数据时触发</span></span><br><span class="line"><span class="hljs-comment">//MediaControllerCompat.getTransportControls().playFromMediaId(mediaItem.getMediaId(), null);        </span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="hljs-meta">@Override</span></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//暂停时触发</span></span><br><span class="line"><span class="hljs-comment">//MediaControllerCompat.getTransportControls().pause();</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="hljs-meta">@Override</span></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//停止播放时触发</span></span><br><span class="line"><span class="hljs-comment">//MediaControllerCompat.getTransportControls().stop();</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="hljs-meta">@Override</span></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSkipToNext</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//跳到下一首时触发</span></span><br><span class="line"><span class="hljs-comment">//MediaControllerCompat.getTransportControls().skipToNext();</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="hljs-meta">@Override</span></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSkipToPrevious</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"><span class="hljs-comment">//跳到上一首时触发</span></span><br><span class="line"><span class="hljs-comment">//MediaControllerCompat.getTransportControls().skipToPrevious();</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="hljs-comment">//当然还有很多回调函数，大家可以自行查看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="MediaControllerCompat"><a href="#MediaControllerCompat" class="headerlink" title="MediaControllerCompat"></a>MediaControllerCompat</h3><p>媒体控制器在上面已经介绍了其创建和关联方式，而它控制播放器状态的方式在上面的代码注释中已经说明了，基本上都是通过<code>MediaControllerCompat.getTransportControls()</code>来进行控制的。</p>
<p>到这里媒体服务的相关使用和注意点已经介绍完了，使用这套api来实现音乐APP还是很方便很快捷的，而且我们可以很方便的切换播放器，如<code>MediaPlayer</code>,<code>ExoPlayer</code>等，如有建议和问题欢迎在博客关于页中扫码加QQ群交流。</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Media </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Behavior实现UC浏览器首页动画效果]]></title>
      <url>http://ittiger.cn/behavior-uc-main-page.html</url>
      <content type="html"><![CDATA[<p>老规矩，还是先上效果图<br><img src="/img/material-design/uc-main-view-behavior.gif" width="360" height="640" alt="图片名称" align="center"></p>
<p><a href="https://github.com/huyongli/UCMainViewForBehavior" target="_blank" rel="noopener">github地址</a></p>
<a id="more"></a>
<p>前面我也写过一篇关于UC浏览器首页滑动动画效果的文章<a href="http://ittiger.cn/UC%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A6%96%E9%A1%B5%E6%BB%91%E5%8A%A8%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0.html">UC浏览器首页滑动动画实现</a>，只不过这篇文章是通过自定义View的方式实现这个滑动效果。最近在看<code>Behavior</code>相关的东西，所以使用<code>Behavior</code>又实现了一次UC浏览器主页的滑动效果，使用<code>Behavior</code>实现相比较自定义View的实现方式还是要简单方便很多。</p>
<h3 id="View结构分析"><a href="#View结构分析" class="headerlink" title="View结构分析"></a>View结构分析</h3><p>UC首页滑动过程中可以分为四个<code>View</code>在参与滑动，具体的分析流程可以参见<a href="http://ittiger.cn/UC%E6%B5%8F%E8%A7%88%E5%99%A8%E9%A6%96%E9%A1%B5%E6%BB%91%E5%8A%A8%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0.html">UC浏览器首页滑动动画实现</a>这篇文章的分析，这里简要罗列下：</p>
<ol>
<li><code>UCViewTitle:</code>首页标题栏视图(UC首页显示<code>UC头条</code>)</li>
<li><code>UCViewHeader:</code>首页头部导航视图(UC首页显示各个网站ICON入口)</li>
<li><code>UCViewContent:</code>首页内容视图(UC首页显示新闻内容的列表)</li>
<li><code>UCViewTab:</code>首页内容<code>Tab</code>导航视图(UC首页显示新闻分类的View)</li>
</ol>
<h3 id="Behavior"><a href="#Behavior" class="headerlink" title="Behavior"></a>Behavior</h3><p>既然已经决定通过<code>Behavior</code>实现此效果，那下面几个概念就必须要弄清楚：</p>
<ol>
<li><code>Behavior</code>必须作用于<code>CoordinatorLayout</code>直接子<code>View</code>才会生效</li>
<li><code>Behavior</code>其实是对嵌套滑动的应用，因为<code>CoordinatorLayout</code>其实是实现嵌套滑动，最终对嵌套滑动的执行交给<code>Behavior</code>来实现，所以<code>Behavior</code>的滑动处理必须要有能触发嵌套滑动的<code>子View</code>触发才会起作用</li>
</ol>
<h3 id="关于嵌套滑动"><a href="#关于嵌套滑动" class="headerlink" title="关于嵌套滑动"></a>关于嵌套滑动</h3><ol>
<li><code>Android</code>实现嵌套滑动只需要实现<code>NestedScrollingParent</code>和<code>NestedScrollingChild</code>这两个接口即可</li>
<li>在嵌套滑动过程中<code>子View(实现NestedScrollingChild接口)</code>会将自身的滑动情况通知<code>父View(实现NestedScrollingParent接口)，不一定是直接父View</code>，<code>父View</code>做完相关动作之后再通知<code>子View</code>，也就是<code>子View</code>其实是整个嵌套滑动的发起者</li>
<li><code>CoordinatorLayout</code>实现了<code>NestedScrollingParent</code>接口作为嵌套滑动的<code>父View</code>，因此如果要处理<code>Behavior</code>中对于滑动的相关处理，就需要有一个嵌套滑动的<code>子View</code>来触发这个<code>Behavior</code></li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol>
<li>上面分析UC首页时发现有个显示新闻的列表，因此我们可以用<code>RecyclerView</code>作为列表，因为<code>RecyclerView</code>实现了<code>NestedScrollingChild</code>接口，可以作为嵌套滑动的<code>子View</code></li>
<li>因为是多个视图的同时滑动处理，所以在实现<code>Behavior</code>时需要选择一个依赖，这里我选择前面说过的<code>UCViewHeader</code>作为其他视图<code>Behavior</code>的依赖</li>
<li>在看了<code>AppBarLayout</code>的源码之后，发现其子类<code>ScrollingViewBehavior</code>继承至<code>HeaderScrollingViewBehavior</code>,在查看源码之后发现如下几个类可以抽出来为我们所用<code>HeaderScrollingViewBehavior</code>,<code>ViewOffsetBehavior</code>,<code>ViewOffsetHelper</code><ol start="4">
<li><code>HeaderScrollingViewBehavior:</code>继承该类后，应用此<code>Behavior</code>的<code>View</code>布局时会自动在其依赖<code>View</code>的下方</li>
<li><code>ViewOffsetBehavior：</code>继承该类后，应用此<code>Behavior</code>的<code>View</code>在布局时会自动进行移动处理</li>
</ol>
</li>
</ol>
<h4 id="UCViewTitleBehavior实现"><a href="#UCViewTitleBehavior实现" class="headerlink" title="UCViewTitleBehavior实现"></a>UCViewTitleBehavior实现</h4><p><code>UCViewTitle</code>在初始时是不可见的，我采用设置其<code>TopMargin</code>让其不可见，然后在滑动过程中再慢慢滑动到可见，当前完全可见时滑动结束，此时其<code>translationY</code>为0，当滑动未开始时其<code>translationY</code>为<code>-height</code><br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UCViewTitleBehavior</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ViewOffsetBehavior</span>&lt;<span class="hljs-title">View</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onLayoutChild</span><span class="hljs-params">(CoordinatorLayout parent, View child, <span class="hljs-keyword">int</span> layoutDirection)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//因为UCViewTitle默认是在屏幕外不可见，所以在UCViewTitle进行布局的时候设置其topMargin让其不可见</span></span><br><span class="line">        ((CoordinatorLayout.LayoutParams) child.getLayoutParams()).topMargin = -child.getMeasuredHeight();</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onLayoutChild(parent, child, layoutDirection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">layoutDependsOn</span><span class="hljs-params">(CoordinatorLayout parent, View child, View dependency)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> isDependOn(dependency);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onDependentViewChanged</span><span class="hljs-params">(CoordinatorLayout parent, View child, View dependency)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> headerOffsetRange = -child.getMeasuredHeight();<span class="hljs-comment">//</span></span><br><span class="line">        <span class="hljs-keyword">int</span> titleOffsetRange = child.getMeasuredHeight();<span class="hljs-comment">//滑动总距离</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (dependency.getTranslationY() == headerOffsetRange) &#123;<span class="hljs-comment">//滑动初始位置</span></span><br><span class="line">            child.setTranslationY(titleOffsetRange);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dependency.getTranslationY() == <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//滑动结束位置</span></span><br><span class="line">            child.setTranslationY(<span class="hljs-number">0</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//滑动过程中</span></span><br><span class="line">            child.setTranslationY((<span class="hljs-keyword">int</span>) (dependency.getTranslationY() / (headerOffsetRange * <span class="hljs-number">1.0f</span>) * titleOffsetRange));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDependOn</span><span class="hljs-params">(View dependency)</span> </span>&#123;</span><br><span class="line">	    <span class="hljs-comment">//确定UCViewHeader作为依赖</span></span><br><span class="line">        <span class="hljs-keyword">return</span> dependency != <span class="hljs-keyword">null</span> &amp;&amp; dependency.getId() == R.id.news_view_header_layout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Material Design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Behavior </tag>
            
            <tag> Material Design </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Behavior实现滑动隐藏ToolBar与BottomNavigation]]></title>
      <url>http://ittiger.cn/Header-Footer-scroll-hide.html</url>
      <content type="html"><![CDATA[<h4 id="多说无益，先上效果图img-material-design"><a href="#多说无益，先上效果图img-material-design" class="headerlink" title="多说无益，先上效果图img\material-design"></a>多说无益，先上效果图img\material-design</h4><p><img src="/img/material-design/sticky_navigation.gif" width="360" height="640" alt="图片名称" align="center"></p>
<p>这个效果其实是和<code>SegmentFault</code>的首页效果是一样的。</p>
<p><a href="https://github.com/huyongli/StickyNavigation" target="_blank" rel="noopener">Demo github地址戳这里</a></p>
<h3 id="来由"><a href="#来由" class="headerlink" title="来由"></a>来由</h3><a id="more"></a>
<p>前几天有人问我这样的效果如何实现，有何思路，我的第一反应就是使用<code>Behavior</code>来实现这个效果，使用<code>Behavior</code>实现此效果比自定义View实现此效果绝对要简单很多，之后找时间了实现了这个效果。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用过<code>ToolBar + CoordinatorLayout + AppBarLayout</code>的人应该知道这三者组合使用再设置合适的参数(没用过的人赶紧去看看吧，或者看我的Demo也可以哟)，就可以实现滑动隐藏显示<code>ToolBar</code>，因此这部分的效果<code>Android</code>使用<code>Behavior</code>已经替我们实现好了，没必要再去费神了，而且它的效果也蛮不错。</p>
<p>接下来我们要考虑的就是如何实现在滑动的时候也隐藏底部的<code>BottomNavigation</code>，既然前面我已经说过用<code>Behavior</code>来实现此效果，因此我们需要自定义一个<code>Behavior</code>来实现滑动隐藏<code>BottomNavigation</code>。</p>
<h3 id="撸代码"><a href="#撸代码" class="headerlink" title="撸代码"></a>撸代码</h3><p>在前面一篇文章<a href="http://ittiger.cn/Custom-Behavior-to-fast-back.html">自定义Behavior实现快速返回效果</a>(没看过的请先看看)中我已经介绍了自定义<code>Behavior</code>的相关知识，这里就不再赘述了。</p>
<p>先来看看<code>ToolBar</code>滑动隐藏的代码<br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">android.support.design.widget.CoordinatorLayout</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">android.support.design.widget.AppBarLayout</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/appBarLayout"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:theme</span>=<span class="hljs-string">"@style/ThemeOverlay.AppCompat.Dark.ActionBar"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/toolBar"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"?attr/actionBarSize"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@android:color/holo_blue_dark"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">app:title</span>=<span class="hljs-string">"ToolBar Title"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">app:titleTextColor</span>=<span class="hljs-string">"@android:color/white"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">app:layout_scrollFlags</span>=<span class="hljs-string">"scroll|enterAlways"</span>/&gt;</span></span><br><span class="line">            </span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">android.support.design.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面属性设置中<code>app:layout_scrollFlags=&quot;scroll|enterAlways&quot;</code>这个是必须要有，否则话滑动的时候<code>ToolBar</code>是不会滑动的。</p>
<p>那滑动隐藏<code>BottomNavigation</code>的这个<code>Behavior</code>该如何实现呢？其实很简单，我们在滑动列表的时候可以看到当<code>ToolBar</code>往上滑的时候<code>BottomNavigation</code>会同时往下滑，因此这里我可以把<code>ToolBar</code>作为<code>BottomNavigation</code>的依赖，<code>ToolBar</code>往上滑动多少<code>BottomNavigation</code>就同时往下滑动多少(这里我实现时保证了两者高度一致)。</p>
<p>既然知道了依赖关系也知道了滑动方向和滑动距离，再实现<code>Behavior</code>就简单多了，代码如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BottomNavigationViewBehavior</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CoordinatorLayout</span>.<span class="hljs-title">Behavior</span>&lt;<span class="hljs-title">View</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BottomNavigationViewBehavior</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BottomNavigationViewBehavior</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">super</span>(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onLayoutChild</span><span class="hljs-params">(CoordinatorLayout parent, View child, <span class="hljs-keyword">int</span> layoutDirection)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ((CoordinatorLayout.LayoutParams) child.getLayoutParams()).topMargin = parent.getMeasuredHeight() - child.getMeasuredHeight();</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onLayoutChild(parent, child, layoutDirection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">layoutDependsOn</span><span class="hljs-params">(CoordinatorLayout parent, View child, View dependency)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-comment">//因为Behavior只对CoordinatorLayout的直接子View生效，因此将依赖关系转移到AppBarLayout</span></span><br><span class="line">        <span class="hljs-keyword">return</span> dependency <span class="hljs-keyword">instanceof</span> AppBarLayout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onDependentViewChanged</span><span class="hljs-params">(CoordinatorLayout parent, View child, View dependency)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-comment">//得到依赖View的滑动距离</span></span><br><span class="line">        <span class="hljs-keyword">int</span> top = ((AppBarLayout.Behavior)((CoordinatorLayout.LayoutParams)dependency.getLayoutParams()).getBehavior()).getTopAndBottomOffset();</span><br><span class="line">		<span class="hljs-comment">//因为BottomNavigation的滑动与ToolBar是反向的，所以取-top值</span></span><br><span class="line">        ViewCompat.setTranslationY(child, -top);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中获取依赖视图<code>AppBarLayout</code>的滑动距离时需要注意几点：</p>
<ol>
<li>通过<code>AppBarLayout.getTranslationY()</code>无法获取到正确的滑动距离</li>
<li>通过<code>AppBarLayout.getTop()</code>无法获取到正确的滑动距离</li>
<li>最后查看源码后发现通过<code>AppBarLayout.Behavior.getTopAndBottomOffset()</code>可以获得正确的滑动距离值</li>
</ol>
<p>现在<code>Behavior</code>实现了，我们再来看完整的布局文件<br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">android.support.design.widget.CoordinatorLayout</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">android.support.design.widget.AppBarLayout</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/appBarLayout"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:theme</span>=<span class="hljs-string">"@style/ThemeOverlay.AppCompat.Dark.ActionBar"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/toolBar"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"?attr/actionBarSize"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@android:color/holo_blue_dark"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">app:title</span>=<span class="hljs-string">"ToolBar Title"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">app:titleTextColor</span>=<span class="hljs-string">"@android:color/white"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">app:layout_scrollFlags</span>=<span class="hljs-string">"scroll|enterAlways"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">android.support.design.widget.TabLayout</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/tabLayout"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@android:color/holo_blue_light"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">app:tabTextColor</span>=<span class="hljs-string">"@android:color/white"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">app:tabGravity</span>=<span class="hljs-string">"center"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">app:tabIndicatorColor</span>=<span class="hljs-string">"@android:color/white"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">app:tabSelectedTextColor</span>=<span class="hljs-string">"@android:color/holo_red_dark"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">android.support.v4.view.ViewPager</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/viewpager"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@android:color/white"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">app:layout_behavior</span>=<span class="hljs-string">"@string/appbar_scrolling_view_behavior"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">android.support.design.widget.BottomNavigationView</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/bottomNavigationView"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"?attr/actionBarSize"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@android:color/holo_blue_dark"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">"bottom"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">app:menu</span>=<span class="hljs-string">"@menu/bottom_menus"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">app:layout_behavior</span>=<span class="hljs-string">"cn.ittiger.stickynavigation.behavior.BottomNavigationViewBehavior"</span></span></span><br><span class="line"><span class="hljs-tag">        /&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">android.support.design.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>对于布局中的<code>ToolBar</code>和<code>BottomNavigationView</code>也可以换成其他任意<code>View</code>来实现滑动隐藏效果。</p>
<p>Demo的完整代码在这 <a href="https://github.com/huyongli/StickyNavigation" target="_blank" rel="noopener">github地址</a></p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Material Design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Behavior </tag>
            
            <tag> Material Design </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自定义Behavior实现快速返回效果]]></title>
      <url>http://ittiger.cn/Custom-Behavior-to-fast-back.html</url>
      <content type="html"><![CDATA[<p>Behavior是Android Design包中出现的一个概念，Android Design包中很多控件的动画效果都是使用Behavior实现的，所以想要更好的实现Material Design风格的应用就有必要弄清楚Behavior。这篇文章从简单开始，介绍如何自定义Behavior以实现快速返回的效果。</p>
<p>还是先看下最终实现的效果<br><img src="/img/back-top-behavior.gif" width="360" height="640" alt="图片名称" align="center"></p>
<a id="more"></a>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>先看官方介绍<a href="https://developer.android.google.cn/reference/android/support/design/widget/CoordinatorLayout.Behavior.html" target="_blank" rel="noopener">https://developer.android.google.cn/reference/android/support/design/widget/CoordinatorLayout.Behavior.html</a></p>
<blockquote>
<blockquote>
<p>Interaction behavior plugin for child views of CoordinatorLayout.</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>A Behavior implements one or more interactions that a user can take on a child view. These interactions may include drags, swipes, flings, or any other gestures.</p>
</blockquote>
</blockquote>
<p>上面的介绍说Behavior是CoordinatorLayout子视图的一个交互插件，它可以为子视图实现一个或多个交互，这些交互包括拖拽，滑动或其他的手势操作。</p>
<p>通过上面的介绍我们知道Behavior是作用于CoordinatorLayout子视图的，而CoordinatorLayout我们可以把它看做一个FrameLayout。</p>
<p>根据我的理解来说Behavior其实就是一系列手势操作行为的回调，通过这些回调来处理CoordinatorLayout子视图的手势操作。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>用过Android Design库中AppBarLayout与NestedScrollView这两个类的同学应该知道，这两个类一起使用会产生很漂亮的滑动效果，这也是Android库中对Behavior的一个很典型的应用。而对于Behavior的使用，也可以参考这两个类的两种使用方式：</p>
<ol>
<li>为CoordinatorLayout的直接子View设置app:layout_behavior=“behavior完全类名”</li>
<li>为CoordinatorLayout的某个子View设置默认Behavior，设置方式是在该View的类声明上添加注解<a href="mailto:`@CoordinatorLayout.DefaultBehavior" target="_blank" rel="noopener">`@CoordinatorLayout.DefaultBehavior</a>(Behavior类.class)`</li>
</ol>
<h2 id="Behavior相关方法"><a href="#Behavior相关方法" class="headerlink" title="Behavior相关方法"></a>Behavior相关方法</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BackTopBehavior</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CoordinatorLayout</span>.<span class="hljs-title">Behavior</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyBehavior</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(context, attrs);</span><br><span class="line">        <span class="hljs-comment">//必须实现此构造方法，因为CoordinatorLayout中初始化Behavior时是通过反射调用此构造来进行初始化的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">layoutDependsOn</span><span class="hljs-params">(CoordinatorLayout parent, View child, View dependency)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.layoutDependsOn(parent, child, dependency);</span><br><span class="line">        <span class="hljs-comment">//判断视图child进行layout布局时是否依赖于某个特定的View dependency</span></span><br><span class="line">        <span class="hljs-comment">//child是指应用此Behavior的View，dependency是触发执行此Behavior的视图并与child进行相关交互，也就是上面所说的是child的依赖</span></span><br><span class="line">        <span class="hljs-comment">//此方法在CoordinatorLayout进行request layout时至少会调用一次</span></span><br><span class="line">        <span class="hljs-comment">//如果返回true，CoordinatorLayout会总是在依赖视图dependency layout完成之后对child视图进行layout布局</span></span><br><span class="line">        <span class="hljs-comment">//同时如果依赖视图dependency的layout或position发生变化，CoordinatorLayout会调用onDependentViewChanged</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onDependentViewChanged</span><span class="hljs-params">(CoordinatorLayout parent, View child, View dependency)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onDependentViewChanged(parent, child, dependency);</span><br><span class="line">        <span class="hljs-comment">//此方法的调用时机参考上面的方法layoutDependsOn的说明</span></span><br><span class="line">        <span class="hljs-comment">//当child的依赖视图dependency发生layout变化后，如果想对child布局(child's size or position)做出相应变化则返回true否则返回false，具体对child如何update则需要在onLayoutChild中进行实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDependentViewRemoved</span><span class="hljs-params">(CoordinatorLayout parent, View child, View dependency)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">super</span>.onDependentViewRemoved(parent, child, dependency);</span><br><span class="line">        <span class="hljs-comment">//当child的依赖视图dependency从其parent中remove掉后会调用此方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onMeasureChild</span><span class="hljs-params">(CoordinatorLayout parent, View child, <span class="hljs-keyword">int</span> parentWidthMeasureSpec, <span class="hljs-keyword">int</span> widthUsed, <span class="hljs-keyword">int</span> parentHeightMeasureSpec, <span class="hljs-keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onMeasureChild(parent, child, parentWidthMeasureSpec, widthUsed, parentHeightMeasureSpec, heightUsed);</span><br><span class="line">        <span class="hljs-comment">//当测量CoordinatorLayout的子视图child时调用此方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onLayoutChild</span><span class="hljs-params">(CoordinatorLayout parent, View child, <span class="hljs-keyword">int</span> layoutDirection)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onLayoutChild(parent, child, layoutDirection);</span><br><span class="line">        <span class="hljs-comment">//当对CoordinatorLayout的子视图child进行layout布局时会调用此方法</span></span><br><span class="line">        <span class="hljs-comment">//当child的依赖视图layout结束之后，会调用此方法对child进行layout布局</span></span><br><span class="line">        <span class="hljs-comment">//如果onDependentViewChanged中返回了true，则需要在此方法中对child视图进行update</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onStartNestedScroll</span><span class="hljs-params">(CoordinatorLayout coordinatorLayout, View child, View directTargetChild, View target, <span class="hljs-keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes);</span><br><span class="line">        <span class="hljs-comment">//滑动开始调用，返回true表示此Behavior接收此滑动，才会有后续的滑动处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStopNestedScroll</span><span class="hljs-params">(CoordinatorLayout coordinatorLayout, View child, View target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">super</span>.onStopNestedScroll(coordinatorLayout, child, target);</span><br><span class="line">        <span class="hljs-comment">//滑动结束调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNestedScroll</span><span class="hljs-params">(CoordinatorLayout coordinatorLayout, View child, View target, <span class="hljs-keyword">int</span> dxConsumed, <span class="hljs-keyword">int</span> dyConsumed, <span class="hljs-keyword">int</span> dxUnconsumed, <span class="hljs-keyword">int</span> dyUnconsumed)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">super</span>.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed);</span><br><span class="line">        <span class="hljs-comment">//滑动过程中调用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNestedPreScroll</span><span class="hljs-params">(CoordinatorLayout coordinatorLayout, View child, View target, <span class="hljs-keyword">int</span> dx, <span class="hljs-keyword">int</span> dy, <span class="hljs-keyword">int</span>[] consumed)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">super</span>.onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed);</span><br><span class="line">       <span class="hljs-comment">//滑动过程中，在child自身消费掉此次滑动的distance之前调用此方法</span></span><br><span class="line">       <span class="hljs-comment">//onNestedPreScroll is called each time the nested scroll is updated by the nested scrolling child</span></span><br><span class="line">       <span class="hljs-comment">// before the nested scrolling child has consumed the scroll distance itself</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onNestedFling</span><span class="hljs-params">(CoordinatorLayout coordinatorLayout, View child, View target, <span class="hljs-keyword">float</span> velocityX, <span class="hljs-keyword">float</span> velocityY, <span class="hljs-keyword">boolean</span> consumed)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onNestedFling(coordinatorLayout, child, target, velocityX, velocityY, consumed);</span><br><span class="line">        <span class="hljs-comment">//快速滑动时调用此方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是Behavior中比较常用比较重要的一些方法。</p>
<h2 id="自定义Behavior"><a href="#自定义Behavior" class="headerlink" title="自定义Behavior"></a>自定义Behavior</h2><p>我要实现的是在在列表上滑时，显示快速返回按钮，列表下滑时隐藏快速返回按钮，当快速返回按钮显示时，点击该按钮，列表会自动滑动到顶部。</p>
<p>快速返回按钮我用的是<code>Android Design</code>中的<code>FloatingActionButton</code>,其实在<code>FloatingActionButton</code>中设置了默认的<code>Behavior</code>，但是这个默认的<code>Behavior</code>是与<code>SnackBar</code>结合使用的，因此我可以直接继承<code>FloatingActionButton.Behavior</code>复写其中的相关方法实现我们所要的效果，这样可以减少很多工作</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BackTopBehavior</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FloatingActionButton</span>.<span class="hljs-title">Behavior</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">"BackTopBehavior"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BackTopBehavior</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onStartNestedScroll</span><span class="hljs-params">(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View directTargetChild, View target, <span class="hljs-keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL;<span class="hljs-comment">//垂直方向滑动</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNestedScroll</span><span class="hljs-params">(CoordinatorLayout coordinatorLayout, FloatingActionButton child, View target, <span class="hljs-keyword">int</span> dxConsumed, <span class="hljs-keyword">int</span> dyConsumed, <span class="hljs-keyword">int</span> dxUnconsumed, <span class="hljs-keyword">int</span> dyUnconsumed)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (dyConsumed &gt; <span class="hljs-number">0</span> &amp;&amp; dyUnconsumed == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            Log.d(TAG, <span class="hljs-string">"上滑中。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (dyConsumed == <span class="hljs-number">0</span> &amp;&amp; dyUnconsumed &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            Log.d(TAG, <span class="hljs-string">"到边界了还在上滑。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (dyConsumed &lt; <span class="hljs-number">0</span> &amp;&amp; dyUnconsumed == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            Log.d(TAG, <span class="hljs-string">"下滑中。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (dyConsumed == <span class="hljs-number">0</span> &amp;&amp; dyUnconsumed &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            Log.d(TAG, <span class="hljs-string">"到边界了，还在下滑。。。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span>((dyConsumed &gt; <span class="hljs-number">0</span> &amp;&amp; dyUnconsumed == <span class="hljs-number">0</span>) || (dyConsumed == <span class="hljs-number">0</span> &amp;&amp; dyUnconsumed &gt; <span class="hljs-number">0</span>) &amp;&amp; child.getVisibility() != View.VISIBLE) &#123;</span><br><span class="line">            child.show();<span class="hljs-comment">//上滑的时候显示按钮</span></span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((dyConsumed &lt; <span class="hljs-number">0</span> &amp;&amp; dyUnconsumed == <span class="hljs-number">0</span>) || (dyConsumed == <span class="hljs-number">0</span> &amp;&amp; dyUnconsumed &lt; <span class="hljs-number">0</span>) &amp;&amp; child.getVisibility() != View.GONE) &#123;</span><br><span class="line">            child.hide();<span class="hljs-comment">//下滑的时候因此按钮</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样实现起来是不是感觉很简单，如果不用<code>Behavior</code>的话，需要自己自定义View，并对滑动事件进行处理，实现起来肯定比<code>Behavior</code>方式要费劲。</p>
<p>剩下的布局和Activity代码如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BackTopBehaviorActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    CommonRecyclerView mRecyclerView;</span><br><span class="line">    LinearLayoutManager mLayoutManager;</span><br><span class="line">    FloatingActionButton mFloatingActionButton;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_backtop_behavior);</span><br><span class="line">        mFloatingActionButton = (FloatingActionButton) findViewById(R.id.floatingActionButton);</span><br><span class="line">        mFloatingActionButton.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;</span><br><span class="line">                mLayoutManager.smoothScrollToPosition(mRecyclerView, <span class="hljs-keyword">null</span> , <span class="hljs-number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        initRecyclerView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initRecyclerView</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        mRecyclerView = (CommonRecyclerView) findViewById(R.id.recyclerView);</span><br><span class="line">        mLayoutManager = <span class="hljs-keyword">new</span> LinearLayoutManager(<span class="hljs-keyword">this</span>);</span><br><span class="line">        mRecyclerView.setLayoutManager(mLayoutManager);</span><br><span class="line">        mRecyclerView.addItemDecoration(<span class="hljs-keyword">new</span> SpacesItemDecoration(<span class="hljs-number">5</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i ++) &#123;</span><br><span class="line">            data.add(<span class="hljs-string">"数据"</span> + (i + <span class="hljs-number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringListAdapter mAdapter = <span class="hljs-keyword">new</span> StringListAdapter(<span class="hljs-keyword">this</span>, data);</span><br><span class="line">        mRecyclerView.setAdapter(mAdapter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">android.support.design.widget.CoordinatorLayout</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">android.support.design.widget.AppBarLayout</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:theme</span>=<span class="hljs-string">"@style/ThemeOverlay.AppCompat.Dark.ActionBar"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">android.support.v7.widget.Toolbar</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/toolbar"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">app:title</span>=<span class="hljs-string">"@string/app_name"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"?attr/actionBarSize"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">app:titleTextColor</span>=<span class="hljs-string">"@android:color/white"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">android.support.design.widget.AppBarLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">cn.ittiger.demo.ui.CommonRecyclerView</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/recyclerView"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">app:layout_behavior</span>=<span class="hljs-string">"@string/appbar_scrolling_view_behavior"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">app:layout_collapseMode</span>=<span class="hljs-string">"pin"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">android.support.design.widget.FloatingActionButton</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/floatingActionButton"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">"bottom|end"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_margin</span>=<span class="hljs-string">"@dimen/d_15"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:src</span>=<span class="hljs-string">"@android:drawable/stat_sys_upload_done"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">app:layout_behavior</span>=<span class="hljs-string">"cn.ittiger.demo.behavior.BackTopBehavior"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">app:layout_scrollFlags</span>=<span class="hljs-string">"scroll|enterAlways|snap"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:visibility</span>=<span class="hljs-string">"gone"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">android.support.design.widget.CoordinatorLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="Demo的完整代码戳这里"><a href="#Demo的完整代码戳这里" class="headerlink" title="Demo的完整代码戳这里"></a>Demo的完整代码<a href="https://github.com/huyongli/AndroidDemo/blob/master/app/src/main/java/cn/ittiger/demo/behavior/BackTopBehaviorActivity.java" target="_blank" rel="noopener">戳这里</a></h4><hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Material Design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Behavior </tag>
            
            <tag> Material Design </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自定义实现微信通讯录效果View]]></title>
      <url>http://ittiger.cn/Imitate-WeiXin-contact-view.html</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用App过程中，经常会有使用到联系人或城市列表的场景，其实这两种效果是一样的，都是右边有个索引列表，点击索引列表可跳转到指定字母开头的联系人或城市上去，同时向上滑动过程中头部会有个显示当前联系人首字母的界面固定不动。下面我以微信通讯录的效果作为例子，介绍我是如何实现一个这样效果自定义View的思路和过程。</p>
<h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p>下面是我实现的最终效果图(GIF录制的不太好)，想看源代码的同学戳这里<a href="https://github.com/huyongli/IndexStickyView" target="_blank" rel="noopener">https://github.com/huyongli/IndexStickyView</a><br><img src="/img/indexStickyView_contact.gif" width="360" height="640" alt></p>
<a id="more"></a>
<h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>既然要高仿实现微信通讯录的效果，那我们来先看看微信通讯录的效果<br><img src="/img/WeiXin_Contact.jpg" width="360" height="640" alt></p>
<h3 id="微信通讯录效果分析"><a href="#微信通讯录效果分析" class="headerlink" title="微信通讯录效果分析"></a>微信通讯录效果分析</h3><p>通过对微信通讯的效果进行分析之后，得出如下几点：</p>
<ol>
<li>通讯录展示分为两部分：<ol start="2">
<li>主体：联系人列表</li>
<li>索引条：右边字母索引条</li>
</ol>
</li>
<li>主体联系人列表又分为三部分：<ol start="3">
<li>联系人姓名和头像展示</li>
<li>根据联系人姓名的首字母进行分组，每组开头都会显示组名称(首字母)，并按字母顺序排序</li>
<li>列表开头的四个菜单，可以看成是一个特殊组数据，但是无组名称展示</li>
</ol>
</li>
<li>索引条中的内容与联系人列表中的所有组字母一样，同时点击索引条中的字母会将列表定位到当前字母所代表的联系人组，因此索引条的每个字母会与该字母所代表联系人组的位置有个一一对应关系</li>
<li>点击索引条中的<code>↑</code>会定位到列表头部的四个菜单上，因此可以将<code>↑</code>与四个菜单作为一组对应关系，只是该菜单组无组名称</li>
<li>点击索引条的某个字母时，列表中间会有该字母的提示显示</li>
<li>列表向上滑动时当前组的组名称固定在列表头部显示不动，直到下一组组名称滑动到顶部时，原来固定不动的组名称视图开始往上滑出，下一组组名称顶替上去</li>
</ol>
<h3 id="实现思路分析"><a href="#实现思路分析" class="headerlink" title="实现思路分析"></a>实现思路分析</h3><ol>
<li>既然要展示联系人列表，所以我采用<code>RecyclerView</code></li>
<li>滑动过程中顶部会有个视图固定不动，而<code>RecyclerView</code>滑动时不可能有子视图固定不动，因此我采用一个独立的视图<code>View</code>来作为这个固定不动的顶部视图显示组名称，在滑动过程中控制该<code>View</code>的显示和隐藏及其内容的变化，显然这个时候就需要父视图将<code>RecyclerView</code>和这个头部视图<code>View</code>包装起来</li>
<li>索引条因为是一个字母索引列表，因此我采用自定义<code>View</code>来绘制这些字母，在绘制过程中每个字母在索引条中要水平居中，而当列表头部有固定显示某个组名称(字母)时，索引条中对应的字母会有一个红色的圆作为该字母的背景，同时字母在圆中居中显示</li>
<li>点击索引条的字母时，列表中间出现的字母提示也采用一个独立的<code>View</code>显示，并将该<code>View</code>放到与<code>RecyclerView</code>所处的同一父视图。</li>
<li>索引条中的每个字母都需要与列表中对应组所在的位置索引有个一一对应的关系</li>
<li>因为微信通讯录中顶部的四个菜单与其他联系人具有不同的行为和展示方式，因此最终实现的<code>View</code>需要支持自定义显示不同的头部视图及对应的索引字母</li>
</ol>
<h1 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h1><p>下面我介绍下我在实现过程中的一些要点</p>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="用户数据"><a href="#用户数据" class="headerlink" title="用户数据"></a>用户数据</h3><p>一般应用在实现过程中，拿到的只有具体的联系人数据，而没有联系人对应的首字母，如果说我们自定义的<code>View</code>需要开发者将联系人对应的首字母也传进来，那这个自定义<code>View</code>写的也太lower了，对开发者太不友好了。因此我们最终实现的<code>View</code>所需要的数据就是开发者能拿到的联系人数据即可，这样的话就需要我们在实现<code>View</code>的过程中将开发者传递过来的联系人数据进行处理，然后得到我们在<code>RecyclerView</code>中展示的实际数据(联系人+字母索引)。</p>
<p>既然要对联系人数据进行处理得到该联系人的首字母，所以我定义了一个实体接口，所有的联系人数据实体必须实现这个接口以便告知我们需要对那个数据字段进行处理得到其索引首字母，具体接口如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BaseEntity</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 要索引的字段数据信息，例如联系人中对姓名进行索引，则此处返回姓名字段值</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function">String <span class="hljs-title">getIndexField</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="展示数据"><a href="#展示数据" class="headerlink" title="展示数据"></a>展示数据</h3><p>列表在展示过程中有两种类型数据，一种是联系人数据，一种是联系人所在组的组名称(索引值)，所以最终在<code>RecyclerView</code>中进行展示时使用用户数据实体<code>BaseEntity</code>是无法达到这种展示效果的，因此我定义了一个<code>RecyclerView</code>实际展示数据的实体类，如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexStickyEntity</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 当前数据项的类型，自动转换赋值</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mItemType = ItemType.ITEM_TYPE_CONTENT;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 当前数据的索引值，自动转换赋值(索引条中显示的文字)</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String mIndexValue;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 索引视图显示的索引名称（组名称）</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String mIndexName;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 原始数据，用户实际展示的数据,用于视图的绑定</span></span><br><span class="line"><span class="hljs-comment">     * 当次值为null时，则表示此实体代表一个Index数据</span></span><br><span class="line"><span class="hljs-comment">     * T extends BaseEntity</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> T mOriginalData;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 当前数据项的拼音</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String mPinYin;</span><br><span class="line"></span><br><span class="line">	...  setter &amp; getter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItemType</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 列表中普通数据项类型，例如联系人列表中的：联系人信息项</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ITEM_TYPE_CONTENT = <span class="hljs-number">1000000</span>;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 列表中索引项类型，例如联系人列表中的：A,B,C...等索引数据</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ITEM_TYPE_INDEX = <span class="hljs-number">2000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 列表中增加头部索引数据(如自定义的常用联系人)</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ITEM_TYPE_INDEX_HEADER = <span class="hljs-number">3000000</span>;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 列表中增加底部索引数据</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ITEM_TYPE_INDEX_FOOTER = <span class="hljs-number">4000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="用户数据-–-gt-展示数据"><a href="#用户数据-–-gt-展示数据" class="headerlink" title="用户数据 –&gt;展示数据"></a>用户数据 –&gt;展示数据</h3><p>在拿到用户的联系人数据后，进行转换处理得到真实展示数据，实现如下，代码中注释比较清晰，就不一一解释其实现逻辑了：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConvertHelper</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 转换过程中，如果待索引字段信息为非字母串，则将其索引值设为：#</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String INDEX_SPECIAL = <span class="hljs-string">"#"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConvertResult</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line">	    <span class="hljs-comment">//转换后得到的实际展示数据列表，包括联系人数据+组名称数据(索引名称)</span></span><br><span class="line">        <span class="hljs-keyword">private</span> List&lt;IndexStickyEntity&lt;T&gt;&gt; mIndexStickyEntities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="hljs-comment">//索引条中展示的数据列表</span></span><br><span class="line">        <span class="hljs-keyword">private</span> List&lt;String&gt; mIndexValueList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="hljs-comment">//索引条中展示数据与对应组在列表中位置索引的一一映射</span></span><br><span class="line">        <span class="hljs-keyword">private</span> Map&lt;String, Integer&gt; mIndexValuePositionMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">public</span> List&lt;IndexStickyEntity&lt;T&gt;&gt; getIndexStickyEntities() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">return</span> mIndexStickyEntities;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">getIndexValueList</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">return</span> mIndexValueList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Integer&gt; <span class="hljs-title">getIndexValuePositionMap</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">return</span> mIndexValuePositionMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-comment">//拿到数据后调用此方法进行数据转换处理</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends BaseEntity&gt; <span class="hljs-function">ConvertResult&lt;T&gt; <span class="hljs-title">transfer</span><span class="hljs-params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConvertResult&lt;T&gt; convertResult = <span class="hljs-keyword">new</span> ConvertResult&lt;T&gt;();</span><br><span class="line">		<span class="hljs-comment">//使用TreeMap自动按照Key(字母索引值)进行排序</span></span><br><span class="line">        TreeMap&lt;String, List&lt;IndexStickyEntity&lt;T&gt;&gt;&gt; treeMap = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(ComparatorFactory.indexValueComparator());</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            IndexStickyEntity&lt;T&gt; entity = originalEntityToIndexEntity(list.get(i));</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span>(treeMap.containsKey(entity.getIndexValue())) &#123;<span class="hljs-comment">//Map中已存在此索引值</span></span><br><span class="line">                treeMap.get(entity.getIndexValue()).add(entity);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                List&lt;IndexStickyEntity&lt;T&gt;&gt; indexStickyEntities = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                indexStickyEntities.add(entity);</span><br><span class="line">                treeMap.put(entity.getIndexValue(), indexStickyEntities);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">for</span>(String indexValue : treeMap.keySet()) &#123;</span><br><span class="line">	        <span class="hljs-comment">//创建组名称展示数据实体</span></span><br><span class="line">            IndexStickyEntity&lt;T&gt; indexValueEntity = createIndexEntity(indexValue, indexValue);</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//将索引值添加到索引值列表中</span></span><br><span class="line">            convertResult.getIndexValueList().add(indexValue);</span><br><span class="line">            <span class="hljs-comment">//按顺序将索引实体添加到列表中</span></span><br><span class="line">            convertResult.getIndexStickyEntities().add(indexValueEntity);</span><br><span class="line">            <span class="hljs-comment">//将索引值与索引值在结果列表中的位置进行映射</span></span><br><span class="line">            convertResult.getIndexValuePositionMap().put(indexValue, convertResult.getIndexStickyEntities().size() - <span class="hljs-number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">//得到当前索引值下的索引数据实体</span></span><br><span class="line">            List&lt;IndexStickyEntity&lt;T&gt;&gt; indexStickyEntities = treeMap.get(indexValue);</span><br><span class="line">            <span class="hljs-comment">//对数据实体按自然进行排序</span></span><br><span class="line">            Collections.sort(indexStickyEntities, ComparatorFactory.&lt;T&gt;indexEntityComparator());</span><br><span class="line">            <span class="hljs-comment">//将排序后的实体列表按顺序加入到结果列表中</span></span><br><span class="line">            convertResult.getIndexStickyEntities().addAll(indexStickyEntities);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> convertResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 原始数据转换成展示的索引数据</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> originalEntity</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends BaseEntity&gt; <span class="hljs-function">IndexStickyEntity&lt;T&gt; <span class="hljs-title">originalEntityToIndexEntity</span><span class="hljs-params">(T originalEntity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        IndexStickyEntity&lt;T&gt; entity = <span class="hljs-keyword">new</span> IndexStickyEntity&lt;&gt;();</span><br><span class="line">        T item = originalEntity;</span><br><span class="line">        String indexFieldName = item.getIndexField();</span><br><span class="line">        String pinyin = PinYinHelper.getPingYin(indexFieldName);</span><br><span class="line">        String indexValue;</span><br><span class="line">        <span class="hljs-keyword">if</span>(PinYinHelper.isLetter(pinyin)) &#123;<span class="hljs-comment">//首字符是否为字母</span></span><br><span class="line">            indexValue = pinyin.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase();</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//非字母以#代替</span></span><br><span class="line">            indexValue = INDEX_SPECIAL;</span><br><span class="line">        &#125;</span><br><span class="line">        entity.setPinYin(pinyin);</span><br><span class="line">        entity.setOriginalData(item);</span><br><span class="line">        entity.setIndexValue(indexValue);</span><br><span class="line">        entity.setIndexName(indexValue);</span><br><span class="line">        <span class="hljs-keyword">return</span> entity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 根据索引值创建索引实体对象</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> indexValue</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends BaseEntity&gt; <span class="hljs-function">IndexStickyEntity&lt;T&gt; <span class="hljs-title">createIndexEntity</span><span class="hljs-params">(String indexValue, String indexName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//根据索引值创建索引实体对象</span></span><br><span class="line">        IndexStickyEntity&lt;T&gt; indexValueEntity = <span class="hljs-keyword">new</span> IndexStickyEntity&lt;&gt;();</span><br><span class="line">        indexValueEntity.setIndexValue(indexValue);</span><br><span class="line">        indexValueEntity.setPinYin(indexValue);</span><br><span class="line">        indexValueEntity.setIndexName(indexName);</span><br><span class="line">        indexValueEntity.setItemType(ItemType.ITEM_TYPE_INDEX);</span><br><span class="line">        <span class="hljs-keyword">return</span> indexValueEntity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="SideBar实现"><a href="#SideBar实现" class="headerlink" title="SideBar实现"></a>SideBar实现</h1><h3 id="SideBar绘制"><a href="#SideBar绘制" class="headerlink" title="SideBar绘制"></a>SideBar绘制</h3><ol>
<li>初始化<code>SideBar</code>相关绘制参数</li>
<li>根据索引列表计算<code>SideBar</code>的实际高度，并得到<code>SideBar</code>的最终高度</li>
<li>根据<code>SideBar</code>高度计算其每项的高度</li>
<li>绘制所有的索引值到视图上，并根据选中情况绘制当前选项的圆形背景</li>
</ol>
<p>关键代码如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthMeasureSpec, <span class="hljs-keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> height = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="hljs-keyword">if</span> (mValueList.size() &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">//计算SideBar的实际高度</span></span><br><span class="line">        mCalViewHeight = (<span class="hljs-keyword">int</span>) (((mValueList.size() - <span class="hljs-number">1</span>) * mTextPaint.getTextSize() + mFocusTextPaint.getTextSize()) + (mValueList.size() + <span class="hljs-number">1</span>) * mTextSpace);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">if</span> (mCalViewHeight &gt; height) &#123;<span class="hljs-comment">//实际高度超过可用高度</span></span><br><span class="line">        mCalViewHeight = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">super</span>.onMeasure(widthMeasureSpec, MeasureSpec.makeMeasureSpec(mCalViewHeight, MeasureSpec.EXACTLY));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">super</span>.onDraw(canvas);</span><br><span class="line">    <span class="hljs-keyword">if</span>(mValueList.size() == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//计算每项的高度</span></span><br><span class="line">    mItemHeight = ((<span class="hljs-keyword">float</span>) getHeight()) / mValueList.size();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">float</span> radius = Math.min(getWidth() / <span class="hljs-number">2</span>, mItemHeight / <span class="hljs-number">2</span>);<span class="hljs-comment">//选中状态时圆形背景半径</span></span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mValueList.size(); i++) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(mSelectPosition == i) &#123;</span><br><span class="line">	        <span class="hljs-comment">//计算文本垂直居中的基准线</span></span><br><span class="line">            <span class="hljs-keyword">float</span> baseline = mItemHeight / <span class="hljs-number">2</span> + (mFocusTextPaint.getFontMetrics().descent - mFocusTextPaint.getFontMetrics().ascent) / <span class="hljs-number">2</span> - mFocusTextPaint.getFontMetrics().descent;</span><br><span class="line">            canvas.drawCircle(getWidth() / <span class="hljs-number">2</span>, mItemHeight / <span class="hljs-number">2</span> + mItemHeight * i, radius, mFocusTextBgPaint);</span><br><span class="line">            canvas.drawText(mValueList.get(i), getWidth() / <span class="hljs-number">2</span>, baseline + mItemHeight * i, mFocusTextPaint);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">float</span> baseline = mItemHeight / <span class="hljs-number">2</span> + (mTextPaint.getFontMetrics().descent - mTextPaint.getFontMetrics().ascent) / <span class="hljs-number">2</span> - mTextPaint.getFontMetrics().descent;</span><br><span class="line">            canvas.drawText(mValueList.get(i), getWidth() / <span class="hljs-number">2</span>, baseline + mItemHeight * i, mTextPaint);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="点击SideBar选中"><a href="#点击SideBar选中" class="headerlink" title="点击SideBar选中"></a>点击SideBar选中</h3><p><code>SideBar</code>绘制成功后，在使用过程中还有一个重要的场景需要实现，那就是我们点击<code>SideBar</code>的时候要知道我们当前点击的是<code>SideBar</code>中的哪个选项，具体实现思路是这样的：根据当前触摸的y坐标(其实是相对于视图坐标系)和每个选项的高度计算当前触摸点在哪个选项内，具体实现代码如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouch</span><span class="hljs-params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="hljs-keyword">int</span> touchPosition = getPositionForPointY(event.getY());</span><br><span class="line">    <span class="hljs-keyword">if</span>(touchPosition &lt; <span class="hljs-number">0</span> || touchPosition &gt;= mValueList.size()) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span>(mOnSideBarTouchListener != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">	    <span class="hljs-comment">//此接口监听主要用于列表跳转到对应的组</span></span><br><span class="line">        mOnSideBarTouchListener.onSideBarTouch(v, event, touchPosition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="hljs-keyword">if</span>(touchPosition != mSelectPosition) &#123;</span><br><span class="line">                setSelectPosition(touchPosition);<span class="hljs-comment">//设置选中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 根据点击的y坐标计算得到当前选中的是哪个选项</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pointY</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>      没选中则返回-1</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPositionForPointY</span><span class="hljs-params">(<span class="hljs-keyword">float</span> pointY)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span>(mValueList.size() &lt;= <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//根据手按下的纵坐标与每个选项的高度计算当前所在项的索引</span></span><br><span class="line">    <span class="hljs-keyword">int</span> position = (<span class="hljs-keyword">int</span>) (pointY / mItemHeight);</span><br><span class="line">    <span class="hljs-keyword">if</span>(position &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        position = <span class="hljs-number">0</span>;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(position &gt; mValueList.size() - <span class="hljs-number">1</span>) &#123;</span><br><span class="line">        position = mValueList.size() - <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="点击SideBar某项时跳转列表到对应组"><a href="#点击SideBar某项时跳转列表到对应组" class="headerlink" title="点击SideBar某项时跳转列表到对应组"></a>点击SideBar某项时跳转列表到对应组</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSideBarTouch</span><span class="hljs-params">(View v, MotionEvent event, <span class="hljs-keyword">int</span> touchPosition)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="hljs-keyword">if</span>(touchPosition != mSideBar.getSelectPosition()) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(touchPosition == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    mLinearLayoutManager.scrollToPosition(<span class="hljs-number">0</span>);</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    <span class="hljs-keyword">int</span> recyclerViewPosition = getScrollPositionBySideBarSelectPosition(touchPosition);</span><br><span class="line">                    mLinearLayoutManager.scrollToPositionWithOffset(recyclerViewPosition, <span class="hljs-number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="固定头部视图处理"><a href="#固定头部视图处理" class="headerlink" title="固定头部视图处理"></a>固定头部视图处理</h1><h3 id="头部显示逻辑"><a href="#头部显示逻辑" class="headerlink" title="头部显示逻辑"></a>头部显示逻辑</h3><ol>
<li>因为固定不动的头部视图(暂且叫做<code>mStickyHeaderView</code>其视图实现与组名称视图完全一样)是在<code>RecyclerView</code>的上面，所以当其显示时会遮盖掉<code>RecyclerView</code>的第一个可见项。<font color="red">——这个点很重要</font></li>
<li>获取<code>RecyclerView</code>的第一个可见项的实体数据<code>IndexStickyEntity</code><ol start="3">
<li>如果当前数据的组名称为空，则不显示头部视图<code>mStickyHeaderView</code>，要注意的是前面我在转换数据的时候会给所有普通联系人实体对象都会设置组名称(如果存在)</li>
<li>如果当前数据的组名称不为空，则显示头部视图<code>mStickyHeaderView</code>并同时更新其显示内容</li>
</ol>
</li>
<li>滚动过程中获取<code>RecyclerView</code>列表中的第二个可见项的实体数据<code>IndexStickyEntity</code>，比如叫做：<code>secondVisibleEntity</code><ol start="4">
<li>如果<code>secondVisibleEntity.getItemType() == ItemType.ITEM_TYPE_INDEX</code>,即为组名称视图(索引视图)，此时说明第二组数据已经滚动上来了，需要将固定在头部的<code>mStickyHeaderView</code>视图随着滚动操作慢慢的滑出界面变成不可见，同时<code>secondVisibleEntity</code>则会慢慢滚动到<code>mStickyHeaderView</code>原来所在的位置，此时在界面上看着就像是第二组的组名称视图慢慢的替换了固定在顶部的<code>mStickyHeaderView</code></li>
<li>如果<code>secondVisibleEntity.getItemType() != ItemType.ITEM_TYPE_INDEX</code>则需要将<code>mStickyHeaderView</code>恢复到初始位置。因为当<code>secondVisibleEntity</code>滚动到<code>mStickyHeaderView</code>原来所在的位置后，此时第一个可见项变成了<code>secondVisibleEntity</code>，而此时的第二个可见项则变成了普通的联系人视图比如叫<code>mContactView</code>，而此时列表还会继续往上滚动，随着滚动<code>secondVisibleEntity</code>会慢慢的变成不可见，而<code>mStickyHeaderView</code>已经滑出界面不可见了，所以当<code>secondVisibleEntity.getItemType() != ItemType.ITEM_TYPE_INDEX</code>则需要将<code>mStickyHeaderView</code>恢复到初始位置显示新的组名称。</li>
</ol>
</li>
<li>列表滚动过程中还需要根据第一个可见项的索引值更新索引条<code>SideBar</code>的选中项</li>
</ol>
<h3 id="滚动时头部显示逻辑实现"><a href="#滚动时头部显示逻辑实现" class="headerlink" title="滚动时头部显示逻辑实现"></a>滚动时头部显示逻辑实现</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecyclerViewScrollListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">OnScrollListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onScrolled</span><span class="hljs-params">(RecyclerView recyclerView, <span class="hljs-keyword">int</span> dx, <span class="hljs-keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">super</span>.onScrolled(recyclerView, dx, dy);</span><br><span class="line">        <span class="hljs-keyword">int</span> firstVisiblePosition = mLinearLayoutManager.findFirstVisibleItemPosition();</span><br><span class="line">        <span class="hljs-keyword">if</span>(firstVisiblePosition &lt; <span class="hljs-number">0</span> || firstVisiblePosition &gt;= mAdapter.getItemCount()) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        IndexStickyEntity entity = mAdapter.getItem(firstVisiblePosition);</span><br><span class="line">        mSideBar.setSelectPosition(mSideBar.getPosition(entity.getIndexValue()));</span><br><span class="line">        <span class="hljs-keyword">if</span>(TextUtils.isEmpty(entity.getIndexName()) &amp;&amp; mStickyHeaderView.itemView.getVisibility() == VISIBLE) &#123;</span><br><span class="line">            <span class="hljs-comment">//如果当前第一个可见项的索引值为空，则当前项可能是普通视图，非索引视图，因此此时需要将mStickyHeaderView进行隐藏</span></span><br><span class="line">            mStickyIndexValue = <span class="hljs-keyword">null</span>;</span><br><span class="line">            mStickyHeaderView.itemView.setVisibility(INVISIBLE);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//第一个可见项为索引视图，则需要显示头部固定的索引提示视图</span></span><br><span class="line">            showStickyHeaderView(entity.getIndexName(), firstVisiblePosition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span>(firstVisiblePosition + <span class="hljs-number">1</span> &gt;= mAdapter.getItemCount()) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//获取第二个可见项实体对象</span></span><br><span class="line">        IndexStickyEntity secondVisibleEntity = mAdapter.getItem(firstVisiblePosition + <span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span>(secondVisibleEntity.getItemType() == ItemType.ITEM_TYPE_INDEX) &#123;</span><br><span class="line">            <span class="hljs-comment">//第二个可见项是索引值视图</span></span><br><span class="line">            View secondVisibleItemView = mLinearLayoutManager.findViewByPosition(firstVisiblePosition + <span class="hljs-number">1</span>);</span><br><span class="line">            <span class="hljs-keyword">if</span>(secondVisibleItemView.getTop() &lt;= mStickyHeaderView.itemView.getHeight() &amp;&amp; mStickyIndexValue != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                <span class="hljs-comment">//当secondVisibleItemView距顶部的距离 &lt;= mStickyHeaderView的高度时，mStickyHeaderView开始往上滑出</span></span><br><span class="line">                mStickyHeaderView.itemView.setTranslationY(secondVisibleItemView.getTop() - mStickyHeaderView.itemView.getHeight());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">//第二个可见项不是索引值视图</span></span><br><span class="line">            <span class="hljs-keyword">if</span>(mStickyHeaderView.itemView.getTranslationY() != <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//有偏移</span></span><br><span class="line">                mStickyHeaderView.itemView.setTranslationY(<span class="hljs-number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是我在模仿微信通讯录实现过程中的实现思路和关键点代码，具体实现细节和使用方式请看码：<a href="https://github.com/huyongli/IndexStickyView" target="_blank" rel="noopener">https://github.com/huyongli/IndexStickyView</a></p>
<p>喜欢的同学欢迎Star和fork</p>
<p>write by laohu<br>2016年12月30日</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android资源应用与适配标准]]></title>
      <url>http://ittiger.cn/Android-resources-adapter.html</url>
      <content type="html"><![CDATA[<p>本文内容来自<code>Android</code>官网对<code>Android</code>开发过程中资源使用、资源适配、资源选择原理的介绍和建议。</p>
<a id="more"></a>
<h2 id="Android资源类型"><a href="#Android资源类型" class="headerlink" title="Android资源类型"></a>Android资源类型</h2><h3 id="Android项目结构"><a href="#Android项目结构" class="headerlink" title="Android项目结构"></a>Android项目结构</h3><p>一个<code>Android</code>项目有多重资源类型，我们一般都会将各种资源放入项目 <code>res/</code>目录的特定子目录下。例如，以下是一个简单项目的文件层次结构：<br><img src="/img/android-resource-adapter/resource_type.png" alt></p>
<p>正如我们在此示例中所看到的那样，<code>res/</code>目录包含所有资源（在子目录下）：一个图像资源、两个布局资源、启动器图标的 <code>mipmap/</code> 目录以及一个字符串资源文件。资源目录名称非常重要，将在<code>表 1</code> 中进行介绍。</p>
<blockquote>
<p><strong>注</strong>：如需了解有关使用 <code>mipmap</code><br>文件夹的详细信息，请参阅<a href="https://developer.android.com/tools/projects/index.html#mipmap" target="_blank" rel="noopener">管理项目概览</a>。</p>
</blockquote>
<h3 id="Android支持的资源类型"><a href="#Android支持的资源类型" class="headerlink" title="Android支持的资源类型"></a>Android支持的资源类型</h3><p><strong>表 1.</strong> 项目 <code>res/</code> 目录内支持的资源目录。</p>
<table>
<thead>
<tr>
<th>目录</th>
<th style="text-align:left">资源类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>animator/</code></td>
<td style="text-align:left">用于定义<a href="https://developer.android.com/guide/topics/graphics/prop-animation.html" target="_blank" rel="noopener">属性动画</a>的 XML文件。</td>
</tr>
<tr>
<td><code>anim/</code></td>
<td style="text-align:left">定义<a href="https://developer.android.com/guide/topics/graphics/view-animation.html#tween-animation" target="_blank" rel="noopener">渐变动画</a>的 XML 文件。（属性动画也可以保存在此目录中，但是为了区分这两种类型，属性动画首选 <code>animator/</code> 目录。）</td>
</tr>
<tr>
<td><code>color/</code></td>
<td style="text-align:left">用于定义颜色状态列表的 XML 文件。请参阅<a href="https://developer.android.com/guide/topics/resources/color-list-resource.html" target="_blank" rel="noopener">颜色状态列表资源</a></td>
</tr>
<tr>
<td><code>drawable/</code></td>
<td style="text-align:left">位图文件（<code>.png</code>、<code>.9.png</code>、<code>.jpg</code>、<code>.gif</code>）或编译为以下可绘制对象资源子类型的 XML 文件：<br>位图文件<br>九宫格（9-Patch）<br>状态列表<br>形状<br>动画可绘制对象<br>其他可绘制对象<br>请参阅<a href="https://developer.android.com/guide/topics/resources/drawable-resource.html" target="_blank" rel="noopener">可绘制对象资源</a></td>
</tr>
<tr>
<td><code>mipmap/</code></td>
<td style="text-align:left">适用于不同启动器图标密度的可绘制对象文件。如需了解有关使用 <code>mipmap/</code> 文件夹管理启动器图标的详细信息，请参阅<a href="https://developer.android.com/tools/projects/index.html#mipmap" target="_blank" rel="noopener">管理项目概览</a>。</td>
</tr>
<tr>
<td><code>layout/</code></td>
<td style="text-align:left">用于定义用户界面布局的 XML 文件。请参阅<a href="https://developer.android.com/guide/topics/resources/layout-resource.html" target="_blank" rel="noopener">布局资源</a></td>
</tr>
<tr>
<td><code>menu/</code></td>
<td style="text-align:left">用于定义应用菜单（如选项菜单、上下文菜单或子菜单）的 XML文件。请参阅<a href="https://developer.android.com/guide/topics/resources/menu-resource.html" target="_blank" rel="noopener">菜单资源</a>。</td>
</tr>
<tr>
<td><code>raw/</code></td>
<td style="text-align:left"><p>要以原始形式保存的任意文件。要使用原始<a href="https://developer.android.com/reference/java/io/InputStream.html" target="_blank" rel="noopener">InputStream</a>打开这些资源，请使用资源 ID（即 <code>R.raw.&lt;em&gt;filename&lt;/em&gt;</code>）调用 <a href="https://developer.android.com/reference/android/content/res/Resources.html#openRawResource(int" target="_blank" rel="noopener">Resources.openRawResource()</a>)<br>但是，如需访问原始文件名和文件层次结构，则可以考虑将某些资源保存在<code>assets/</code> 目录下（而不是 <code>res/raw/</code>）。<code>assets/</code> 中的文件没有资源 ID，因此您只能使用 <a href="https://developer.android.com/reference/android/content/res/AssetManager.html" target="_blank" rel="noopener">AssetManager</a> 读取这些文件。</p></td>
</tr>
<tr>
<td><code>values/</code></td>
<td style="text-align:left">包含字符串、整型数和颜色等简单值的 XML 文件。<br>其他 <code>res/</code> 子目录中的 XML资源文件是根据XML文件名定义单个资源，而 <code>values/</code> 目录中的文件可描述多个资源。对于此目录中的文件，<code>&lt;resources&gt;</code> 元素的每个子元素均定义一个资源。例如，<code>&lt;string&gt;</code> 元素创建<code>R.string</code> 资源，<code>&lt;color&gt;</code> 元素创建 <code>R.color</code>资源。<br>由于每个资源均用其自己的 XML元素定义，因此您可以根据自己的需要命名文件，并将不同的资源类型放在一个文件中。但是，为了清晰起见，您可能需要将独特的资源类型放在不同的文件中。<br>例如，对于可在此目录中创建的资源，下面给出了相应的文件名约定：<br>arrays.xml，用于资源数组（<a href="https://developer.android.com/guide/topics/resources/more-resources.html#TypedArray" target="_blank" rel="noopener">类型化数组</a>）。<br>colors.xml：<a href="https://developer.android.com/guide/topics/resources/more-resources.html#Color" target="_blank" rel="noopener">颜色值</a>。<br>dimens.xml：<a href="https://developer.android.com/guide/topics/resources/more-resources.html#Dimension" target="_blank" rel="noopener">尺寸值</a>。<br>strings.xml：<a href="https://developer.android.com/guide/topics/resources/string-resource.html" target="_blank" rel="noopener">字符串值</a>。<br>styles.xml：<a href="https://developer.android.com/guide/topics/resources/style-resource.html" target="_blank" rel="noopener">样式</a><br>请参阅<a href="https://developer.android.com/guide/topics/resources/string-resource.html" target="_blank" rel="noopener">字符串资源</a>、<a href="https://developer.android.com/guide/topics/resources/style-resource.html" target="_blank" rel="noopener">样式资源</a>和<a href="https://developer.android.com/guide/topics/resources/more-resources.html" target="_blank" rel="noopener">更多资源类型</a>。</td>
</tr>
<tr>
<td><code>xml/</code></td>
<td style="text-align:left">可以在运行时通过调用 <a href="https://developer.android.com/reference/android/content/res/Resources.html#getXml(int" target="_blank" rel="noopener">Resources.getXML()</a>) 读取的任意 XML 文件。各种 XML配置文件（如<a href="https://developer.android.com/guide/topics/search/searchable-config.html" target="_blank" rel="noopener">可搜索配置</a>）都必须保存在此处。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意</strong>：切勿将资源文件直接保存在<code>res/</code>目录内，这会导致出现编译错误。</p>
</blockquote>
<p>如需了解有关某些资源类型的详细信息，请参阅<a href="https://developer.android.com/guide/topics/resources/available-resources.html" target="_blank" rel="noopener">资源类型</a>文档。</p>
<p>保存在<code>表 1</code>中定义的子目录下的资源是“默认”资源。即，这些资源定义应用的默认设计和内容。但是，采用<code>Android</code>技术的不同设备类型可能需要不同类型的资源。例如，如果设备的屏幕尺寸大于标准屏幕，则应提供不同的布局资源，以充分利用额外的屏幕空间。 或者，如果设备的语言设置不同，则应提供不同的字符串资源，以转换用户界面中的文本。 要为不同的设备配置提供这些不同资源，除了默认资源以外，您还需要提供备用资源。</p>
<h2 id="为项目提供备用资源"><a href="#为项目提供备用资源" class="headerlink" title="为项目提供备用资源"></a>为项目提供备用资源</h2><p><img src="/img/android-resource-adapter/resource_devices_diagram2.png" alt><br><strong>图 1</strong>. 两种不同的设备，均使用不同的布局资源。</p>
<p>几乎每个应用都应提供备用资源以支持特定的设备配置。 例如，对于不同的屏幕密度和语言，您应分别包括备用可绘制对象资源和备用字符串资源。 在运行时，<code>Android</code>会检测当前设备配置并为应用加载合适的资源。</p>
<p>为一组资源指定特定于配置的备用资源：</p>
<ol>
<li><p>在 <code>res/</code>中创建一个以<code>&lt;resources_name&gt;-&lt;config_qualifier&gt;</code>形式命名的新目录。</p>
<ul>
<li><code>&lt;resources_name&gt;</code> 是相应默认资源的目录名称（如<code>表 1</code>中所定义）。</li>
<li><code>&lt;qualifier&gt;</code> 是指定要使用这些资源的各个配置的名称（如<code>表 2</code>中所定义）。<br>您可以追加多个 <code>&lt;qualifier&gt;</code>。以短划线将其分隔。<blockquote>
<p><strong>注意</strong>：追加多个限定符时，必须按照<code>表 2</code> 中列出的相同顺序放置它们。如果限定符的顺序错误，则该资源将被忽略。  </p>
</blockquote>
</li>
</ul>
</li>
<li><p>将相应的备用资源保存在此新目录下。这些资源文件的名称必须与默认资源文件完全一样。</p>
</li>
</ol>
<p>例如，以下是一些默认资源和备用资源：<br><img src="/img/android-resource-adapter/resource_default.png" alt></p>
<p><code>hdpi</code>限定符表示该目录中的资源适用于屏幕密度较高的设备。其中每个可绘制对象目录中的图像已针对特定的屏幕密度调整大小，但是文件名完全相同。 这样一来，用于引用 <code>icon.png</code> 或<code>background.png</code> 图像的资源 ID 始终相同，但是 <code>Android</code> 会通过将设备配置信息与资源目录名称中的限定符进行比较，选择最符合当前设备的各个资源版本。</p>
<p>Android 支持若干配置限定符，您可以通过使用短划线分隔每个限定符，向一个目录名称添加多个限定符。表 2 按优先顺序列出了有效的配置限定符；如果对资源目录使用多个限定符，则必须按照表中列出的顺序将它们添加到目录名称。</p>
<h2 id="Android资源限定符"><a href="#Android资源限定符" class="headerlink" title="Android资源限定符"></a>Android资源限定符</h2><p><strong>表 2</strong>. 配置限定符名称。</p>
<table>
<thead>
<tr>
<th>配置</th>
<th style="text-align:center">限定符值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>MCC 和 MNC</td>
<td style="text-align:center">示例：<br> <code>mcc310</code><br> <code>&lt;nobr&gt;mcc310-mnc004&lt;/nobr&gt;</code><br> <code>mcc208-mnc00</code><br>等等</td>
<td style="text-align:left">移动国家代码 (MCC)，（可选）后跟设备 SIM卡中的移动网络代码 (MNC)。例如，<code>mcc310</code> 是指美国的任一运营商，<code>mcc310-mnc004</code> 是指美国的 Verizon公司，<code>mcc208-mnc00</code> 是指法国的 Orange公司。<br><br>如果设备使用无线电连接（GSM 手机），则 MCC 和 MNC 值来自 SIM卡。<br>也可以单独使用MCC（例如，将国家/地区特定的合法资源包括在应用中）。如果只需根据语言指定，则改用“语言和区域”<em></em>限定符（稍后进行介绍）。如果决定使用 MCC 和MNC 限定符，请谨慎执行此操作并测试限定符是否按预期工作。 <br><br>另请参阅配置字段 <a href="https://developer.android.com/reference/android/content/res/Configuration.html#mcc" target="_blank" rel="noopener">mcc</a>和 <a href="https://developer.android.com/reference/android/content/res/Configuration.html#mnc" target="_blank" rel="noopener">mnc</a>，这两个字段分别表示当前的移动国家代码和移动网络代码。</td>
</tr>
<tr>
<td>语言和区域</td>
<td style="text-align:center">示例：<br><code>en</code><br> <code>fr</code><br> <code>en-rUS</code><br> <code>fr-rFR</code><br> <code>fr-rCA</code><br>等等</td>
<td style="text-align:left">语言通过由两个字母组成的 <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php" target="_blank" rel="noopener">ISO639-1</a> 语言代码定义，可以选择后跟两个字母组成的<a href="http://www.iso.org/iso/en/prods-services/iso3166ma/02iso-3166-code-lists/list-en1.html" target="_blank" rel="noopener">ISO3166-1-alpha-2</a> 区域码（前带小写字母“<code>r</code>”）。<br><br>这些代码不区分大小写；<code>r</code>前缀用于区分区域码。<em></em>不能单独指定区域。<br><br>如果用户更改系统设置中的语言，它有可能在应用生命周期中发生改变。如需了解这会在运行期间给应用带来哪些影响，请参阅<a href="https://developer.android.com/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时变更</a>。<br><br>有关针对其他语言本地化应用的完整指南，请参阅<a href="https://developer.android.com/guide/topics/resources/localization.html" target="_blank" rel="noopener">本地化</a>。<br><br>另请参阅 <a href="https://developer.android.com/reference/android/content/res/Configuration.html#locale" target="_blank" rel="noopener">locale</a> 配置字段，该字段表示当前的语言区域。</td>
</tr>
<tr>
<td>布局方向</td>
<td style="text-align:center"><code>ldrtl</code><br> <code>ldltr</code><br></td>
<td style="text-align:left">应用的布局方向。<code>ldrtl</code> 是指“布局方向从右到左”。<code>ldltr</code>是指“布局方向从左到右”，这是默认的隐式值。<br><br>它适用于布局、图片或值等任何资源。<br><br>例如，若要针对阿拉伯语提供某种特定布局，并针对任何其他“从右到左”语言（如波斯语或希伯来语）提供某种通用布局，则可编码如下：<img src="/img/android-resource-adapter/resource_default2.png" alt><br><br><strong>注</strong>：要为应用启用从右到左的布局功能，必须将<a href="https://developer.android.com/guide/topics/manifest/application-element.html#supportsrtl" target="_blank" rel="noopener">supportsRtl</a> 设置为 <code>&quot;true&quot;</code>，并将 <a href="https://developer.android.com/guide/topics/manifest/uses-sdk-element.html#target" target="_blank" rel="noopener">targetSdkVersion</a> 设置为 17 或更高版本。<br><br><em>此项为 API 级别 17 中新增配置。</em></td>
</tr>
<tr>
<td>smallestWidth</td>
<td style="text-align:center"><code>sw&lt;N&gt;dp</code><br><br> 示例：<br><code>sw320dp</code><br><code>sw600dp</code><br><code>sw20dp</code><br>等等</td>
<td style="text-align:left">屏幕的基本尺寸，由可用屏幕区域的最小尺寸指定。具体来说，设备的 <code>smallestWidth</code>是屏幕可用高度和宽度的最小尺寸（您也可以将其视为屏幕的“最小可能宽度”）。无论屏幕的当前方向如何，您均可使用此限定符确保应用UI 的可用宽度至少为<code>&lt;N&gt;dp</code>。<br><br>例如，如果布局要求屏幕区域的最小尺寸始终至少为<code>600dp</code>，则可使用此限定符创建布局资源 <code>res/layout-sw600dp/</code>。仅当可用屏幕的最小尺寸至少为<code>600dp</code> 时，系统才会使用这些资源，而不考虑<code>600dp</code>所代表的边是用户所认为的高度还是宽度。<code>smallestWidth</code>是设备的固定屏幕尺寸特性；<strong>设备的 <code>smallestWidth</code>不会随屏幕方向的变化而改变</strong>。<br><br>设备的 <code>smallestWidth</code> 将屏幕装饰元素和系统 UI 考虑在内。例如，如果设备的屏幕上有一些永久性 UI 元素占据沿<code>smallestWidth</code>轴的空间，则系统会声明 <code>smallestWidth</code> 小于实际屏幕尺寸，因为这些屏幕像素不适用于您的 UI。<br><br>因此，使用的值应该是<em>布局所需要</em>的实际最小尺寸（通常，无论屏幕的当前方向如何，此值都是布局支持的“最小宽度”）。<br><br>以下是一些可用于普通屏幕尺寸的值：<br>320，适用于屏幕配置如下的设备：<br>240x320 ldpi（QVGA 手机）<br>320x480 mdpi（手机）<br>480x800 hdpi（高密度手机）<br>480，适用于 480x800 mdpi 之类的屏幕（平板电脑/手机）。<br>600，适用于 600x1024 mdpi 之类的屏幕（7 英寸平板电脑）。<br>720，适用于 720x1280 mdpi 之类的屏幕（10 英寸平板电脑）。<br><br>应用为多个资源目录提供不同的 smallestWidth 限定符值时，系统会使用最接近（但未超出）设备smallestWidth 的值。 <br><br><em>此项为 API 级别 13 中新增配置。</em> <br> <br>另请参阅 <a href="https://developer.android.com/guide/topics/manifest/supports-screens-element.html#requiresSmallest" target="_blank" rel="noopener">android:requiresSmallestWidthDp</a> 属性和 <a href="https://developer.android.com/reference/android/content/res/Configuration.html#smallestScreenWidthDp" target="_blank" rel="noopener">smallestScreenWidthDp</a> 配置字段，前者声明与应用兼容的最小 smallestWidth；后者存放设备的 smallestWidth 值。<br><br>如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅<a href="https://developer.android.com/guide/practices/screens_support.html" target="_blank" rel="noopener">支持多种屏幕</a>开发者指南。</td>
</tr>
<tr>
<td>可用宽度</td>
<td style="text-align:center"><code>w&lt;N&gt;dp</code><br><br>示例：<br><code>w720dp</code><br><code>w1024dp</code><br> 等等</td>
<td style="text-align:left">指定资源应该使用的最小可用屏幕宽度，以 <code>dp</code>为单位，由 <code>&amp;lt;N&amp;gt;</code> 值定义。在横向和纵向之间切换时，为了匹配当前实际宽度，此配置值也会随之发生变化。<br>br/&gt;应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕宽度的值。此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的左边缘或右边缘上有一些永久性 UI元素，考虑到这些 UI元素，它会使用小于实际屏幕尺寸的宽度值，这样会减少应用的可用空间。<br><br><em>此项为 API 级别 13 中新增配置。</em><br> <br>另请参阅<a href="https://developer.android.com/reference/android/content/res/Configuration.html#screenWidthDp" target="_blank" rel="noopener">screenWidthDp</a> 配置字段，该字段存放当前屏幕宽度。<br><br>如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅<a href="https://developer.android.com/guide/practices/screens_support.html" target="_blank" rel="noopener">支持多种屏幕</a>开发者指南。</td>
</tr>
<tr>
<td>可用高度</td>
<td style="text-align:center"><code>h&lt;N&gt;dp</code><br><br> 示例：<br><code>h720dp</code><br> <code>h1024dp</code><br>等等</td>
<td style="text-align:left">指定资源应该使用的最小可用屏幕高度，以“dp”为单位，由 <code>&lt;N&gt;</code> 值定义。在横向和纵向之间切换时，为了匹配当前实际高度，此配置值也会随之发生变化。<br><br>应用为多个资源目录提供不同的此配置值时，系统会使用最接近（但未超出）设备当前屏幕高度的值。此处的值考虑到了屏幕装饰元素，因此如果设备显示屏的上边缘或下边缘有一些永久性 UI元素，考虑到这些 UI 元素，同时为减少应用的可用空间，它会使用小于实际屏幕尺寸的高度值。非固定的屏幕装饰元素（例如，全屏时可隐藏的手机状态栏）并不<em></em>在考虑范围内，标题栏或操作栏等窗口装饰也不在考虑范围内，因此应用必须准备好处理稍小于其所指定值的空间。<br><br><em>此项为 API 级别 13 中新增配置。</em><br><br>另请参阅<a href="https://developer.android.com/reference/android/content/res/Configuration.html#screenHeightDp" target="_blank" rel="noopener">screenHeightDp</a> 配置字段，该字段存放当前屏幕宽度。<br><br>如需了解有关设计不同屏幕和使用此限定符的详细信息，请参阅<a href="https://developer.android.com/guide/practices/screens_support.html" target="_blank" rel="noopener">支持多种屏幕</a>开发者指南。</td>
</tr>
<tr>
<td>屏幕尺寸</td>
<td style="text-align:center"><code>small</code><br><code>normal</code><br> <code>large</code><br> <code>xlarge</code></td>
<td style="text-align:left"><code>small</code>：尺寸类似于低密度QVGA 屏幕的屏幕。小屏幕的最小布局尺寸约为320x426 dp 单位。例如，QVGA 低密度屏幕和WVGA高密度屏幕。<br><br><code>normal</code>：尺寸类似于中等密度HVGA 屏幕的屏幕。标准屏幕的最小布局尺寸约为320x470 dp 单位。例如，WQVGA低密度屏幕、HVGA 中等密度屏幕、WVGA高密度屏幕。<br><br><code>large</code>：尺寸类似于中等密度WVGA 屏幕的屏幕。大屏幕的最小布局尺寸约为 480x640 dp 单位。 例如，VGA 和 WVGA 中等密度屏幕。<br><br><code>xlarge</code>：明显大于传统中等密度HVGA 屏幕的屏幕。超大屏幕的最小布局尺寸约为720x960 dp 单位。在大多数情况下，屏幕超大的设备体积过大，不能放进口袋，最常见的是平板式设备。<em>API 级别 9 中的新增配置。</em><br><br><strong>注：使用尺寸限定符并不表示资源仅<em></em>适用于该尺寸的屏幕。如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中最匹配的资源。</strong><br><br><strong>注意：如果所有资源均使用大于<em></em>当前屏幕的尺寸限定符，则系统<strong>不</strong>会使用这些资源，并且应用在运行时将会崩溃（例如，如果所有布局资源均用 <code>xlarge</code> 限定符标记，但设备是标准尺寸的屏幕）。</strong><br><br><em>此项为 API 级别 4 中新增配置。</em><br><br>如需了解详细信息，请参阅<a href="https://developer.android.com/guide/practices/screens_support.html" target="_blank" rel="noopener">支持多种屏幕</a>。<br><br>另请参阅 <a href="https://developer.android.com/reference/android/content/res/Configuration.html#screenLayout" target="_blank" rel="noopener">screenLayout</a> 配置字段，该字段表示屏幕是小尺寸、标准尺寸还是大尺寸。</td>
</tr>
<tr>
<td>屏幕纵横比</td>
<td style="text-align:center"><code>long</code><br><code>notlong</code></td>
<td style="text-align:left"><code>long</code>：宽屏，如 WQVGA、WVGA、FWVGA<br><code>notlong</code>：非宽屏，如 QVGA、HVGA 和 VGA<br><br><em>此项为 API 级别 4 中新增配置。</em><br><br>它完全基于屏幕的纵横比（宽屏较宽），而与屏幕方向无关。<br><br>另请参阅 <a href="https://developer.android.com/reference/android/content/res/Configuration.html#screenLayout" target="_blank" rel="noopener">screenLayout</a> 配置字段，该字段指示屏幕是否为宽屏。</td>
</tr>
<tr>
<td>圆形屏幕</td>
<td style="text-align:center"><code>round</code><br><code>notround</code></td>
<td style="text-align:left"><code>round</code>：圆形屏幕，例如圆形可穿戴式设备<br><code>notround</code>：方形屏幕，例如手机或平板电脑<br><br><em>此项为 API 级别 23 中新增配置。</em><br> <br>另请参阅 <a href="https://developer.android.com/reference/android/content/res/Configuration.html#isScreenRound(" target="_blank" rel="noopener">isScreenRound()</a>) 配置方法，其指示屏幕是否为宽屏。</td>
</tr>
<tr>
<td>屏幕方向</td>
<td style="text-align:center"><code>port</code><br><code>land</code></td>
<td style="text-align:left"><code>port</code>：设备处于纵向（垂直）<br><code>land</code>：设备处于横向（水平）<br><br>如果用户旋转屏幕，它有可能在应用生命周期中发生改变。如需了解这会在运行期间给应用带来哪些影响，请参阅<a href="https://developer.android.com/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时变更</a>。<br><br>另请参阅 <a href="https://developer.android.com/reference/android/content/res/Configuration.html#orientation" target="_blank" rel="noopener">orientation</a> 配置字段，该字段指示当前的设备方向。</td>
</tr>
<tr>
<td>UI 模式</td>
<td style="text-align:center"><code>car</code><br> <code>desk</code><br> <code>television&lt;br/&gt;</code>appliance<code></code>watch`</td>
<td style="text-align:left"><code>car</code>：设备正在车载手机座上显示<br><code>desk</code>：设备正在桌面手机座上显示<br><code>television</code>：设备正在电视上显示，为用户提供“十英尺”体验，其UI 位于远离用户的大屏幕上，主要面向方向键或其他非指针式交互<br><code>appliance</code>：设备用作不带显示屏的装置<br><code>watch</code>：设备配有显示屏，戴在手腕上<br> <br><em>此项为 API 级别 8 中新增配置，API 13 中新增电视配置，API 20 中新增手表配置。</em><br> <br>如需了解应用在设备插入手机座或从中移除时的响应方式，请阅读<a href="https://developer.android.com/training/monitoring-device-state/docking-monitoring.html" target="_blank" rel="noopener">确定并监控插接状态和类型</a>。<br><br>如果用户将设备放入手机座中，它有可能在应用生命周期中发生改变。可以使用 <a href="https://developer.android.com/reference/android/app/UiModeManager.html&quot;&gt;UiModeManager" target="_blank" rel="noopener"></a> 启用或禁用其中某些模式。如需了解这会在运行期间给应用带来哪些影响，请参阅<a href="https://developer.android.com/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时变更</a>。</td>
</tr>
<tr>
<td>夜间模式</td>
<td style="text-align:center"><code>night</code><br> <code>notnight</code></td>
<td style="text-align:left"><code>night</code>：夜间<br><code>notnight</code>：白天<br> <br><em>此项为 API 级别 8 中新增配置。</em><br><br>如果夜间模式停留在自动模式（默认），它有可能在应用生命周期中发生改变。在这种情况下，该模式会根据当天的时间进行调整。可以使用<a href="https://developer.android.com/reference/android/app/UiModeManager.html" target="_blank" rel="noopener">UiModeManager</a> 启用或禁用此模式。如需了解这会在运行期间给应用带来哪些影响，请参阅<a href="https://developer.android.com/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时变更</a>。</td>
</tr>
<tr>
<td>屏幕像素密度 (dpi)</td>
<td style="text-align:center"><code>ldpi</code><br><code>mdpi</code><br><code>hdpi</code><br><code>xhdpi</code><br><code>xxhdpi</code><br><code>xxxhdpi</code><br> <code>nodpi</code><br> <code>tvdpi</code><br><code>anydpi</code></td>
<td style="text-align:left"><code>ldpi</code>：低密度屏幕；约为120dpi。<br><code>mdpi</code>：中等密度（传统 HVGA）屏幕；约为160dpi。<br><code>hdpi</code>：高密度屏幕；约为 240dpi。<br><code>xhdpi</code>：超高密度屏幕；约为 320dpi。<em>此项为 API级别 8 中新增配置</em><br><code>xxhdpi</code>：超超高密度屏幕；约为 480dpi。<em>此项为 API级别 16 中新增配置</em><br><code>xxxhdpi</code>：超超超高密度屏幕使用（仅限启动器图标，请参阅“支持多种屏幕”中的<a href="https://developer.android.com/guide/practices/screens_support.html#xxxhdpi-note" target="_blank" rel="noopener">注释</a>）；约为640dpi。<em>此项为 API级别 18 中新增配置</em><br><code>nodpi</code>：它可用于您不希望缩放以匹配设备密度的位图资源。<br><code>tvdpi</code>：密度介于 mdpi 和 hdpi 之间的屏幕；约为 213dpi。它并不是“主要”密度组，主要用于电视，而大多数应用都不需要它。对于大多数应用而言，提供 mdpi 和hdpi资源便已足够，系统将根据需要对其进行缩放。<em>此项为 API 级别 13 中新增配置</em><br><code>anydpi</code>：此限定符适合所有屏幕密度，其优先级高于其他限定符。这对于<a href="https://developer.android.com/training/material/drawables.html#VectorDrawables" target="_blank" rel="noopener">矢量可绘制对象</a>很有用。<em>此项为 API 级别 21 中新增配置</em> <br><br>六个主要密度之间的缩放比为 3:4:6:8:12:16（忽略tvdpi 密度）。因此，9x9 (ldpi) 位图相当于 12x12 (mdpi)、18x18 (hdpi)、24x24 (xhdpi) 位图，依此类推。 <br><br>如果您认为图像资源在电视或其他某些设备上呈现的效果不够好，而想尝试使用 tvdpi 资源，则缩放比例为1.33*mdpi。例如，mdpi屏幕的 100px x 100px 图像应该相当于 tvdpi 的133px x 133px。 <br> <br><strong>注：使用密度限定符并不表示资源仅适用于该密度的屏幕。如果没有为备用资源提供最符合当前设备配置的限定符，则系统可能使用其中<a href>#BestMatch”&gt;最匹配</a>的资源。</strong><br><br>如需了解有关如何处理不同屏幕密度以及 Android 如何缩放位图以适应当前密度的详细信息，请参阅<a href="https://developer.android.com/guide/practices/screens_support.html" target="_blank" rel="noopener">支持多种屏幕</a>。</td>
</tr>
<tr>
<td>触摸屏类型</td>
<td style="text-align:center"><code>notouch</code><br><code>finger</code></td>
<td style="text-align:left"><code>notouch</code>：设备没有触摸屏。<br><code>finger</code>：设备有一个专供用户通过手指直接与其交互的触摸屏。<br> <br>另请参阅 <a href="https://developer.android.com/reference/android/content/res/Configuration.html#touchscreen" target="_blank" rel="noopener">touchscreen</a> 配置字段，该字段指示设备上的触摸屏类型。</td>
</tr>
<tr>
<td>键盘可用性</td>
<td style="text-align:center"><code>keysexposed</code><br> <code>keyshidden</code><br> <code>keyssoft</code></td>
<td style="text-align:left"><code>keysexposed</code>：设备具有可用的键盘。如果设备启用了软键盘（不无可能），那么即使硬键盘没有展示给用户，哪怕设备没有硬键盘，也可以使用此限定符。如果没有提供或已经禁用软键盘，则只有在显示硬键盘时才会使用此限定符。<br><code>keyshidden</code>：设备具有可用的硬键盘，但它处于隐藏状态，且设备没有启用软键盘。<br><code>keyssoft</code>：设备已经启用软键盘（无论是否可见）。<br><br>如果提供了 <code>keysexposed</code> 资源，但未提供 <code>keyssoft</code>资源，那么只要系统已经启用软键盘，就会使用<code>keysexposed</code> 资源，而不考虑键盘是否可见。<br><br>如果用户打开硬键盘，它有可能在应用生命周期中发生改变。如需了解这会在运行期间给应用带来哪些影响，请参阅<a href="https://developer.android.com/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时变更</a>。<br><br>另请参阅配置字段 <a href="https://developer.android.com/reference/android/content/res/Configuration.html#hardKeyboardHidden" target="_blank" rel="noopener">hardKeyboardHidden</a>和<a href="https://developer.android.com/reference/android/content/res/Configuration.html#keyboardHidden" target="_blank" rel="noopener">keyboardHidden</a>，这两个字段分别指示硬键盘的可见性和任何一种键盘（包括软键盘）的可见性。</td>
</tr>
<tr>
<td>主要文本输入法</td>
<td style="text-align:center"><code>nokeys</code><br><code>qwerty</code><br> <code>12key</code></td>
<td style="text-align:left"><code>nokeys</code>：设备没有用于文本输入的硬按键。<br><code>qwerty</code>：设备具有标准硬键盘（无论是否对用户可见）。<br><code>12key</code>：设备具有 12 键硬键盘（无论是否对用户可见）。<br><br>另请参阅 <a href="https://developer.android.com/reference/android/content/res/Configuration.html#keyboard" target="_blank" rel="noopener">keyboard</a> 配置字段，该字段指示可用的主要文本输入法。</td>
</tr>
<tr>
<td>导航键可用性</td>
<td style="text-align:center"><code>navexposed</code><br> <code>navhidden</code></td>
<td style="text-align:left"><code>navexposed</code>：导航键可供用户使用。<br><code>navhidden</code>：导航键不可用（例如，位于密封盖子后面）。<br> <br>如果用户显示导航键，它有可能在应用生命周期中发生改变。如需了解这会在运行期间给应用带来哪些影响，请参阅<a href="https://developer.android.com/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时变更</a>。<br><br>另请参阅<a href="https://developer.android.com/reference/android/content/res/Configuration.html#navigationHidden" target="_blank" rel="noopener">navigationHidden</a> 配置字段，该字段指示导航键是否处于隐藏状态。</td>
</tr>
<tr>
<td>主要非触摸导航方法</td>
<td style="text-align:center"><code>nonav</code><br><code>dpad</code><br> <code>trackball</code><br> <code>wheel</code></td>
<td style="text-align:left"><code>nonav</code>：除了使用触摸屏以外，设备没有其他导航设施。<br><code>dpad</code>：设备具有用于导航的方向键。<br><code>trackball</code>：设备具有用于导航的轨迹球。<br><code>wheel</code>：设备具有用于导航的方向盘（不常见）。<br><br>另请参阅 <a href="https://developer.android.com/reference/android/content/res/Configuration.html#navigation" target="_blank" rel="noopener">navigation</a>配置字段，该字段指示可用的导航方法类型。</td>
</tr>
<tr>
<td>平台版本（API 级别）</td>
<td style="text-align:center">示例：<br><code>v3</code><br><code>v4</code><br><code>v7</code><br>等等</td>
<td style="text-align:left">设备支持的 API 级别。例如，<code>v1</code> 对应于 API 级别1（带有 Android 1.0 或更高版本系统的设备），<code>v4</code> 对应于 API 级别 4（带有 Android1.6 或更高版本系统的设备）。如需了解有关这些值的详细信息，请参阅<a href="https://developer.android.com/guide/topics/manifest/uses-sdk-element.html#ApiLevels" target="_blank" rel="noopener">Android API 级别</a>文档。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注</strong>：有些配置限定符是从 <code>Android 1.0</code> 才开始添加，因此并非所有版本的<code>Android</code>系统都支持所有限定符。使用新限定符会隐式添加平台版本限定符，因此较旧版本系统的设备必然会忽略它。 例如，使用 <code>w600dp</code> 限定符会自动包括 v13 限定符，因为可用宽度限定符是 API 级别 13 中的新增配置。为了避免出现任何问题，请始终包含一组默认资源（一组“不带限定符”的资源）。 如需了解详细信息，请参阅利用资源提供最佳设备兼容性部分</p>
</blockquote>
<h2 id="限定符命名规则"><a href="#限定符命名规则" class="headerlink" title="限定符命名规则"></a>限定符命名规则</h2><p>以下是一些关于使用配置限定符名称的规则：</p>
<ul>
<li>您可以为单组资源指定多个限定符，并使用短划线分隔。例如，<code>drawable-en-rUS-land</code> 适用于横排美国英语设备。</li>
<li>这些限定符必须遵循表 2 中列出的顺序。例如：<ul>
<li>错误：<code>drawable-hdpi-port/</code></li>
<li>正确：<code>drawable-port-hdpi/</code></li>
</ul>
</li>
<li>不能嵌套备用资源目录。例如，您不能拥有 <code>res/drawable/drawable-en/</code>。</li>
<li>值不区分大小写。在处理之前，资源编译器会将目录名称转换为小写，以避免不区分大小写的文件系统出现问题。 名称中使用的任何大写字母只是为了便于认读。</li>
<li>对于每种限定符类型，仅支持一个值。例如，若要对西班牙语和法语使用相同的可绘制对象文件，则您肯定不能拥有名为<code>drawable-rES-rFR/</code> 的目录，而是需要两个包含相应文件的资源目录，如 <code>drawable-rES/</code> 和 <code>drawable-rFR/</code>。然而，实际上您无需将相同的文件都复制到这两个位置。相反，您可以创建指向资源的别名。 请参阅下面的<strong><code>创建别名资源</code></strong>。</li>
</ul>
<p>将备用资源保存到以这些限定符命名的目录中之后，Android 会根据当前设备配置在应用中自动应用这些资源。 每次请求资源时，Android 都会检查备用资源目录是否包含所请求的资源文件，然后找到最匹配资源（下文进行介绍）。 如果没有与特定设备配置匹配的备用资源，则 Android 会使用相应的默认资源（一组用于不含配置限定符的特定资源类型的资源）</p>
<h2 id="创建别名资源"><a href="#创建别名资源" class="headerlink" title="创建别名资源"></a>创建别名资源</h2><p>如果您想将某一资源用于多种设备配置（但是不想作为默认资源提供），则无需将同一资源放入多个备用资源目录中。 相反，您可以（在某些情况下）创建备用资源，充当保存在默认资源目录下的资源的别名。</p>
<blockquote>
<p><strong> 注</strong>：并非所有资源都会提供相应机制让您创建指向其他资源的别名。 特别是，xml/ 目录中的动画资源、菜单资源、原始资源以及其他未指定资源均不提供此功能。</p>
</blockquote>
<p>例如，假设您有一个应用图标 <code>icon.png</code>，并且需要不同语言区域的独特版本。 但是，加拿大英语和加拿大法语这两种语言区域需要使用同一版本。 您可能会认为需要将相同的图像复制到加拿大英语和加拿大法语对应的资源目录中，但事实并非如此。 相反，您可以将用于二者的图像另存为<code>icon_ca.png</code>（除 <code>icon.png</code> 以外的任何名称），并将其放入默认<code>res/drawable/</code>目录中。然后，在<code>res/drawable-en-rCA/</code> 和 <code>res/drawable-fr-rCA/</code> 中创建<code>icon.xml</code>文件，使用 <code>&lt;bitmap&gt;</code> 元素引用 <code>icon_ca.png</code>资源。这样，您只需存储 PNG 文件的一个版本和两个指向该版本的小型 XML 文件。（XML 文件示例如下。）</p>
<h3 id="可绘制对象"><a href="#可绘制对象" class="headerlink" title="可绘制对象"></a>可绘制对象</h3><p>要创建指向现有可绘制对象的别名，请使用<code>&lt;bitmap&gt;</code>元素。例如：<br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">bitmap</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:src</span>=<span class="hljs-string">"@drawable/icon_ca"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果将此文件另存为<code>icon.xml</code>（例如，在备用资源目录中，另存为<code>res/drawable-en-rCA/</code>），则会编译到可作为 <code>R.drawable.icon</code> 引用的资源中，但实际上它是 <code>R.drawable.icon_ca</code>资源（保存在<code>res/drawable/</code>中）的别名。</p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>要创建指向现有布局的别名，请使用包装在<code>&lt;merge&gt;</code>中的<code>&lt;include&gt;</code>元素。例如：<br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">merge</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">"@layout/main_ltr"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">merge</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果将此文件另存为 <code>main.xml</code>，则会编译到可作为 <code>R.layout.main</code> 引用的资源中，但实际上它是 <code>R.layout.main_ltr</code> 资源的别名。</p>
<h3 id="字符串和其他简单值"><a href="#字符串和其他简单值" class="headerlink" title="字符串和其他简单值"></a>字符串和其他简单值</h3><p>要创建指向现有字符串的别名，只需将所需字符串的资源 ID 用作新字符串的值即可。例如：<br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hello"</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hi"</span>&gt;</span>@string/hello<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>R.string.hi</code>资源现在是 <code>R.string.hello</code>的别名。</p>
<p>其他简单值的原理相同。 例如，颜色：<br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"red"</span>&gt;</span>#f00<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"highlight"</span>&gt;</span>@color/red<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="利用资源提供最佳设备兼容性"><a href="#利用资源提供最佳设备兼容性" class="headerlink" title="利用资源提供最佳设备兼容性"></a>利用资源提供最佳设备兼容性</h2><p>要使应用支持多种设备配置，则务必为应用使用的每种资源类型提供默认资源，这一点非常重要。</p>
<p>例如，如果应用支持多种语言，请始终包含不带语言和区域限定符的 values/ 目录（用于保存字符串）。相反，如果您将所有字符串放入带有语言和区域限定符的目录中，则在语言设置不支持您的字符串的设备上运行应用时，应用将会崩溃。 但是，只要提供默认 values/ 资源，应用就会正常运行（即使用户不理解该语言，这也总比崩溃要好）。</p>
<p>同样，如果您根据屏幕方向提供不同的布局资源，则应选择一个方向作为默认方向。 例如，不要在 layout-land/ 和 layout-port/ 中分别提供横向和纵向的布局资源，而是保留其中之一作为默认设置，例如：layout/ 用于横向，layout-port/ 用于纵向。</p>
<p>提供默认资源至关重要，这不仅仅因为应用可能在超出预期的配置上运行，也因为新版 Android 有时会添加旧版本不支持的配置限定符。若要使用新的资源限定符，又希望维持对旧版 Android 的代码兼容性，则当旧版 Android 运行应用时，如果不提供默认资源，应用将会崩溃，这是因为它无法使用以新限定符命名的资源。例如，如果将 <code>minSdkVersion</code> 设置为 4，并使用<code>夜间模式</code>（night 或 notnight，API 级别 8 中新增配置）限定所有可绘制对象资源，则 API 级别 4 设备无法访问可绘制对象资源，而且会崩溃。在这种情况下，您可能希望 notnight 成为默认资源，为此，您应排除该限定符，使可绘制对象资源位于<code>drawable/</code> 或 <code>drawable-night/</code> 中。</p>
<p>因此，为了提供最佳设备兼容性，请始终为应用正确运行所必需的资源提供默认资源。 然后，使用配置限定符为特定的设备配置创建备用资源。</p>
<p>这条规则有一个例外：如果应用的 <code>minSdkVersion</code> 为 4 或更高版本，则在提供带屏幕密度限定符的备用可绘制对象资源时，不需要默认可绘制对象资源。 即使没有默认可绘制对象资源，Android 也可以从备用屏幕密度中找到最佳匹配项并根据需要缩放位图。 但是，为了在所有类型的设备上提供最佳体验，您应该为所有三种类型的密度提供备用可绘制对象。</p>
<h2 id="Android-如何找到最匹配资源"><a href="#Android-如何找到最匹配资源" class="headerlink" title="Android 如何找到最匹配资源"></a>Android 如何找到最匹配资源</h2><p>当您请求要为其提供备用资源的资源时，Android 会根据当前的设备配置选择要在运行时使用的备用资源。为演示 Android 如何选择备用资源，假设以下可绘制对象目录分别包含相同图像的不同版本：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">drawable/</span><br><span class="line">drawable-en/</span><br><span class="line">drawable-fr-rCA/</span><br><span class="line">drawable-en-port/</span><br><span class="line">drawable-en-notouch-<span class="hljs-number">12</span>key/</span><br><span class="line">drawable-port-ldpi/</span><br><span class="line">drawable-port-notouch-<span class="hljs-number">12</span>key/</span><br></pre></td></tr></table></figure></p>
<p>同时，假设设备配置如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语言区域 = en-GB </span><br><span class="line">屏幕方向 = port </span><br><span class="line">屏幕像素密度 = hdpi </span><br><span class="line">触摸屏类型 = notouch </span><br><span class="line">主要文本输入法 = <span class="hljs-number">12</span>key</span><br></pre></td></tr></table></figure></p>
<p>通过将设备配置与可用的备用资源进行比较，Android 从 <code>drawable-en-port</code> 中选择可绘制对象。</p>
<p>系统使用以下逻辑决定要使用的资源：</p>
<ol>
<li><p>淘汰与设备配置冲突的资源文件。<br> <code>drawable-fr-rCA/</code> 目录与<code>en-GB</code>语言区域冲突，因而被淘汰。</p>
 <figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">drawable/</span><br><span class="line">drawable-en/</span><br><span class="line">drawable-fr-rCA/ ---&gt;<span class="hljs-comment">//被淘汰</span></span><br><span class="line">drawable-en-port/</span><br><span class="line">drawable-en-notouch-<span class="hljs-number">12</span>key/</span><br><span class="line">drawable-port-ldpi/</span><br><span class="line">drawable-port-notouch-<span class="hljs-number">12</span>key/</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>例外</strong>：屏幕像素密度是唯一一个未因冲突而被淘汰的限定符。 尽管设备的屏幕密度为 hdpi，但是 drawable-port-ldpi/ 未被淘汰，因为此时每个屏幕密度均视为匹配。如需了解详细信息，请参阅支持多种屏幕文档。</p>
</blockquote>
</li>
<li>选择列表（<code>表 2</code>）中（下一个）优先级最高的限定符。（先从 <code>MCC</code>开始，然后下移。）</li>
<li>是否有资源目录包括此限定符？<ul>
<li>若无，请返回到第 2 步，看看下一个限定符。（在该示例中，除非达到语言限定符，否则答案始终为“否”。）</li>
<li>若有，请继续执行第 4 步。</li>
</ul>
</li>
<li><p>淘汰不含此限定符的资源目录。在该示例中，系统会淘汰所有不含语言限定符的目录。</p>
 <figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	drawable/  ---&gt;<span class="hljs-comment">//被淘汰</span></span><br><span class="line">drawable-en/</span><br><span class="line">drawable-en-port/</span><br><span class="line">drawable-en-notouch-<span class="hljs-number">12</span>key/</span><br><span class="line">drawable-port-ldpi/        ---&gt;<span class="hljs-comment">//被淘汰</span></span><br><span class="line">drawable-port-notouch-<span class="hljs-number">12</span>key/   ---&gt;<span class="hljs-comment">//被淘汰</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>例外</strong>：如果涉及的限定符是屏幕像素密度，则 Android 会选择最接近设备屏幕密度的选项。通常，Android 倾向于缩小大型原始图像，而不是放大小型原始图像。请参阅支持多种屏幕。</p>
</blockquote>
</li>
<li><p>返回并重复第 2 步、第 3 步和第 4 步，直到只剩下一个目录为止。在此示例中，屏幕方向是下一个判断是否匹配的限定符。因此，未指定屏幕方向的资源被淘汰：</p>
<pre><code><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	drawable-en/  ---&gt;<span class="hljs-comment">//被淘汰</span></span><br><span class="line">drawable-en-port/</span><br><span class="line">drawable-en-notouch-<span class="hljs-number">12</span>key/  ---&gt;<span class="hljs-comment">//被淘汰</span></span><br></pre></td></tr></table></figure>
</code></pre><p> 剩下的目录是<code>drawable-en-port</code>。</p>
</li>
</ol>
<p>尽管对所请求的每个资源均执行此程序，但是系统仍会对某些方面做进一步优化。 例如，系统一旦知道设备配置，即会淘汰可能永远无法匹配的备用资源。 比如说，如果配置语言是英语（“en”），则系统绝不会将语言限定符设置为非英语的任何资源目录包含在选中的资源池中（不过，仍会将不带语言限定符的资源目录包含在该池中）。</p>
<p>根据屏幕尺寸限定符选择资源时，如果没有更好的匹配资源，则系统将使用专为小于当前屏幕的屏幕而设计的资源（例如，如有必要，大尺寸屏幕将使用标准尺寸的屏幕资源）。 但是，如果唯一可用的资源大于当前屏幕，则系统不会使用这些资源，并且如果没有其他资源与设备配置匹配，应用将会崩溃（例如，如果所有布局资源均用 xlarge 限定符标记，但设备是标准尺寸的屏幕）。</p>
<blockquote>
<p><strong>注</strong>：限定符的优先顺序（表 2 中）比与设备完全匹配的限定符数量更加重要。例如，在上面的第 4 步中，列表剩下的最后选项包括三个与设备完全匹配的限定符（方向、触摸屏类型和输入法），而 <code>drawable-en</code> 只有一个匹配参数（语言）。但是，语言的优先顺序高于其他两个限定符，因此<code>drawable-port-notouch-12key</code> 被淘汰。</p>
</blockquote>
<p>write by laohu<br>2016年11月19日</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android基础之9-Patch(9.PNG)与padding]]></title>
      <url>http://ittiger.cn/Nine-Patch-Affect-Padding-Principle.html</url>
      <content type="html"><![CDATA[<p>在上一篇文章<a href="http://ittiger.cn/My-9.png-hold-the-fat-lady-tour.html">记一次9.png的填坑之旅</a>最后，我留了两个个问题：</p>
<ol>
<li>为什么使用<code>9.PNG</code>设置背景之后会改变控件的<code>padding</code>属性值</li>
<li>在我所遇到的问题中<code>9.PNG</code>明明改变的是<code>padding</code>值为什么却产生了<code>margin</code>的效果   </li>
</ol>
<p>这篇文章就来解答这两个问题以及<code>9.PNG</code>使用过程中需要注意的地方。</p>
<p>各位同学如果没看过<a href="http://ittiger.cn/My-9.png-hold-the-fat-lady-tour.html">记一次9.png的填坑之旅</a>这篇文章可以先去看看，因为我下面所讲的内容都是根据这篇文章中的问题来讲的。</p>
<a id="more"></a>
<h2 id="问题9-Patch图"><a href="#问题9-Patch图" class="headerlink" title="问题9-Patch图"></a>问题9-Patch图</h2><p>还是先来看下我所使用的<code>9.PNG</code>的图<br><img src="/img/View_9_PNG_3.png" alt><br>从图中可以看出中间那一片白色区域是内容区，而内容区到底部的黑边线之间还一段<font color="red"><strong>透明的区域</strong></font>，这段区域是不会显示内容的。</p>
<h2 id="结论猜想"><a href="#结论猜想" class="headerlink" title="结论猜想"></a>结论猜想</h2><p>看到这个透明区域联想到我上面遇到的问题</p>
<blockquote>
<p>明明改变的是<code>padding</code>却产生了<code>margin</code>的效果</p>
</blockquote>
<p>大家是不是会出现一个猜想，难道上篇文章中<code>padding</code>改变却出现<code>margin</code>效果是因为这个透明的区域导致的？</p>
<p>恭喜你，答对了，我前面遇到的问题中<code>padding</code>改变却产生<code>margin</code>效果就是因为这个透明区域导致的。</p>
<p>你可能又要接着问了，这是为什么呢？</p>
<p>不要走开，下面我就来说说其中的原因。</p>
<h2 id="一探setBackgroundResource"><a href="#一探setBackgroundResource" class="headerlink" title="一探setBackgroundResource"></a>一探setBackgroundResource</h2><p>我们来看看布局设置背景图片的方法<code>setBackgroundResource(int resid)</code>是如何实现的<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBackgroundResource</span><span class="hljs-params">(<span class="hljs-keyword">int</span> resid)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (resid != <span class="hljs-number">0</span> &amp;&amp; resid == mBackgroundResource) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Drawable d = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (resid != <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        d = mContext.getDrawable(resid);</span><br><span class="line">    &#125;</span><br><span class="line">    setBackground(d);</span><br><span class="line">    mBackgroundResource = resid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码可以看到调用了<code>setBackground(Drawable drawable)</code>这个方法，我们接着看<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBackground</span><span class="hljs-params">(Drawable background)</span> </span>&#123;</span><br><span class="line">    setBackgroundDrawable(background);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们接着看<code>setBackgroundDrawable(Drawable drawable)</code>这个方法的实现<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBackgroundDrawable</span><span class="hljs-params">(Drawable background)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-keyword">if</span> (background != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        Rect padding = sThreadLocal.get();</span><br><span class="line">        <span class="hljs-keyword">if</span> (padding == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            padding = <span class="hljs-keyword">new</span> Rect();</span><br><span class="line">            sThreadLocal.set(padding);</span><br><span class="line">        &#125;</span><br><span class="line">        resetResolvedDrawables();</span><br><span class="line">        background.setLayoutDirection(getLayoutDirection());</span><br><span class="line">        <span class="hljs-keyword">if</span> (background.getPadding(padding)) &#123;</span><br><span class="line">            resetResolvedPadding();</span><br><span class="line">            <span class="hljs-keyword">switch</span> (background.getLayoutDirection()) &#123;</span><br><span class="line">                <span class="hljs-keyword">case</span> LAYOUT_DIRECTION_RTL:</span><br><span class="line">                    mUserPaddingLeftInitial = padding.right;</span><br><span class="line">                    mUserPaddingRightInitial = padding.left;</span><br><span class="line">                    internalSetPadding(padding.right, padding.top, padding.left, padding.bottom);</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                <span class="hljs-keyword">case</span> LAYOUT_DIRECTION_LTR:</span><br><span class="line">                <span class="hljs-keyword">default</span>:</span><br><span class="line">                    mUserPaddingLeftInitial = padding.left;</span><br><span class="line">                    mUserPaddingRightInitial = padding.right;</span><br><span class="line">                    internalSetPadding(padding.left, padding.top, padding.right, padding.bottom);</span><br><span class="line">            &#125;</span><br><span class="line">            mLeftPaddingDefined = <span class="hljs-keyword">false</span>;</span><br><span class="line">            mRightPaddingDefined = <span class="hljs-keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码很明显可以看到当<code>background.getPadding(padding)</code>返回<code>true</code>的时候当前布局视图会通过<code>internalSetPadding(padding.left, padding.top, padding.right, padding.bottom)</code>给当前视图设置相应的<code>padding</code>值</p>
<h2 id="NinePatchDrawable"><a href="#NinePatchDrawable" class="headerlink" title="NinePatchDrawable"></a>NinePatchDrawable</h2><p>因为我们使用的是<code>9-Patch</code>，所以生成的<code>Drawable</code>对象是<code>NinePatchDrawable</code>实例，我们接着上面的源码流程继续查看<code>NinePatchDrawable.getPadding(Rect padding)</code>方法：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">getPadding</span><span class="hljs-params">(Rect padding)</span> </span>&#123;</span><br><span class="line"> <span class="hljs-keyword">final</span> Rect scaledPadding = mPadding;</span><br><span class="line">    <span class="hljs-keyword">if</span> (scaledPadding != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (needsMirroring()) &#123;</span><br><span class="line">            padding.set(scaledPadding.right, scaledPadding.top,</span><br><span class="line">                    scaledPadding.left, scaledPadding.bottom);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            padding.set(scaledPadding);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> (padding.left | padding.top | padding.right | padding.bottom) != <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的方法很明显可以看出，如果当前<code>9-Patch</code>图存在<code>Padding</code>值的话，它会将该值设置到参数<code>Rect</code>中，而在前面<code>setBackgroundDrawable(Drawable drawable)</code>方法实现中方法<code>internalSetPadding(padding.left, padding.top, padding.right, padding.bottom)</code>里所传的参数<code>padding</code>就是这个地方的<code>Rect</code>参数实例。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>总结成一句话就是<font color="red">如果我们使用的<code>9-Patch</code>图生成的<code>NinePatchDrawable</code>对象存在<code>Padding</code>值，那么这些<code>Padding</code>值将会同时设置给使用该<code>9-Patch</code>作为背景图的<code>View</code>的<code>Padding</code>属性上</font></p>
<p>看了上面的结论，大家可能又会有一个疑问？？？</p>
<blockquote>
<p>我们使用的<code>9-Patch</code>图时，系统为我们生成<code>NinePatchDrawable</code>对象时产生的<code>Padding</code>是根据什么依据得来的呢？</p>
</blockquote>
<h2 id="9-Patch官方定义"><a href="#9-Patch官方定义" class="headerlink" title="9-Patch官方定义"></a>9-Patch官方定义</h2><p>OK，我们来看看<code>Google</code>官方对<code>9-Patch</code>图的定义和介绍<br><a href="https://developer.android.com/guide/topics/graphics/2d-graphics.html#nine-patch" target="_blank" rel="noopener">https://developer.android.com/guide/topics/graphics/2d-graphics.html#nine-patch</a></p>
<blockquote>
<p>The border is used to define the stretchable and static areas of the image. You indicate a stretchable section by drawing one (or more) 1-pixel-wide black line(s) in the left and top part of the border (the other border pixels should be fully transparent or white). You can have as many stretchable sections as you want: their relative size stays the same, so the largest sections always remain the largest.</p>
</blockquote>
<blockquote>
<p>You can also define an optional drawable section of the image (effectively, the padding lines) by drawing a line on the right and bottom lines. <font color="red">If a View object sets the NinePatch as its background and then specifies the View’s text, it will stretch itself so that all the text fits inside only the area designated by the right and bottom lines (if included). </font>If the padding lines are not included, Android uses the left and top lines to define this drawable area.</p>
</blockquote>
<blockquote>
<p>To clarify the difference between the different lines, the left and top lines define which pixels of the image are allowed to be replicated in order to stretch the image. The bottom and right lines define the relative area within the image that the contents of the View are allowed to lie within</p>
</blockquote>
<p><img src="/img/ninepatch_raw.png" alt></p>
<blockquote>
<p>This NinePatch defines one stretchable area with the left and top lines and the drawable area with the bottom and right lines. In the top image, the dotted grey lines identify the regions of the image that will be replicated in order to stretch the image. The pink rectangle in the bottom image identifies the region in which the contents of the View are allowed. If the contents don’t fit in this region, then the image will be stretched so that they do.</p>
</blockquote>
<p>上面这段几段文字是我引用的<code>Android</code>官方的介绍说明，里面介绍了<code>9-Patch</code>图的使用方式和要点。</p>
<h2 id="9-Patch图Padding的由来"><a href="#9-Patch图Padding的由来" class="headerlink" title="9-Patch图Padding的由来"></a>9-Patch图Padding的由来</h2><p>大家注意看段落中我标红的那一句话，这句话就是说：如果你使用<code>9-Patch</code>图给某个<code>View</code>设置<code>background</code>之后，这个<code>View</code>的所有内容仅仅适配显示在内容区域里，而内容区域范围是由<code>9-Patch</code>图<code>right and bottom lines</code>决定的。而<code>9-Patch</code>图内容区以外的部分是不可能无故消失的，所以就作为其<code>Padding</code>了，因此在我们使用<code>9-Patch</code>图作为背景图时，系统为我们生成的<code>NinePatchDrawable</code>对象的<code>Padding</code>值就是根据这得来的。</p>
<h2 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h2><p>知道上面的结论之后，我们再回过头来看我所遇到的问题，我们再看一遍我所使用的<code>9-Patch</code>图<br><img src="/img/View_9_PNG_3.png" alt><br>根据上面的结论可以发现这个图底部有一块透明的非内容区，因此我所使用的这个<code>9-Patch</code>图会产生一个<code>paddingBottom</code>值，而刚好这块区域又是透明，所以在使用的时候这块区域在视图上其实也是透明的，因此这块透明区域看到的效果其实是其父容器视图的内容，所以就造成了<code>margin</code>的效果。</p>
<p>讲到这里，我所遇到的那个问题就得到了完美的解答。</p>
<p>另外大家在使用<code>9-Patch</code>图的时候一定要注意其内容区域，如果<code>9-Patch</code>图制作不合适会产生一些莫名其妙的布局问题。</p>
<p>write by laohu<br>2016年11月18日</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TextView之SpannableStringBuilder使用总结]]></title>
      <url>http://ittiger.cn/TextView-SpannableStringBuilder-usage-summary.html</url>
      <content type="html"><![CDATA[<p>最近项目中碰到一个<code>TextView</code>的显示问题，想了各种办法之后，最后还是用<code>SpannableStringBuilder</code>解决的。这篇文章就记录下我的问题的解决过程，同时总结下<code>SpannableStringBuilder</code>在<code>TextView</code>中的不同用法。</p>
<a id="more"></a>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>项目中<code>GridView</code>有两列，每个<code>Item</code>视图都有一个<code>TextView</code>(设置了最大显示行数)，项目业务要求每列的<code>TextView</code>展示高度相同，但是因为显示的文本你不知道有多少行，所以在布局的时候不能设置固定高度，而是设置为<code>wrap_content</code>，所以为了保证两列的<code>TextView</code>高度一致，只需要保证他们展示内容的行数一致就行。</p>
<p>而上面的问题只需要在内容行数达不到最大显示行数时，为其手动补齐行数即可。</p>
<p><em><font color="red">这里有个问题就是如何计算当前要展示的文本在此<code>TextView</code>中能展示多少行，这个地方直接通过<code>textView.getLineCount()</code>是不行的，我是通过<code>StaticLayout</code>计算当前文本能显示的行数，对于<code>StaticLayout</code>的使用这篇文章就不介绍了，不会的同学可以去google下，后面的文章我会专门介绍<code>StaticLayout</code>的使用</font></em></p>
<p>有了上面的解决方法之后，我在行数不足时我手动添加了换行符<code>\n</code>补齐行数，但是运行之后，发现达不到效果，因为虽然手动换行，但是通过换行符<code>\n</code>换行之后的高度达不到实际文本行显示的高度，因此这种方式还是没法保证两边<code>TextView</code>高度一致。</p>
<p>既然单纯的换行无法达到我们想要的效果，那我就在换行之后再添加几个文字，有了这几个文字就可以让其真正达到多行文本的效果了。但是多的这几个字会显示在界面上，所以我们只需要让这几个文字不显示出来或者让这几个文字完全透明即可。</p>
<p>将<code>TextView</code>的部分文本设置为透明色，最后查询之后发现<code>SpannableStringBuilder</code>可以实现这样的效果，下面我就总结下<code>SpannableStringBuilder</code>结合<code>TextView</code>的使用方法。</p>
<h2 id="SpannableStringBuilder使用总结"><a href="#SpannableStringBuilder使用总结" class="headerlink" title="SpannableStringBuilder使用总结"></a>SpannableStringBuilder使用总结</h2><p>我们来看下<code>SpannableStringBuilder</code>的官方介绍</p>
<blockquote>
<p>This is the class for text whose content and markup can both be changed</p>
</blockquote>
<p>通过上面的介绍可以看出<code>SpannableStringBuilder</code>是一个内容和标记都可以更改的类，它其实是<code>CharSequence</code>的子类。</p>
<h3 id="SpannableStringBuilder使用效果"><a href="#SpannableStringBuilder使用效果" class="headerlink" title="SpannableStringBuilder使用效果"></a>SpannableStringBuilder使用效果</h3><p><img src="/img/SpannableStringBuilder.png" alt></p>
<h3 id="文本高亮"><a href="#文本高亮" class="headerlink" title="文本高亮"></a>文本高亮</h3><p>使用<code>ForegroundColorSpan</code>为<code>TextView</code>的部分文本添加指定颜色，使这部分文本高亮显示<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SpannableStringBuilder builder = <span class="hljs-keyword">new</span> SpannableStringBuilder(<span class="hljs-string">"普通文本"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> start = builder.length();<span class="hljs-comment">//高亮的开始位置</span></span><br><span class="line">builder.append(<span class="hljs-string">"文本高亮"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> end = builder.length();<span class="hljs-comment">//高亮的结束位置</span></span><br><span class="line">builder.setSpan(<span class="hljs-keyword">new</span> ForegroundColorSpan(Color.RED), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">mTextView.setText(builder);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>ForegroundColorSpan</code>代表设置文本高亮的颜色</li>
<li><code>Spanned.SPAN_INCLUSIVE_EXCLUSIVE</code>这个常量表示高亮开始位置但不包含结束位置的字符，还有几个类似的常量，这几个常量与<code>Stirng.subString()</code>方法的参数代表的意思是类似的。</li>
<li>上面我的解决办法中需要文本完全透明，只需要将高亮的颜色设置为100%透明即可</li>
</ul>
<h3 id="URL超链接效果"><a href="#URL超链接效果" class="headerlink" title="URL超链接效果"></a>URL超链接效果</h3><p>使用<code>URLSpan</code>为<code>TextView</code>的部分文本添加超链接效果<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SpannableStringBuilder builder = <span class="hljs-keyword">new</span> SpannableStringBuilder(<span class="hljs-string">"普通文本"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> start = builder.length();<span class="hljs-comment">//URL文本开始位置</span></span><br><span class="line">builder.append(<span class="hljs-string">"URL连接"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> end = builder.length();<span class="hljs-comment">//URL文本结束位置</span></span><br><span class="line">builder.setSpan(<span class="hljs-keyword">new</span> URLSpan(<span class="hljs-string">"www.baidu.com"</span>) &#123;</span><br><span class="line">     <span class="hljs-meta">@Override</span></span><br><span class="line">     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View widget)</span> </span>&#123;</span><br><span class="line">	     <span class="hljs-comment">//URLSpan点击响应</span></span><br><span class="line">         UIUtil.showToast(context, <span class="hljs-string">"URLSpan点击"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;, start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">mTextView.setText(builder);</span><br><span class="line"><span class="hljs-comment">//必须设置下面的方法，否则URLSpan点击事件无法响应</span></span><br><span class="line">mTextView.setMovementMethod(LinkMovementMethod.getInstance());</span><br></pre></td></tr></table></figure></p>
<ul>
<li>使用<code>URLSpan</code>即可将<code>TextView</code>的部分文本设置为超链接显示样式，同时还可以实现点击响应，但是必须调用<code>TextView.setMovementMethod(LinkMovementMethod.getInstance());</code>点击响应才会有效</li>
</ul>
<h3 id="设置文本背景色"><a href="#设置文本背景色" class="headerlink" title="设置文本背景色"></a>设置文本背景色</h3><p>使用<code>BackgroundColorSpan</code>为<code>TextView</code>的部分文本添加背景色<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SpannableStringBuilder builder = <span class="hljs-keyword">new</span> SpannableStringBuilder(<span class="hljs-string">"普通文本"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> start = builder.length();<span class="hljs-comment">//设置背景色的开始位置</span></span><br><span class="line">builder.append(<span class="hljs-string">"设置背景色"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> end = builder.length();<span class="hljs-comment">//设置背景色的结束位置</span></span><br><span class="line">builder.setSpan(<span class="hljs-keyword">new</span> BackgroundColorSpan(Color.BLUE), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">mTextView.setText(builder);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>BackgroundColorSpan</code>可以将<code>TextView</code>的部分文本添加背景色，与<code>ForegroundColorSpan</code>的使用方式相同，只需要设置颜色即可</li>
</ul>
<h3 id="添加文本下划线"><a href="#添加文本下划线" class="headerlink" title="添加文本下划线"></a>添加文本下划线</h3><p>使用<code>UnderlineSpan</code>为<code>TextView</code>的部分文本添加下划线<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SpannableStringBuilder builder = <span class="hljs-keyword">new</span> SpannableStringBuilder(<span class="hljs-string">"普通文本"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> start = builder.length();<span class="hljs-comment">//设置下划线的开始位置</span></span><br><span class="line">builder.append(<span class="hljs-string">"下划线文本"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> end = builder.length();<span class="hljs-comment">//设置下划线的结束位置</span></span><br><span class="line">builder.setSpan(<span class="hljs-keyword">new</span> UnderlineSpan(), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">mTextView.setText(builder);</span><br></pre></td></tr></table></figure></p>
<h3 id="文本添加删除线"><a href="#文本添加删除线" class="headerlink" title="文本添加删除线"></a>文本添加删除线</h3><p>使用<code>StrikethroughSpan</code>为<code>TextView</code>的部分文本添加删除线<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SpannableStringBuilder builder = <span class="hljs-keyword">new</span> SpannableStringBuilder(<span class="hljs-string">"普通文本"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> start = builder.length();<span class="hljs-comment">//设置删除线的开始位置</span></span><br><span class="line">builder.append(<span class="hljs-string">"删除线文本"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> end = builder.length();<span class="hljs-comment">//设置删除线的结束位置</span></span><br><span class="line">builder.setSpan(<span class="hljs-keyword">new</span> StrikethroughSpan(), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">mTextView.setText(builder);</span><br></pre></td></tr></table></figure></p>
<h3 id="图片替换文本"><a href="#图片替换文本" class="headerlink" title="图片替换文本"></a>图片替换文本</h3><p>使用<code>ImageSpan</code>为<code>TextView</code>的部分文本替换为图片<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SpannableStringBuilder builder = <span class="hljs-keyword">new</span> SpannableStringBuilder(<span class="hljs-string">"普通文本"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> start = builder.length();<span class="hljs-comment">//替换为图片的开始位置</span></span><br><span class="line">builder.append(<span class="hljs-string">"图片替换文本"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> end = builder.length();<span class="hljs-comment">//替换为图片的结束位置</span></span><br><span class="line">Drawable drawable = getResources().getDrawable(R.mipmap.ic_launcher);</span><br><span class="line">drawable.setBounds(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>);<span class="hljs-comment">//设置图片为50px大小</span></span><br><span class="line">builder.setSpan(<span class="hljs-keyword">new</span> ImageSpan(drawable, ImageSpan.ALIGN_BOTTOM), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">mTextView.setText(builder);</span><br></pre></td></tr></table></figure></p>
<h3 id="设置部分粗体"><a href="#设置部分粗体" class="headerlink" title="设置部分粗体"></a>设置部分粗体</h3><p>使用<code>StyleSpan</code>为<code>TextView</code>的部分文本设置为粗体<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SpannableStringBuilder builder = <span class="hljs-keyword">new</span> SpannableStringBuilder(<span class="hljs-string">"普通文本"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> start = builder.length();<span class="hljs-comment">//设置粗体的开始位置</span></span><br><span class="line">builder.append(<span class="hljs-string">"粗体文本"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> end = builder.length();<span class="hljs-comment">//设置粗体的结束位置</span></span><br><span class="line">builder.setSpan(<span class="hljs-keyword">new</span> StyleSpan(Typeface.BOLD), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">mTextView.setText(builder);</span><br></pre></td></tr></table></figure></p>
<h3 id="为任意文本添加点击响应"><a href="#为任意文本添加点击响应" class="headerlink" title="为任意文本添加点击响应"></a>为任意文本添加点击响应</h3><p>使用<code>ClickableSpan</code>为<code>TextView</code>的任意文本添加点击响应<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SpannableStringBuilder builder = <span class="hljs-keyword">new</span> SpannableStringBuilder(<span class="hljs-string">"普通文本"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> start = builder.length();<span class="hljs-comment">//设置删除线的开始位置</span></span><br><span class="line">builder.append(<span class="hljs-string">"单击响应文本"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> end = builder.length();<span class="hljs-comment">//设置删除线的结束位置</span></span><br><span class="line">builder.setSpan(<span class="hljs-keyword">new</span> ClickableSpan() &#123;<span class="hljs-comment">//将任意文本设置为可点击</span></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View widget)</span> </span>&#123;</span><br><span class="line">        UIUtil.showToast(StyleTextViewActivity.<span class="hljs-keyword">this</span>, <span class="hljs-string">"ClickableSpan"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateDrawState</span><span class="hljs-params">(TextPaint ds)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//此方法的默认实现会出现下划线效果，去掉其默认实现</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">mTextView.setText(builder);</span><br><span class="line">mTextView.setMovementMethod(LinkMovementMethod.getInstance());</span><br></pre></td></tr></table></figure></p>
<h3 id="组合使用各效果"><a href="#组合使用各效果" class="headerlink" title="组合使用各效果"></a>组合使用各效果</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SpannableStringBuilder builder = <span class="hljs-keyword">new</span> SpannableStringBuilder(<span class="hljs-string">"普通文本"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> start = builder.length();<span class="hljs-comment">//设置组合使用的开始位置</span></span><br><span class="line">builder.append(<span class="hljs-string">"组合使用"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> end = builder.length();<span class="hljs-comment">//设置组合使用的结束位置</span></span><br><span class="line">builder.setSpan(<span class="hljs-keyword">new</span> ForegroundColorSpan(Color.WHITE), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">builder.setSpan(<span class="hljs-keyword">new</span> BackgroundColorSpan(Color.RED), start, end, Spanned.SPAN_INCLUSIVE_EXCLUSIVE);</span><br><span class="line">mTextView.setText(builder);</span><br></pre></td></tr></table></figure>
<p>上面这些就是<code>SpannableStringBuilder</code>结合<code>TextView</code>的一些使用方法，其实使用起来还是很简单的。</p>
<p>具体使用示例代码请参考：<a href="https://github.com/huyongli/AndroidDemo/blob/master/app/src/main/java/cn/ittiger/demo/StyleTextViewActivity.java" target="_blank" rel="noopener">https://github.com/huyongli/AndroidDemo</a></p>
<p>write by laohu<br>2016年11月5日21:45:48</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> SpannableStringBuilder </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记一次9.png的填坑之旅]]></title>
      <url>http://ittiger.cn/My-9.png-hold-the-fat-lady-tour.html</url>
      <content type="html"><![CDATA[<p>最近在项目中进行界面调整时遇到了一个<code>9.PNG</code>图引起的<code>View</code>的<code>padding</code>值不正常导致UI显示不符合预期结果的问题。这篇文章就来记录我当时遇到的问题的表现形式，以及如何根据问题找到产生问题的原因，及其最后的解决办法。</p>
<a id="more"></a>
<h2 id="问题表现形式"><a href="#问题表现形式" class="headerlink" title="问题表现形式"></a>问题表现形式</h2><p>不多说，直接上出现问题的视图表现形式的截图：<br><img src="/img/View_9_PNG_1.png" alt></p>
<h2 id="我的实现"><a href="#我的实现" class="headerlink" title="我的实现"></a>我的实现</h2><p>上图中我实现的是一个<code>ListView</code>，同时自定义实现一个视图<code>Png9View extends FrameLayout</code>作为<code>ListView</code>的<code>item</code>视图，为每个<code>item</code>设置灰色背景色。<code>Png9View</code>视图中的白色部分是一个线性布局，并为线性布局顶部添加了一个蓝色的分割线，其底部添加了一个红色的分割线，中间是一个<code>TextView</code>。</p>
<p>大家可以看下<code>item</code>视图实现代码如下，整个<code>Demo</code>的代码在这里<a href="https://github.com/huyongli/AndroidDemo/blob/master/app/src/main/java/cn/ittiger/demo/Png9Activity.java" target="_blank" rel="noopener">https://github.com/huyongli/AndroidDemo</a>：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Png9View</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FrameLayout</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> LinearLayout mContainer;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Png9View</span><span class="hljs-params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>(context, <span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Png9View</span><span class="hljs-params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>(context, attrs, <span class="hljs-number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Png9View</span><span class="hljs-params">(Context context, AttributeSet attrs, <span class="hljs-keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(Context context)</span> </span>&#123;</span><br><span class="line">        LayoutInflater.from(context).inflate(R.layout.png_9_view, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">true</span>);</span><br><span class="line">        mContainer = (LinearLayout) findViewById(R.id.root);</span><br><span class="line">        setBackgroundColor(getResources().getColor(android.R.color.darker_gray));</span><br><span class="line">        mContainer.setBackgroundResource(R.drawable.bg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>png_9_view</code>布局代码如下：<br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">merge</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/root"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"vertical"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"1dp"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@android:color/holo_blue_dark"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"100dp"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_margin</span>=<span class="hljs-string">"10dp"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@color/colorAccent"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">"@android:color/white"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"center_vertical"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">"测试视图标题"</span>/&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"1dp"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@android:color/holo_red_dark"</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">merge</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>ListView</code>的布局如下：<br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">ListView</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/listView"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:dividerHeight</span>=<span class="hljs-string">"0dp"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:divider</span>=<span class="hljs-string">"@null"</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">ListView</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="问题？"><a href="#问题？" class="headerlink" title="问题？"></a>问题？</h2><p>通过上面的效果截图我们很容易发现在第一个<code>Png9View</code>的底部红色分割线和第二个<code>Png9View</code>的顶部蓝色分割线中还有一小段灰色的间隔，而这个灰色间隔显然与我的期望效果不一样，那这个灰色间隔是哪里来的呢？我的代码里好像没有任何设置会出现这样的效果啊。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>出现上面的问题后我第一个想到的就是打开开发者模式中显示布局边界，结果竟然发现这个灰色间隔是<code>Png9View</code>的一部分，而其颜色也刚好与<code>Png9View</code>的背景色相同，但我并没有为<code>LinearLayout</code>视图设置过<code>margin</code>啊，<code>ListView</code>也没有设置过<code>divider</code>，所以看到这个现象时感到很奇怪。想了会也没想出个所以然来，很是费解啊~~~</p>
<p>后来想到在<code>Android Studio 2.2.2</code>中有个新工具<code>Layout Inspector</code>(该工具在<code>Tools -&gt; Android -&gt; Layout Inspector</code>)可以进行<code>UI</code>分析，于是用该工具对界面进行分析最后发现了问题的原因，大家看下我对上面的界面进行分析的截图：<br><img src="/img/View_9_PNG_2.png" alt></p>
<p>上面的图中，我选中的是<code>Png9View</code>的布局文件中的<code>id为root的LinearLayout</code>(左边圈中的)，右边圈的是该布局的相关属性值信息，可以看到该线性布局有的<code>paddingBottom</code>属性值为<code>5</code>，而我也并没有为该<code>LinearLayout</code>设置过<code>margin</code>属性值，那这个值是怎么来的呢？</p>
<p>这个时候我就只能想到该线性布局设置的背景图片<code>bg.9.png</code>了这个地方了。于是我就猜想难道是因为设置了这个<code>.9图</code>才导致了这个问题？为了验证我的猜想，于是我就直接将背景换成了一个颜色作为背景，结果发现就正常了。到这里基本上就可以肯定这个问题就是<code>9.png</code>图干的好事了。</p>
<p>给大家看下我设置的这个图片是什么样的<br><img src="/img/View_9_PNG_3.png" alt></p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>因为我们项目中这个<code>.9</code>图本身就是为了达到白色的效果，所以我直接用背景颜色代替图片作为背景图解决了我的这个问题，这样还可以减少图片资源。</p>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>看了上面的分析之后，可能大家会问另外一个问题，既然这个<code>paddingBottom</code>值是属于<code>LinearLayout</code>的，那为什么会产生<code>margin</code>的效果呢？<code>padding</code>应该是当前布局的内容距离当前布局的边距，那也应该是白色啊，怎么这个<code>padding</code>区域显示的却是其父布局<code>Png9View</code>的背景色呢，怎么就产生了<code>margin</code>的效果呢？</p>
<p>大家伙别急，原因且待下篇分解。。。</p>
<p>write by laohu<br>2016年11月5日15:14:09</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RxJava学习之基本使用]]></title>
      <url>http://ittiger.cn/RxJava-Basic-Use.html</url>
      <content type="html"><![CDATA[<p><code>RxJava</code>现在在Android开发中越来越流行，作为一个<code>Android</code>开发者我也必须紧跟步伐学习学习<code>RxJava</code>，这篇文章就记录了<code>RxJava</code>中我认为比较常用的一些场景。</p>
<p>也给大伙推荐篇比较好的<code>RxJava</code>文章</p>
<ul>
<li><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">给 Android 开发者的 RxJava 详解</a></li>
</ul>
<h2 id="RxJava基础"><a href="#RxJava基础" class="headerlink" title="RxJava基础"></a>RxJava基础</h2><p>大家都知道<code>JDK</code>中提供了观察者模式的实现，它主要两个重要元素：</p>
<ul>
<li>被观察者 <code>Observable</code></li>
<li>观察者 <code>Observer</code></li>
</ul>
<p>至于<code>Java</code>中观察者模式的使用，大家可以自行Google下。</p>
<p>而<code>RxJava</code>中也有两个重要的元素：</p>
<ul>
<li>被观察者(事件源) <code>Observable</code></li>
<li>观察者(事件订阅者) <code>Subscriber</code></li>
</ul>
<p>因此<code>RxJava</code>的设计看起来也有点类似<code>JDK</code>中的观察者模式，都有被观察者和观察者。<br><code>JDK</code>观察者模式中当有操作需要时是由被观察者通知观察者来进行更新操作<br><code>RxJava</code>中是由被观察者<code>Observable</code>发出事件给观察者<code>Subscriber</code>接收，然后观察者<code>Subscriber</code>调用<code>noNext()</code>进行处理，直到调用<code>onComplete)()</code>或<code>onError()</code>结束</p>
<a id="more"></a>
<h2 id="Gradle依赖"><a href="#Gradle依赖" class="headerlink" title="Gradle依赖"></a>Gradle依赖</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="hljs-string">'io.reactivex:rxjava:1.0.1'</span></span><br><span class="line">compile <span class="hljs-string">'io.reactivex:rxandroid:1.0.1'</span></span><br></pre></td></tr></table></figure>
<h2 id="基础方式创建Observable和Subscriber"><a href="#基础方式创建Observable和Subscriber" class="headerlink" title="基础方式创建Observable和Subscriber"></a>基础方式创建Observable和Subscriber</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//使用Observable.create()方式创建一个Observable事件源</span></span><br><span class="line">Observable&lt;String&gt; observable = Observable.create(<span class="hljs-keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(Subscriber&lt;? <span class="hljs-keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        subscriber.onNext(<span class="hljs-string">"hello world"</span>);</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-comment">//创建一个观察者Subscriber</span></span><br><span class="line">Subscriber&lt;String&gt; subscriber = <span class="hljs-keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">		Log.d(<span class="hljs-string">"RxJava"</span> <span class="hljs-string">"onComplete"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable e)</span> </span>&#123;</span><br><span class="line">	    Log.d(<span class="hljs-string">"RxJava"</span> <span class="hljs-string">"onError"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">        Log.d(<span class="hljs-string">"RxJava"</span> s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//观察者订阅事件源</span></span><br><span class="line">observable.subscribe(subscriber);</span><br></pre></td></tr></table></figure>
<p>上面是<code>RxJava</code>的基础使用方式，这种方式使用起来和观察者模式还是比较像的，首先创建一个被观察者<code>Observable</code>，再创建一个观察者<code>Subscriber</code>，然后观察者订阅这个被观察者，一旦订阅之后<code>Observable</code>就会执行上面的<code>call(Subscriber subscriber)</code>方法(参数里面的<code>Subscriber</code>参数就是我们创建的观察者实例)，通过该方法我们手动调用<code>Subscriber</code>方法的<code>onNext和onCompleted</code>方法。这里有个要注意的就是我们必须自己手动调用<code>onNext和onCompleted</code>方法，否则不会自己执行。</p>
<h2 id="简化创建Observable和Subscriber"><a href="#简化创建Observable和Subscriber" class="headerlink" title="简化创建Observable和Subscriber"></a>简化创建Observable和Subscriber</h2><p>上面提到的<code>Observable</code>和<code>Subscriber</code>创建方式是<code>RxJava</code>中最基本的方式，但是上面的方式使用起来还是感觉有点繁琐，必须按部就班的来。</p>
<p><code>RxJava</code>中也提供了简单的创建方式，比如：<code>Observable.just()</code>方式创建<code>Observable</code>，完整是示例如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//创建一个只发出一个事件就结束的对象</span></span><br><span class="line">Observable&lt;String&gt; observable = Observable.just(<span class="hljs-string">"hello world"</span>);</span><br><span class="line"><span class="hljs-comment">//创建一个只关心onNext处理的subscriber</span></span><br><span class="line">Action1&lt;String&gt; onNextAction = <span class="hljs-keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">		Log.d(<span class="hljs-string">"RxJava"</span> s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//此方法有重载版本，可以传递处理onError,onComplete的Action</span></span><br><span class="line">observable.subscribe(onNextAction);</span><br></pre></td></tr></table></figure></p>
<p>上面的方法中使用<code>Observable.just()</code>方法可以快速的创建一个发送<code>hello world</code>事件的事件源，而如果我们只关心观察者对事件的处理，而不关心事件处理结束和事件发生错误时的处理，我们则可以创建<code>Action1</code>对象来替代<code>Subscriber</code>进行事件处理。</p>
<p>上面<code>observable.subscribe(onNextAction)</code>一旦订阅事件，就会自动的执行<code>Action1</code>中的<code>call</code>方法，该方法的作用等同于<code>Subscriber</code>中的<code>onNext</code>方法的作用，至于为什么一旦订阅就会自动执行<code>call</code>方法，而前面的一个例子中我们却需要手动调用<code>Subscriber</code>中的<code>onNext</code>方法，这个原因大家可以去源码实现中找答案，我就不介绍了。</p>
<p>当然如果你除了处理事件外，也需要对事件结束和事件错误时进行其他处理，则可以使用<code>observable.subscribe(Action1)</code>另一个重载方法<code>observable.subscribe(Action1,Action1,Action1)</code>分别接收对应<code>onNext</code>,<code>onCompleted</code>,<code>onError</code>.</p>
<p><code>Action1</code>中的<code>call</code>方法只能接收一个参数，<code>RxJava</code>中也提供了很多其他的几种<code>Action</code>，从<code>Action0</code>到<code>Action9</code>分表代表其<code>call</code>方法能接收0个参数到9个参数，另外还有一个<code>ActionN</code>其能接收N个参数。</p>
<p><code>RxJava</code>其实是支持链式写法 的，所以上面的写法可以适用如下的方式实现：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="hljs-string">"hello world"</span>)</span><br><span class="line">          .subscribe(<span class="hljs-keyword">new</span> Action1&lt;String&gt;() &#123;</span><br><span class="line">              <span class="hljs-meta">@Override</span></span><br><span class="line">              <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">				  Log.d(<span class="hljs-string">"RxJava"</span> s);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面介绍了<code>RxJava</code>的基本使用，下面接着介绍<code>RxJava</code>中一些比较常用的功能函数。</p>
<h2 id="事件变换map"><a href="#事件变换map" class="headerlink" title="事件变换map"></a>事件变换map</h2><p>这个<code>map</code>是干什么用的呢？我举个例子：比如说我们有一个<code>Observable</code>对象，这个对象发送的事件是一串用户密码字符串，但是<code>Subscriber</code>进行处理的时候需要的是一个包含加密后的密码串，这个时候我们就可以使用<code>map</code>操作符将一个<code>Observable</code>对象发送的事件修改成另一个事件，下面的代码里通过map将<code>hello world</code>转换成其<code>hashCode</code>值<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="hljs-string">"hello world"</span>)</span><br><span class="line"><span class="hljs-comment">//map操作将一个事件变换为另外一个事件，只会影响到当前的subscriber</span></span><br><span class="line"><span class="hljs-comment">//此处将Observable的String事件转换成Integer事件，所以事件是可用改变的</span></span><br><span class="line">.map(<span class="hljs-keyword">new</span> Func1&lt;String, Integer&gt;() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> s.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.subscribe(<span class="hljs-keyword">new</span> Action1&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(Integer hashCode)</span> </span>&#123;</span><br><span class="line">		<span class="hljs-comment">//这里的值就是hello world的hash值</span></span><br><span class="line">		Log.d(<span class="hljs-string">"RxJava"</span> s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>例子中<code>map(Func1&lt;source, target&gt;)</code>操作符通过<code>Func1&lt;source, target&gt;</code>类将<code>source</code>事件转换修改成<code>target</code>事件</p>
<p>通过上面的介绍可以看出map是用来变换修改<code>Observable</code>所发出的事件</p>
<h2 id="Observable变换flatMap"><a href="#Observable变换flatMap" class="headerlink" title="Observable变换flatMap"></a>Observable变换flatMap</h2><p><code>map</code>是用来变换<code>Observable</code>所发出的事件，而<code>flatMap</code>就更强大，它可以将<code>Observable</code>转换成一个全新的<code>Observable</code>，依旧上例子代码<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="hljs-string">"laohu"</span>)</span><br><span class="line">    <span class="hljs-comment">//将一个事件数据变换为另一种事件输出的Observable</span></span><br><span class="line">    .flatMap(<span class="hljs-keyword">new</span> Func1&lt;String, Observable&lt;User&gt;&gt;() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;User&gt; <span class="hljs-title">call</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> Observable.just(<span class="hljs-keyword">new</span> User(s));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(<span class="hljs-keyword">new</span> Action1&lt;User&gt;() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(User user)</span> </span>&#123;</span><br><span class="line">			Log.d(<span class="hljs-string">"RxJava"</span> user.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面的例子中通过<code>flatMap</code>操作符将一个发送<code>laohu</code>事件的<code>Observable</code>转换成一个发送<code>User</code>对象的<code>Observable</code>，该变化是完全生成一个新的<code>Observable</code></p>
<h2 id="Observable-from"><a href="#Observable-from" class="headerlink" title="Observable.from"></a>Observable.from</h2><p>在我们开发过程中经常需要对一个数组或是一个集合数据进行处理，比如我通过班级编号可以查出这个班的所有学生，查询出来后需要打印出每个学生的名字，那么我们使用上面介绍的方式该怎么做呢？<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students= ...</span><br><span class="line">Observable.just(students)</span><br><span class="line">    .subscribe(<span class="hljs-keyword">new</span> Action1&lt;List&lt;Student&gt;&gt;() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(List&lt;Student&gt; students)</span> </span>&#123;</span><br><span class="line">	        <span class="hljs-keyword">for</span>(User user : users) &#123;</span><br><span class="line">		        Log.d(<span class="hljs-string">"RxJava"</span> students.getName());</span><br><span class="line">	        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面的做法中，很明显我们是在<code>Subscriber</code>中对列表进行循环打印出每个学生的名字，这种方法是不是感觉很多余，我既然都拿到列表了我干嘛还要多次一举使用<code>RxJava</code>去进行循环处理。这时使用<code>Observable.from</code>就可以解决这个问题，该方法可以将集合或数组进行循环处理，每次发送一个事件元素给<code>Subscriber</code>进行处理，在<code>Subscriber</code>中只需要针对单个<code>Student</code>进行姓名打印就可以了，改进之后的写法如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students= ...</span><br><span class="line">Observable.from(students)</span><br><span class="line">    .subscribe(<span class="hljs-keyword">new</span> Action1&lt;Student&gt;() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(Student student)</span> </span>&#123;</span><br><span class="line">		    Log.d(<span class="hljs-string">"RxJava"</span> student.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>改进之后的写法看着是不是很简单，<code>from</code>配合<code>flatMap</code>可以实现很多很复杂的操作，后面我们再举例</p>
<h2 id="事件过滤filter"><a href="#事件过滤filter" class="headerlink" title="事件过滤filter"></a>事件过滤filter</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>  </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">        <span class="hljs-keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String[] array = &#123;<span class="hljs-string">"张三"</span>, <span class="hljs-string">"李四"</span>, <span class="hljs-string">"王麻子"</span>, <span class="hljs-string">"赵六"</span>&#125;;</span><br><span class="line">Observable.from(array)</span><br><span class="line">        <span class="hljs-comment">//将一个事件数据变换为另一种事件输出的Observable</span></span><br><span class="line">        .flatMap(<span class="hljs-keyword">new</span> Func1&lt;String, Observable&lt;User&gt;&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;User&gt; <span class="hljs-title">call</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">int</span> age = <span class="hljs-number">20</span>;</span><br><span class="line">                <span class="hljs-keyword">if</span>(s.length() &gt; <span class="hljs-number">2</span>) &#123;<span class="hljs-comment">//名字长度大于2的年龄设为10</span></span><br><span class="line">                    age = <span class="hljs-number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">return</span> Observable.just(<span class="hljs-keyword">new</span> User(s, age));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="hljs-comment">//将age &lt;= 10的事件过滤掉</span></span><br><span class="line">        .filter(<span class="hljs-keyword">new</span> Func1&lt;User, Boolean&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">call</span><span class="hljs-params">(User user)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> user.getAge() &gt; <span class="hljs-number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(<span class="hljs-keyword">new</span> Action1&lt;User&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(User user)</span> </span>&#123;</span><br><span class="line">	             Log.d(<span class="hljs-string">"RxJava"</span> user.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>上面的例子中，会将年龄小于等于10的用户数据过滤掉不进行处理，因此在<code>filter</code>的<code>call</code>方法中进行判断，年龄小于等于10的数据返回false即可将该数据过滤掉。</p>
<h2 id="选取指定数量数据take"><a href="#选取指定数量数据take" class="headerlink" title="选取指定数量数据take()"></a>选取指定数量数据take()</h2><p>上面的例子中如果我只想对符合条件的前两个数据进行处理该怎么做呢，这时我们可以使用<code>take()</code>操作符来实现<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123;<span class="hljs-string">"张三"</span>, <span class="hljs-string">"李四"</span>, <span class="hljs-string">"王麻子"</span>, <span class="hljs-string">"赵六"</span>&#125;;</span><br><span class="line">Observable.from(array)</span><br><span class="line">        <span class="hljs-comment">//将一个事件数据变换为另一种事件输出的Observable</span></span><br><span class="line">        .flatMap(<span class="hljs-keyword">new</span> Func1&lt;String, Observable&lt;User&gt;&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;User&gt; <span class="hljs-title">call</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">int</span> age = <span class="hljs-number">20</span>;</span><br><span class="line">                <span class="hljs-keyword">if</span>(s.length() &gt; <span class="hljs-number">2</span>) &#123;</span><br><span class="line">                    age = <span class="hljs-number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">return</span> Observable.just(<span class="hljs-keyword">new</span> User(s, age));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="hljs-comment">//将age &lt;= 10的事件过滤掉</span></span><br><span class="line">        .filter(<span class="hljs-keyword">new</span> Func1&lt;User, Boolean&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">call</span><span class="hljs-params">(User user)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> user.getAge() &gt; <span class="hljs-number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="hljs-comment">//只取符合条件的前两个结果</span></span><br><span class="line">        .take(<span class="hljs-number">2</span>)</span><br><span class="line">        .subscribe(<span class="hljs-keyword">new</span> Action1&lt;User&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(User user)</span> </span>&#123;</span><br><span class="line">	            Log.d(<span class="hljs-string">"RxJava"</span> user.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="doOnNext"><a href="#doOnNext" class="headerlink" title="doOnNext"></a>doOnNext</h2><p>上面的例子中如果我们取到前两个符合条件的数据进行处理之前，我们要先进行缓存处理，这个时候我们就可以使用<code>doOnNext</code>操作符进行处理，实现如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">String[] array = &#123;<span class="hljs-string">"张三"</span>, <span class="hljs-string">"李四"</span>, <span class="hljs-string">"王麻子"</span>, <span class="hljs-string">"赵六"</span>&#125;;</span><br><span class="line">Observable.from(array)</span><br><span class="line">        <span class="hljs-comment">//将一个事件数据变换为另一种事件输出的Observable</span></span><br><span class="line">        .flatMap(<span class="hljs-keyword">new</span> Func1&lt;String, Observable&lt;User&gt;&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;User&gt; <span class="hljs-title">call</span><span class="hljs-params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">int</span> age = <span class="hljs-number">20</span>;</span><br><span class="line">                <span class="hljs-keyword">if</span>(s.length() &gt; <span class="hljs-number">2</span>) &#123;</span><br><span class="line">                    age = <span class="hljs-number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">return</span> Observable.just(<span class="hljs-keyword">new</span> User(s, age));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="hljs-comment">//将age &lt;= 10的事件过滤掉</span></span><br><span class="line">        .filter(<span class="hljs-keyword">new</span> Func1&lt;User, Boolean&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">call</span><span class="hljs-params">(User user)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> user.getAge() &gt; <span class="hljs-number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="hljs-comment">//只取符合条件的前两个结果</span></span><br><span class="line">        .take(<span class="hljs-number">2</span>)</span><br><span class="line">        <span class="hljs-comment">//在subscribe执行之前进行额外的操作，比如将数据保存到磁盘上</span></span><br><span class="line">        .doOnNext(<span class="hljs-keyword">new</span> Action1&lt;User&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(User user)</span> </span>&#123;</span><br><span class="line">                save(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(<span class="hljs-keyword">new</span> Action1&lt;User&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(User user)</span> </span>&#123;</span><br><span class="line">	            Log.d(<span class="hljs-string">"RxJava"</span> user.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>比如我们有一个同步请求网络数据的服务，在<code>Android</code>中使用<code>RxJava</code>进行处理该怎么做呢？我们可以使用<code>subscribeOn()</code>指定被观察者(事件)的运行线程，使用<code>observeOn()</code>指定观察者(订阅者)的运行线程。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="hljs-string">"查询条件"</span>)</span><br><span class="line">    .subscribeOn(Schedulers.io())<span class="hljs-comment">//在子线程中进行查询操作</span></span><br><span class="line">    .flatMap(<span class="hljs-keyword">new</span> Func1&lt;String, Observable&lt;Result&gt;&gt;() &#123;</span><br><span class="line">         <span class="hljs-meta">@Override</span></span><br><span class="line">         <span class="hljs-function"><span class="hljs-keyword">public</span> Observable&lt;Result&gt; <span class="hljs-title">call</span><span class="hljs-params">(String whereClause)</span> </span>&#123;</span><br><span class="line">             Result result = queryResult(whereClause);</span><br><span class="line">             <span class="hljs-keyword">return</span> Observable.just(result);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">    .observeOn(AndroidSchedulers.mainThread())<span class="hljs-comment">//在UI线程中处理结果</span></span><br><span class="line">    .subscribe(<span class="hljs-keyword">new</span> Action1&lt;Result&gt;() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Result result)</span> </span>&#123;</span><br><span class="line">	        Log.d(<span class="hljs-string">"RxJava"</span> result.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面这些是我目前使用<code>RxJava</code>用到的一些功能函数和操作符，后面学习了其他操作符之后，我会用另外的一篇博文记录下来。</p>
<p>write by 老胡<br>    2016年10月30日</p>
<p>本文章发表在 <a href="ittiger.cn">独立博客 ittiger.cn</a> 和 <a href="http://blog.csdn.net/huyongl1989" target="_blank" rel="noopener">个人CSDN博客</a></p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> RxJava </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[透过Retrofit使用看其源码设计模式]]></title>
      <url>http://ittiger.cn/Retrofit-Source-Design-Pattern.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章我将从Retrofit的基本用法出发，透过其使用步骤，一步步的探究Retrofit的实现原理及其源码的设计模式。这篇文章可能会将Retrofit中用到的设计模式和其实现原理穿插着写，所以各位同学也可以选择性的阅读。而对于Retrofit具体使用还不太清楚的同学可以去看的另一篇文章<a href="http://ittiger.cn/2016/08/29/Retrofit2%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/">Retrofit2的使用介绍</a></p>
<a id="more"></a>
<h2 id="Retrofit基本用法"><a href="#Retrofit基本用法" class="headerlink" title="Retrofit基本用法"></a>Retrofit基本用法</h2><p>我以用户登录作为示例：</p>
<h3 id="声明接口"><a href="#声明接口" class="headerlink" title="声明接口"></a>声明接口</h3><p>首先我们先定义一个登录服务接口<code>LoginService</code>，如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LoginService</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@FormUrlEncoded</span></span><br><span class="line">    <span class="hljs-meta">@POST</span>(<span class="hljs-string">"login"</span>)</span><br><span class="line">    <span class="hljs-function">Call&lt;String&gt; <span class="hljs-title">login</span><span class="hljs-params">(@Field(<span class="hljs-string">"username"</span>)</span> String name, @<span class="hljs-title">Field</span><span class="hljs-params">(<span class="hljs-string">"password"</span>)</span> String password)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="创建Retrofit对象"><a href="#创建Retrofit对象" class="headerlink" title="创建Retrofit对象"></a>创建Retrofit对象</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="hljs-keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="hljs-string">"http://ittiger.cn"</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoginService service = retrofit.create(LoginService.class);</span><br><span class="line">Call&lt;User&gt; call = service.login(<span class="hljs-string">"user"</span>, <span class="hljs-string">"pwd"</span>);</span><br><span class="line">call.execute()或call.enqueue()</span><br></pre></td></tr></table></figure>
<h2 id="Retrofit关键类"><a href="#Retrofit关键类" class="headerlink" title="Retrofit关键类"></a>Retrofit关键类</h2><p>在讲Retrofit实现原理之前，我先说下Retrofit里面涉及到几个关键类都是干什么用的</p>
<ol>
<li><code>Retorift：</code> 负责配置请求过程中的基本参数，如：请求地址，结果转换器，自定义OKHttpClient等，同时还会生成请求接口对象</li>
<li><code>Call：</code> 网络请求执行者(<code>Retrofit.Call</code>)，比如：上面示例中最后调用<code>login</code>方法得到的<code>Call</code>对象就是此接口的实例</li>
<li><code>OkHttpCall：</code> 此类是<code>Retrofit.Call</code>接口的实现，示例中最后调用<code>login</code>方法得到的<code>Call</code>对象就是此类的实例。但是其底层网络请求执行都是通过<code>OkHttp.Call</code>接口间接执行的，也就是说<code>OkHttpCall</code>是对<code>OkHttp.Call</code>网络请求功能的封装。</li>
<li><code>Converter &amp; Converter.Factory：</code> 分别负责网络请求结果转换以及生成<code>Converter</code>转换器</li>
<li><code>CallAdapter &amp; CallAdapter.Factory：</code> 分别负责对<code>Retrofit.Call实例(OkHttpCall)</code>进行适配及生成<code>CallAdapter</code>适配器</li>
<li><code>Platform：</code> 确定<code>Retrofit</code>当前运行平台，以及确定当前平台默认的的<code>CallAdapter.Factory</code>和<code>Executor</code></li>
<li><code>ExecutorCallAdapterFactory：</code> Android平台下的默认<code>CallAdapter.Factory</code>实现</li>
<li><code>ServiceMethod：</code> 解析接口服务所有注解、生成请求对象<code>Request</code>、解析请求结果<code>Response</code></li>
<li><code>ParameterHandler：</code> 服务接口方法(<code>login()</code>)参数解析处理器，配合<code>ServiceMethod</code>进行服务接口参数注解解析</li>
<li><code>RequestBuilder：</code> 根据参数和<code>URL</code>构造请求需要的<code>OkHttp.Request</code>对象</li>
</ol>
<p>以上就是Retrofit源码实现中比较关键的10个类及其相关作用</p>
<h2 id="使用流程-gt-gt-实现-gt-gt-设计模式"><a href="#使用流程-gt-gt-实现-gt-gt-设计模式" class="headerlink" title="使用流程 &gt;&gt; 实现 &gt;&gt; 设计模式"></a>使用流程 &gt;&gt; 实现 &gt;&gt; 设计模式</h2><h2 id="Builder模式创建Retrofit"><a href="#Builder模式创建Retrofit" class="headerlink" title="Builder模式创建Retrofit"></a>Builder模式创建Retrofit</h2><h3 id="Retrofit场景"><a href="#Retrofit场景" class="headerlink" title="Retrofit场景"></a>Retrofit场景</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="hljs-keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="hljs-string">"http://ittiger.cn"</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<p>上面代码的对象创建方式看着是不是似曾相识，看着很眼熟，没错，Android里面的Dialog的创建就是使用的这种方式：<code>Builder模式</code></p>
<h3 id="Builder模式定义"><a href="#Builder模式定义" class="headerlink" title="Builder模式定义"></a>Builder模式定义</h3><p>将一个复杂对象的构建与它的表示分离，使得同样的构建可以创建不同的表示</p>
<h3 id="Builder模式使用场景"><a href="#Builder模式使用场景" class="headerlink" title="Builder模式使用场景"></a>Builder模式使用场景</h3><ol>
<li>相同的方法不同的执行顺序产生不同的结果</li>
<li>多个部件都可以装配到一个对象中，但是产生的结果不同</li>
</ol>
<h3 id="Builder模式类图"><a href="#Builder模式类图" class="headerlink" title="Builder模式类图"></a>Builder模式类图</h3><p><img src="/img/design_builder.bmp" alt></p>
<h3 id="Retrofit中的Builder模式"><a href="#Retrofit中的Builder模式" class="headerlink" title="Retrofit中的Builder模式"></a>Retrofit中的Builder模式</h3><ol>
<li><code>Retrofit</code>中的<code>Builder模式</code>是简化版的<code>Builder模式</code>，省略了抽象建造者和指挥者</li>
<li>不同的配置会对<code>Retrofit</code>产生不同的影响，如果通过<code>addCallAdapterFactory()</code>配置<code>CallAdapterFactory</code>和不配置<code>CallAdapterFactory</code>会对<code>Retrofit</code>产生完全不同的影响。</li>
<li>如果<code>Retrofit</code>中使用构造方法的方式创建对象，则需要实现多个不同参数的构造方法，而使用构造方法创建对象时如果参数太多，很多时候参数代表的意思是不太理解的，总归来说就是创建过程不直观。</li>
</ol>
<h3 id="Builder模式优缺点"><a href="#Builder模式优缺点" class="headerlink" title="Builder模式优缺点"></a>Builder模式优缺点</h3><ul>
<li>优点：<ol start="2">
<li>不需要知道产品内部的组成细节，产品与创建过程解耦</li>
<li>分步组装产品，使得产品的创建过程更精细更清晰</li>
<li>容易扩展，新产品只需要新建一个建造者即可</li>
</ol>
</li>
<li>缺点：<ol>
<li>Builder模式创建的产品差异性小，使用范围受限制</li>
<li>不同的产品会产生多个建造者和指挥者</li>
</ol>
</li>
</ul>
<h2 id="Retrofit创建流程-gt-gt-Platform"><a href="#Retrofit创建流程-gt-gt-Platform" class="headerlink" title="Retrofit创建流程 &gt;&gt; Platform"></a>Retrofit创建流程 &gt;&gt; Platform</h2><p>在创建Retrofit过程中有这样一行代码：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="hljs-keyword">new</span> Retrofit.Builder()</span><br><span class="line">...</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure></p>
<p>从代码可以看到在创建<code>Retrofit</code>时得先根据<code>Retrofit.Builder</code>内部类的默认构造方法<code>Retrofit.Builder()</code>创建一个<code>Builder</code>对象，所以我们来看看这个默认构造方法里都做了些什么事：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">this</span>(Platform.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>OK，我们再来看看我们前面说到的<code>Platform</code>这个平台类的静态方法<code>get()</code><br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//静态实例对象，类加载就确定了</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Platform PLATFORM = findPlatform();</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">static</span> Platform <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> PLATFORM;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Platform <span class="hljs-title">findPlatform</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="hljs-string">"android.os.Build"</span>);</span><br><span class="line">      <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT != <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Android();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="hljs-string">"java.util.Optional"</span>);</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Java8();</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">      Class.forName(<span class="hljs-string">"org.robovm.apple.foundation.NSObject"</span>);</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IOS();</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Platform();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码我们可以很明确的知道，在<code>Platform</code>类加载的时候它就通过反射的机制确定了当前运行的平台是属于哪一个，是<code>Android</code>，是<code>Java8</code>还是<code>IOS</code>，并生成对应的平台类的实例，<code>get()</code>方法是用来获取当前的平台类的实例。</p>
<p>目前，我们只关注<code>Android</code>平台下的<code>Platform</code>实例，我们也来看看<code>Android</code>平台类中做了些什么：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Android</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Platform</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Executor <span class="hljs-title">defaultCallbackExecutor</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MainThreadExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span> CallAdapter.<span class="hljs-function">Factory <span class="hljs-title">defaultCallAdapterFactory</span><span class="hljs-params">(Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainThreadExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Executor</span> </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Handler handler = <span class="hljs-keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">      <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        handler.post(r);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>Android</code>类中重写了<code>Platform</code>类的两个方法<code>defaultCallbackExecutor()</code>和<code>defaultCallAdapterFactory(Executor callbackExecutor)</code></p>
<ol>
<li>前者就是用来返回当前平台下默认的<code>Executor</code>，这<code>Android</code>平台下就是<code>MainThreadExecutor</code>这个类的实例，可以看到这个执行器主要就是用来进行线程切换的，因为我们知道安卓平台下所有的UI操作都必须在UI线程中执行。</li>
<li>后者就是用来返回当前平台下默认的<code>CallAdapter.Factory</code></li>
<li>当然你也可以不使用这两个默认值，都可以在创建<code>Retrofit</code>过程中自定义配置自己需要的相关实例</li>
</ol>
<h2 id="Retrofit创建流程-gt-gt-ExecutorCallAdapterFactory"><a href="#Retrofit创建流程-gt-gt-ExecutorCallAdapterFactory" class="headerlink" title="Retrofit创建流程 &gt;&gt; ExecutorCallAdapterFactory"></a>Retrofit创建流程 &gt;&gt; ExecutorCallAdapterFactory</h2><p>看完<code>Platform</code>之后紧接着我们再来看看<code>Android</code>平台下默认的<code>CallAdapter.Factory</code>实现<code>ExecutorCallAdapterFactory</code>都做了些什么，这里只贴关键代码：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CallAdapter</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Factory</span> </span>&#123;</span><br><span class="line">	    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations,</span><br><span class="line">	        Retrofit retrofit);</span><br><span class="line">	    ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExecutorCallAdapterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CallAdapter</span>.<span class="hljs-title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">final</span> Executor callbackExecutor;<span class="hljs-comment">//对应默认的MainThreadExecutor</span></span><br><span class="line"></span><br><span class="line">  ExecutorCallAdapterFactory(Executor callbackExecutor) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">  <span class="hljs-keyword">public</span> CallAdapter&lt;Call&lt;?&gt;&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CallAdapter&lt;Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Type <span class="hljs-title">responseType</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> &lt;R&gt; <span class="hljs-function">Call&lt;R&gt; <span class="hljs-title">adapt</span><span class="hljs-params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大家看源码可以发现<code>CallAdapter.Factory</code>工厂是通过<code>get()</code>方法来创建<code>CallAdapter</code>的，所以<code>ExecutorCallAdapterFactory</code>关键代码也是在<code>get()</code>方法的实现上，上面的代码中我们可以看到<code>get()</code>方法返回一个<code>CallAdapter</code>实例，这就是我前面介绍关键类作用时说到的<code>CallAdapter.Factory</code>主要负责生成<code>CallAdapter</code>的实现。</p>
<p>该类中，我们从其类的命名以及代码实现结构上来看，<code>ExecutorCallAdapterFactory</code>其实也使用了一种设计模式，那就是<code>工厂方法模式</code>，其实<code>Retrofit</code>中还有一个地方也使用了<code>工厂方法模式</code>，那就是<code>Converter &amp; Converter.Factory</code>它的实现方式和<code>CallAdapter &amp; CallAdapter.Factory</code>是一样样的。</p>
<h2 id="工厂方式模式-创建CallAdapter-amp-Converter"><a href="#工厂方式模式-创建CallAdapter-amp-Converter" class="headerlink" title="工厂方式模式(创建CallAdapter &amp; Converter)"></a>工厂方式模式(创建CallAdapter &amp; Converter)</h2><p>本文我就已<code>CallAdapter</code>进行举例，看懂<code>CallAdapter</code>的创建原理之后，再看<code>Converter</code>的创建也就比较简单，都是一样的道理。</p>
<h3 id="Retrofit场景-1"><a href="#Retrofit场景-1" class="headerlink" title="Retrofit场景"></a>Retrofit场景</h3><p><code>Retrofit</code>中使用工厂方式模式的场景我在前面讲<code>ExecutorCallAdapterFactory</code>实现的时候已经讲过了，这里就不重复举例了，大家可以对照着源码看下。</p>
<h3 id="工厂方法模式定义"><a href="#工厂方法模式定义" class="headerlink" title="工厂方法模式定义"></a>工厂方法模式定义</h3><p>一个用于创建对象的接口，让子类决定实例化哪个类</p>
<h3 id="工厂方法模式使用场景"><a href="#工厂方法模式使用场景" class="headerlink" title="工厂方法模式使用场景"></a>工厂方法模式使用场景</h3><ol>
<li>不需要知道其具体的类名，只需要知道生成它的工厂</li>
<li>一个类通过其子类来决定创建哪个对象</li>
</ol>
<h3 id="工厂方法模式类图"><a href="#工厂方法模式类图" class="headerlink" title="工厂方法模式类图"></a>工厂方法模式类图</h3><p><img src="/img/design_factory.bmp" alt></p>
<h3 id="Retrofit中的工厂方法"><a href="#Retrofit中的工厂方法" class="headerlink" title="Retrofit中的工厂方法"></a>Retrofit中的工厂方法</h3><ol>
<li><code>Retrofit</code>中使用工厂方法模式可以讲<code>CallAdapter</code>的创建与具体实现充分解耦，对于创建我们只需要知道其工厂即可，不需要关注是如何实现</li>
<li>所以我们可以通过<code>addCallAdapterFactory()</code>和<code>addConverterFactory()</code>很方便的自定义我们自己所需要的适配器工厂和数据转换工厂</li>
<li>通过<code>addCallAdapterFactory()</code>可以很方便的让<code>Retrofit</code>支持<code>RxJava</code>特性，而通过<code>addConverterFactory()</code>可以自定义配置们想要的转换器，让我们可以将请求数据结果转换成我们想要的任意类型。</li>
</ol>
<p>这些就是<code>Retrofit</code>使用工厂方法模式带来的好处。</p>
<h3 id="工厂方法模式优缺点"><a href="#工厂方法模式优缺点" class="headerlink" title="工厂方法模式优缺点"></a>工厂方法模式优缺点</h3><ul>
<li>优点<ol>
<li>只关注产品工厂即可，不需要关注产品如何创建，由工厂确定如何创建</li>
<li>扩展性好，新增产品时，只需要新增一个具体工厂和具体产品</li>
</ol>
</li>
<li>缺点<ol>
<li>新增产品时，需要新增具体工厂和具体产品类，使系统变得庞大</li>
<li>系统中加入抽象层，增加了系统的抽象性和理解难度</li>
</ol>
</li>
</ul>
<h2 id="适配器模式-gt-gt-CallAdapter"><a href="#适配器模式-gt-gt-CallAdapter" class="headerlink" title="适配器模式 &gt;&gt; CallAdapter"></a>适配器模式 &gt;&gt; CallAdapter</h2><h3 id="Retrofit场景-2"><a href="#Retrofit场景-2" class="headerlink" title="Retrofit场景"></a>Retrofit场景</h3><p>先来看看<code>CallAdapter</code>在<code>Retrofit</code>中的使用场景<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CallAdapter</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> Type <span class="hljs-title">responseType</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> &lt;R&gt; <span class="hljs-function">Call&lt;R&gt; <span class="hljs-title">adapt</span><span class="hljs-params">(Call&lt;R&gt; call)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//ExecutorCallAdapterFactory中生成CallAdapter实例</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CallAdapter&lt;Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Type <span class="hljs-title">responseType</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> &lt;R&gt; <span class="hljs-function">Call&lt;R&gt; <span class="hljs-title">adapt</span><span class="hljs-params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>前面讲到<code>ExecutorCallAdapterFactory</code>会生成一个<code>CallAdapter</code>实例。而<code>CallAdapter</code>这个名字看着是不是也很眼熟，也有种似曾相识的感觉，没错，<code>CallAdapter</code>与我们在<code>Android</code>中使用<code>ListView</code>或<code>RecyclerView</code>时经常用到的各种<code>Adapter</code>一样也是一个适配器。</p>
<p>那<code>CallAdapter</code>是来适配什么的呢？</p>
<p>还记得前面介绍关键类的时候说到的<code>OkHttpCall</code>吗？<code>CallAdapter</code>就是来适配<code>OkHttpCall</code>实例的，结合上面的代码来说的话在调用<code>CallAdapter.adapt</code>方法时<code>OkHttpCall</code>实例会作为参数传递给<code>adapt</code>方法从而交给<code>CallAdapter</code>去进行适配。</p>
<p>在我前面举的登录示例中，我们调用<code>login()</code>方法得到的<code>Call</code>实例就是<code>CallAdapter</code>适配<code>OkHttpCall</code>之后得到的一个新<code>Call</code>实例对象，至于为什么是这样，我后面会一一讲解，各位看官不要离开  </p>
<p>所以<code>Retrofit</code>在这个地方又使用了一种设计模式：<code>适配器模式</code></p>
<h3 id="适配器模式定义"><a href="#适配器模式定义" class="headerlink" title="适配器模式定义"></a>适配器模式定义</h3><p>将一个类的接口变成客户端所需要的另一个接口，从而使原本因接口不匹配而无法一起工作的两个类可以在一起工作</p>
<h3 id="适配器模式使用场景"><a href="#适配器模式使用场景" class="headerlink" title="适配器模式使用场景"></a>适配器模式使用场景</h3><ol>
<li>需要复用现有类，而现有类不符合系统需求</li>
<li>需要一个统一的输出接口，而输入端类型不可预知</li>
</ol>
<h3 id="适配器模式类图"><a href="#适配器模式类图" class="headerlink" title="适配器模式类图"></a>适配器模式类图</h3><p><img src="/img/design_adapter.bmp" alt></p>
<h3 id="Retrofit中的适配器模式"><a href="#Retrofit中的适配器模式" class="headerlink" title="Retrofit中的适配器模式"></a>Retrofit中的适配器模式</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ExecutorCallAdapterFactory中生成CallAdapter实例</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CallAdapter&lt;Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Type <span class="hljs-title">responseType</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> &lt;R&gt; <span class="hljs-function">Call&lt;R&gt; <span class="hljs-title">adapt</span><span class="hljs-params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p><code>Android</code>平台下默认的<code>CallAdapter</code>会将<code>OkHttpCall</code> 和 <code>MainThreadExecutor</code>两个实例对象适配成一个新的<code>Call</code>实例，这个新的<code>Call</code>实例在执行过程中就具备了切换到UI线程的功能。</p>
<p>那<code>Retrofit</code>在这个地方为什么要使用适配器模式将<code>OkHttpCall</code>进行适配了，直接拿过来用不就可以了吗？</p>
<p>前面讲过<code>OkHttpCall</code>仅仅只是对<code>OkHttp.Call</code>执行网络请求操作的封装，没有其他功能，也就是说<code>OkHttpCall</code>也只有网络请求的功能，而<code>Retrofit</code>是支持多个平台的（安卓，Java8，IOS，甚至包括支持RxJava特性），而不同的平台可能具有不同的特性。</p>
<p>如果在请求过程中需要用到这些特性的话，那么单靠<code>OkHttp.Call</code>是无法完成的，而如果在其他地方柔和进这些特性的支持可能就会使得框架结构不那么严谨平台解耦性比较差，甚至有可能会增加更多的接口。</p>
<p><code>Retrofit</code>通过使用适配器模式将平台特性与<code>OkHttpCall</code>适配成一个最终我们需要的<code>Call</code>实例，这样的话我们在使用过程中只需要关注最后拿到的<code>Call</code>对象，而不需要关注底层这个<code>Call</code>实例到底是什么样的，这也就为我们支持更多的特性提供了可能。比如对RxJava特性的支持，我们只需要提供一个支持<code>RxJava</code>特性的<code>CallAdapter</code>适配器即可，所以我们就可以通过<code>addCallAdapterFactory()</code>配置我们提供的支持<code>RxJava</code>特性的<code>CallAdapter.Factory</code></p>
<h3 id="适配器模式优缺点"><a href="#适配器模式优缺点" class="headerlink" title="适配器模式优缺点"></a>适配器模式优缺点</h3><ul>
<li>优点<ol>
<li>复用性好，引入适配器类来重用适配者类，无需修改原有代码</li>
<li>增加类的透明性，将适配过程封装在适配器类中，对使用者来说相对透明</li>
<li>灵活性扩展性好，通过配置可以随时更换适配器 </li>
</ol>
</li>
<li>缺点<ol>
<li>使用适配器会使系统整体不好把握，调的是A接口，却被适配成了B接口的实现</li>
</ol>
</li>
</ul>
<h2 id="静态代理模式-gt-gt-ExecutorCallbackCall"><a href="#静态代理模式-gt-gt-ExecutorCallbackCall" class="headerlink" title="静态代理模式 &gt;&gt;  ExecutorCallbackCall"></a>静态代理模式 &gt;&gt;  ExecutorCallbackCall</h2><h3 id="Retrofit场景-3"><a href="#Retrofit场景-3" class="headerlink" title="Retrofit场景"></a>Retrofit场景</h3><p>还是先来看看<code>Retrofit</code>中使用<code>ExecutorCallbackCall</code>的场景<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ExecutorCallAdapterFactory中生成CallAdapter实例</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CallAdapter&lt;Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> &lt;R&gt; <span class="hljs-function">Call&lt;R&gt; <span class="hljs-title">adapt</span><span class="hljs-params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>在上面<code>CallAdapter</code>实现中，可以发现它将<code>OkHttpCall</code>适配成了一个新的<code>Call</code>实例：<code>ExecutorCallbackCall</code>，所以我们接着看看<code>ExecutorCallbackCall</code>的具体实现代码<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExecutorCallbackCall</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Call</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> Executor callbackExecutor;<span class="hljs-comment">//Android平台下的Executor：MainThreadExecutor</span></span><br><span class="line">    <span class="hljs-keyword">final</span> Call&lt;T&gt; delegate;<span class="hljs-comment">//网络实际执行者OkHttpCall实例</span></span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">      <span class="hljs-keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">      <span class="hljs-keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (callback == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">      delegate.enqueue(<span class="hljs-keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(Call&lt;T&gt; call, <span class="hljs-keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">          <span class="hljs-comment">//Android平台下此处进行了线程切换</span></span><br><span class="line">          callbackExecutor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">              <span class="hljs-keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">                callback.onFailure(ExecutorCallbackCall.<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Canceled"</span>));</span><br><span class="line">              &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                callback.onResponse(ExecutorCallbackCall.<span class="hljs-keyword">this</span>, response);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(Call&lt;T&gt; call, <span class="hljs-keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">          <span class="hljs-comment">//Android平台下此处进行了线程切换</span></span><br><span class="line">          callbackExecutor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">              callback.onFailure(ExecutorCallbackCall.<span class="hljs-keyword">this</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isExecuted</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> delegate.isExecuted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Response&lt;T&gt; <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> delegate.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cancel</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">      delegate.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCanceled</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> delegate.isCanceled();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"CloneDoesntCallSuperClone"</span>) <span class="hljs-comment">// Performing deep clone.</span></span><br><span class="line">    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Call&lt;T&gt; <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, delegate.clone());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Request <span class="hljs-title">request</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> delegate.request();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到我们通过<code>login()</code>方法拿到<code>Call</code>实例(也就是<code>ExecutorCallbackCall</code>)之后，在执行网络请求时，在<code>ExecutorCallbackCall</code>的实现中其实都是将具体操作委托给<code>OkHttpCall</code>在执行。所以<code>Retrofit</code>在<code>ExecutorCallbackCall</code>中又使用了一种设计模式：<code>静态代理模式</code></p>
<h3 id="静态代理模式定义"><a href="#静态代理模式定义" class="headerlink" title="静态代理模式定义"></a>静态代理模式定义</h3><p>为其他对象提供一种代理以控制对这个对象的访问</p>
<h3 id="静态代理模式使用场景"><a href="#静态代理模式使用场景" class="headerlink" title="静态代理模式使用场景"></a>静态代理模式使用场景</h3><p>无法访问或不想直接访问某个对象</p>
<h3 id="静态代理模式类图"><a href="#静态代理模式类图" class="headerlink" title="静态代理模式类图"></a>静态代理模式类图</h3><p><img src="/img/design_proxy.bmp" alt></p>
<h3 id="Retrofit中的静态代理"><a href="#Retrofit中的静态代理" class="headerlink" title="Retrofit中的静态代理"></a>Retrofit中的静态代理</h3><p><code>Retrofit</code>中使用<code>ExecutorCallbackCall</code>代理<code>OkHttpCall</code>具体请求操作，可以将<code>Call</code>的使用与底层实现进行解耦，不用关心底层具体请求接口的实现，所以如果将来出现了一个比<code>OkHttp</code>更好的网络请求库，我们完全可以将<code>OkHttp</code>替换掉，即便这样也不会影响外部API接口在项目中的使用。</p>
<h3 id="静态代理的优缺点"><a href="#静态代理的优缺点" class="headerlink" title="静态代理的优缺点"></a>静态代理的优缺点</h3><ul>
<li>优点<ol>
<li>协调调用者与被调用者，降低系统耦合度</li>
<li>减小外部接口与内部接口实现的关联，降低耦合</li>
</ol>
</li>
<li>缺点<ol>
<li>委托对象与代理对象需要实现相同的接口，当接口类增加方法时，除了所有实现类需要增加该方法外，所有代理类也需要实现此方法，增加了维护难度</li>
<li>一个代理类只能代理一种类型的对象</li>
</ol>
</li>
</ul>
<h2 id="动态代理-gt-gt-Retrofit-create"><a href="#动态代理-gt-gt-Retrofit-create" class="headerlink" title="动态代理 &gt;&gt; Retrofit.create()"></a>动态代理 &gt;&gt; Retrofit.create()</h2><p>先看下<code>Retrofit.create()</code>方法的具体实现代码：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), </span><br><span class="line">        <span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;, <span class="hljs-keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">      <span class="hljs-meta">@Override</span> </span><br><span class="line">      <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object... args)</span></span></span><br><span class="line"><span class="hljs-function">          <span class="hljs-keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        ServiceMethod serviceMethod = loadServiceMethod(method);</span><br><span class="line">        OkHttpCall okHttpCall = <span class="hljs-keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">        <span class="hljs-keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>相信很多人在刚开始用<code>Retrofit</code>时都会有一点疑问，我们明明声明的是接口，为什么通过<code>create()</code>方法就能创建出一个对象实例呢？<br>通过上面的实现源码我们找到了答案，那就是使用了JDK中提供的动态代理机制，它会在运行过程中为我们声明的服务接口动态的创建出一个代理对象，以便实现我们的请求操作。我个人认为这是<code>Retrofit</code>框架得以实现的一个核心之处，另外一个核心之处就是其完善的注解机制，关于其注解本文就不说，主要就是一些注解的声明和解析，比较简单，感兴趣的可以去看看。</p>
<p>上面的源码中我们可以看到，运行过程中得到服务接口的代理对象之后，当我们调用<code>login()</code>这样的接口方法时，其实真实执行的是上面源码中写的<code>invoke()</code>方法，所以我们调用<code>login()</code>方法时其实是执行了如下三步：</p>
<ol>
<li>根据反射得到接口方法<code>Method</code>对象生成对应的<code>ServiceMethod</code>对象，该对象会对该声明方法上的所有方法注解、参数注解进行解析以得到一个请求所需要的所有信息</li>
<li>得到<code>ServiceMethod</code>对象之后，会根据该对象和方法调用时传递的参数生成<code>OkHttpCall</code>对象，也就是具体的网络实施者</li>
<li>将<code>OkHttpCall</code>作为<code>CallAdapter</code>适配器中<code>adapt()</code>方法的参数传递给<code>CallAdapter</code>进行适配，最后得到我们所需要的<code>ExecutorCallbackCall</code>对象，也就是调用<code>login()</code>方法得到的<code>Call</code>实例对象</li>
</ol>
<h3 id="动态代理使用场景"><a href="#动态代理使用场景" class="headerlink" title="动态代理使用场景"></a>动态代理使用场景</h3><p>静态代理特点一个代理对应一种类型，如果有多个类需要代理则需要多个代理，而且维护成本高，而动态代理就是来解决此类问题</p>
<h3 id="动态代理特点"><a href="#动态代理特点" class="headerlink" title="动态代理特点"></a>动态代理特点</h3><p>运行期由JVM通过反射机制动态生成，可以代理多种类型，代码复用性高。但是只能代理Java接口，不能代理Java实现类。</p>
<h2 id="Call-enqueue-amp-Call-execute-实现"><a href="#Call-enqueue-amp-Call-execute-实现" class="headerlink" title="Call.enqueue() &amp; Call.execute()实现"></a>Call.enqueue() &amp; Call.execute()实现</h2><p>前面从<code>Retrofit</code>的配置、创建、调用接口方法得到<code>Call</code>实例，基本用法都已经讲的差不多了，现在我们来看基本用法的最后一步<code>Call.enqueue() &amp; Call.execute()</code></p>
<p>前面讲过调用接口方法比如<code>login()</code>时，<code>Android</code>平台下默认得到的是<code>ExecutorCallbackCall</code>实例，而<code>ExecutorCallbackCall</code>实例中执行网络请求的实际上又是<code>OkHttpCall</code>，所以我们来看<code>OkHttpCall</code>中的<code>Call.enqueue() &amp; Call.execute()</code>两个方法的实现，我以<code>Call.enqueue()</code>为例，另外一个大家可以自己去看看</p>
<p>下面是该方法实现的关键代码：</p>
<h3 id="OkHttpCall-enqueue"><a href="#OkHttpCall-enqueue" class="headerlink" title="OkHttpCall.enqueue()"></a>OkHttpCall.enqueue()</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    okhttp3.Call call;</span><br><span class="line">    Throwable failure;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Already executed."</span>);</span><br><span class="line">      executed = <span class="hljs-keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      call = rawCall;</span><br><span class="line">      failure = creationFailure;</span><br><span class="line">      <span class="hljs-keyword">if</span> (call == <span class="hljs-keyword">null</span> &amp;&amp; failure == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">	      <span class="hljs-comment">//如果okhttp3.Call为空，则先创建该实例</span></span><br><span class="line">          call = rawCall = createRawCall();</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          failure = creationFailure = t;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="hljs-comment">//又讲网络执行转交给okhttp3.Call实例来执行</span></span><br><span class="line">    call.enqueue(<span class="hljs-keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">      <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(okhttp3.Call call, okhttp3.Response rawResponse)</span></span></span><br><span class="line"><span class="hljs-function">          <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Response&lt;T&gt; response;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">	      <span class="hljs-comment">//将okhttp3.Response结果包装成Retrofit中的结果对象Response</span></span><br><span class="line">          response = parseResponse(rawResponse);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          callFailure(e);</span><br><span class="line">          <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        callSuccess(response);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(okhttp3.Call call, IOException e)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callFailure</span><span class="hljs-params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callSuccess</span><span class="hljs-params">(Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>前面介绍关键类时说过<code>OkHttpCall</code>底层网络执行其实是<code>OkHttp.Call</code>在执行，从上面的代码我们就可以看出来(代码关键地方我加了注释)，上面代码关键第一步是先创建一个<code>okhttp3.call</code>实例，所以我们同样看看创建<code>okhttp3.call</code>实例的代码是怎么实现的<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> okhttp3.<span class="hljs-function">Call <span class="hljs-title">createRawCall</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = serviceMethod.toRequest(args);</span><br><span class="line">    okhttp3.Call call = serviceMethod.callFactory.newCall(request);</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-keyword">return</span> call;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的<code>createRawCall()</code>方法实现我们可以发现，它会首先通过<code>ServiceMethod.toRequest()</code>方法生成一个<code>OkHttp.Request</code>对象(这部分代码比较简单，我就不细说了)，然后根据<code>ServiceMethod</code>中的成员变量<code>CallFactory</code>创建一个<code>okhttp3.Call</code>实例。但是这个<code>CallFactory</code>是怎么来的呢？其实我们可以猜到这个<code>CallFactory</code>实例就是<code>OkHttpClient</code>实例。但是我们还是看看<code>ServiceMethod</code>的创建过程</p>
<h3 id="ServiceMethod创建"><a href="#ServiceMethod创建" class="headerlink" title="ServiceMethod创建"></a>ServiceMethod创建</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//在Retrofit.create()方法实现的第一步就是通过loadServiceMethod()方法创建ServiceMethod，这是其实现</span></span><br><span class="line"><span class="hljs-function">ServiceMethod <span class="hljs-title">loadServiceMethod</span><span class="hljs-params">(Method method)</span> </span>&#123;</span><br><span class="line">    ServiceMethod result;</span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      <span class="hljs-keyword">if</span> (result == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        result = <span class="hljs-keyword">new</span> ServiceMethod.Builder(<span class="hljs-keyword">this</span>, method).build();</span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//下面是ServiceMethod相关关键代码</span></span><br><span class="line"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceMethod</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="hljs-keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">	ServiceMethod(Builder&lt;T&gt; builder) &#123;</span><br><span class="line">	    <span class="hljs-keyword">this</span>.callFactory = builder.retrofit.callFactory();</span><br><span class="line">	    <span class="hljs-keyword">this</span>.callAdapter = builder.callAdapter;</span><br><span class="line">	    <span class="hljs-keyword">this</span>.baseUrl = builder.retrofit.baseUrl();</span><br><span class="line">	    <span class="hljs-keyword">this</span>.responseConverter = builder.responseConverter;</span><br><span class="line">	    ...</span><br><span class="line">	  &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;</span><br><span class="line">		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">	      <span class="hljs-keyword">this</span>.retrofit = retrofit;</span><br><span class="line">	      <span class="hljs-keyword">this</span>.method = method;</span><br><span class="line">	      ...</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="hljs-function"><span class="hljs-keyword">public</span> ServiceMethod <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">			  <span class="hljs-comment">//创建CallAdapter</span></span><br><span class="line">		      callAdapter = createCallAdapter();</span><br><span class="line">		      <span class="hljs-comment">//得到请求结果返回类型，接口方法声明</span></span><br><span class="line">		      responseType = callAdapter.responseType();</span><br><span class="line">		      ...</span><br><span class="line">		      <span class="hljs-comment">//创建得到Converter结果转换器</span></span><br><span class="line">		      responseConverter = createResponseConverter();</span><br><span class="line">		      ...</span><br><span class="line">		      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServiceMethod&lt;&gt;(<span class="hljs-keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的<code>ServiceMethod</code>创建过程的相关代码可以看出，<code>ServiceMethod</code>中的实例变量<code>callFactory</code>其实是调用<code>Retrofit.callFactory()</code>方法所得，大家也可以看看上面我注释的<code>CallAdapter</code>和<code>Converter</code>的创建过程，所以我们再来看看这个方法的实现<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> okhttp3.Call.<span class="hljs-function">Factory <span class="hljs-title">callFactory</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> callFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到该方法只是返回了<code>Retrofit</code>中的<code>callFactory</code>实例，同样，我们再来看看<code>Retrofit</code>中的<code>callFactory</code>实例是怎么来的<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Retrofit</span> </span>&#123;</span><br><span class="line">	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	Retrofit(okhttp3.Call.Factory callFactory, ...) &#123;</span><br><span class="line">	    <span class="hljs-keyword">this</span>.callFactory = callFactory;</span><br><span class="line">	    ...</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">private</span> okhttp3.Call.Factory callFactory;</span><br><span class="line">		...</span><br><span class="line">		<span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">client</span><span class="hljs-params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">	      <span class="hljs-keyword">return</span> callFactory(checkNotNull(client, <span class="hljs-string">"client == null"</span>));</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">callFactory</span><span class="hljs-params">(okhttp3.Call.Factory factory)</span> </span>&#123;</span><br><span class="line">	      <span class="hljs-keyword">this</span>.callFactory = checkNotNull(factory, <span class="hljs-string">"factory == null"</span>);</span><br><span class="line">	      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="hljs-function"><span class="hljs-keyword">public</span> Retrofit <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">	      ...</span><br><span class="line">	      okhttp3.Call.Factory callFactory = <span class="hljs-keyword">this</span>.callFactory;</span><br><span class="line">	      <span class="hljs-keyword">if</span> (callFactory == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">	        callFactory = <span class="hljs-keyword">new</span> OkHttpClient();</span><br><span class="line">	      &#125;</span><br><span class="line">		  ...</span><br><span class="line">	      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Retrofit(callFactory, ...);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码，我们可以看出<code>Retrofit</code>中的<code>callFactory</code>实例就是我们使用的<code>OkHttpClient</code>实例，所以这就验证了我们前面猜测的<code>serviceMethod.callFactory</code>就是<code>OkHttpClient</code>实例的猜想。</p>
<p>Ok，回到我们前面将的<code>OkHttpCall.equeue()</code>方法的实现流程上来。</p>
<h3 id="请求结果解析"><a href="#请求结果解析" class="headerlink" title="请求结果解析"></a>请求结果解析</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">call.enqueue(<span class="hljs-keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">      <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(okhttp3.Call call, okhttp3.Response rawResponse)</span></span></span><br><span class="line"><span class="hljs-function">          <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Response&lt;T&gt; response;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">	      <span class="hljs-comment">//将okhttp3.Response结果包装成Retrofit中的结果对象Response</span></span><br><span class="line">          response = parseResponse(rawResponse);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          callFailure(e);</span><br><span class="line">          <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        callSuccess(response);</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建完<code>okhttp3.call</code>实例之后，调用该实现的<code>equeue()</code>方法开始执行网络请求，请求执行完成之后，会调用<code>parseResponse</code>方法，我们来看看这个方法实现的关键代码：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">Response&lt;T&gt; <span class="hljs-title">parseResponse</span><span class="hljs-params">(okhttp3.Response rawResponse)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ResponseBody rawBody = rawResponse.body();</span><br><span class="line">	...</span><br><span class="line">	<span class="hljs-comment">//上面省略的这段代码是对请求失败时的结果处理，大家可以自行查看源码</span></span><br><span class="line">	</span><br><span class="line">    ExceptionCatchingRequestBody catchingBody = <span class="hljs-keyword">new</span> ExceptionCatchingRequestBody(rawBody);</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">      T body = serviceMethod.toResponse(catchingBody);</span><br><span class="line">      <span class="hljs-keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">      catchingBody.throwIfCaught();</span><br><span class="line">      <span class="hljs-keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法中，当请求成功时，会调用<code>serviceMethod.toResponse()</code>这个方法，我们来看看这个方法又做了哪些事情：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">T <span class="hljs-title">toResponse</span><span class="hljs-params">(ResponseBody body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> responseConverter.convert(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很明显，上面方法中就直接调用了<code>ServiceMethod</code>中的<code>Converter</code>实例进行结果转换，也就是说在这个地方<code>Retrofit</code>会帮我们把网络请求结果转换成我们所需要的类型，转换成功之后会调用<code>Response.success(body, rawResponse)</code>将转换后的结果包装成<code>Retrofit</code>中的<code>Response</code>对象。</p>
<h3 id="获取配置的Converter"><a href="#获取配置的Converter" class="headerlink" title="获取配置的Converter"></a>获取配置的Converter</h3><p>问题又来了，上面的<code>Converter</code>是怎么来的呢？</p>
<p>在前面给出的<code>ServiceMethod</code>创建过程的代码块中，我对<code>ServiceMethod</code>中创建<code>Converter</code>实例的代码进行了注释，我们再回过头来看看这段代码：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//ServiceMethod.Buibler中的方法</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Converter&lt;ResponseBody, T&gt; <span class="hljs-title">createResponseConverter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">	  ...</span><br><span class="line">      <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">      &#125; <span class="hljs-keyword">catch</span> (RuntimeException e) &#123; <span class="hljs-comment">// Wide exception range because factories are user code.</span></span><br><span class="line">        <span class="hljs-keyword">throw</span> methodError(e, <span class="hljs-string">"Unable to create converter for %s"</span>, responseType);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//Retrofit中的方法</span></span><br><span class="line"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Converter&lt;ResponseBody, T&gt; <span class="hljs-title">responseBodyConverter</span><span class="hljs-params">(Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> nextResponseBodyConverter(<span class="hljs-keyword">null</span>, type, annotations);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Converter&lt;ResponseBody, T&gt; <span class="hljs-title">nextResponseBodyConverter</span><span class="hljs-params">(Converter.Factory skipPast,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">      Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="hljs-keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">          converterFactories.get(i).responseBodyConverter(type, annotations, <span class="hljs-keyword">this</span>);</span><br><span class="line">      <span class="hljs-keyword">if</span> (converter != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(builder.toString());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码我们可以看到会从<code>Retrofit</code>的<code>converterFactories</code>转换器工厂集合中去查找当前接口方法对应的转换器工厂。其实这也告诉我们可以在创建<code>Retrofit</code>时配置多个<code>Converter.Factory</code>转换器工厂，也就是说我们一个接口服务中如果声明的多个接口方法的返回值不一样时，我们可以针对性的配置多个不一样的结果转换器工厂去进行结果解析，而不用为了保持结果类型一致对接口进行其他处理。</p>
<p>上面创建<code>ServiceMethod</code>时得到<code>CallAdapter</code>的过程与得到<code>Converter</code>的过程基本一样，我就不赘述了。</p>
<p>到这里，<code>Retrofit</code>的实现原理、实现流程以及其源码实现过程中用到的设计模式就介绍完了。</p>
<p>内容好长，时间好长~~~~</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Retrofit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在线视频播放App的实现]]></title>
      <url>http://ittiger.cn/%E5%9C%A8%E7%BA%BF%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BEApp%E7%9A%84%E5%AE%9E%E7%8E%B0.html</url>
      <content type="html"><![CDATA[<p>前一段时间在公司项目上做了一个视频播放的功能，当时时间紧，做完之后感觉有些地方处理的不好，所以就基于当时实现的思路进行了一些改进，加上自己平时喜欢看新闻客户端里面的一些短视频，所以就用网易等客户端的视频数据完成了一个独立的视频播放APP，顺便巩固下其他的技术。</p>
<h2 id="主要使用的开源库"><a href="#主要使用的开源库" class="headerlink" title="主要使用的开源库"></a>主要使用的开源库</h2><p>Mosby(一个MVP框架)、RxJava、Retrofit2、ButterKnife、Glide、Systembartint、TigerDB、Material Design相关控件</p>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ol>
<li>列表中播放视频</li>
<li>列表滑动时如果正在播放视频，则列表中播放的视频自动切换为小窗口浮动播放</li>
<li>列表播放切换到全屏播放模式</li>
<li>视频播放时也添加了完整的暂停、播放等控制操作，也添加了视频播放进度，视频缓冲进度等显示功能</li>
<li>视频全屏播放时支持左右滑动实现视频的快进和后退，支持右边上下滑动调整播放音量，左边上下滑动调整播放器的亮度等手势控制操作  </li>
</ol>
<a id="more"></a>
<h2 id="播放器"><a href="#播放器" class="headerlink" title="播放器"></a>播放器</h2><ol>
<li>播放器采用<code>Android</code>中自带的<code>TextureView + MediaPlayer</code>实现，同时视频播放过程中因为涉及到列表、小窗口、全屏续播等问题，所以整个视频播放过程中，播放器采用的是全局单例模式实现，这样就可以达到无缝切换续播的问题</li>
<li>切换到全屏播放时，是直接重新开启一个横向的<code>Activity</code>来实现全屏播放</li>
</ol>
<h2 id="APP实现效果图"><a href="#APP实现效果图" class="headerlink" title="APP实现效果图"></a>APP实现效果图</h2><p><img src="/img/TigerVideo-1.jpg" width="360" height="640" alt><br><img src="/img/TigerVideo-2.jpg" width="360" height="640" alt><br><img src="/img/TigerVideo-3.jpg" width="360" height="640" alt><br><img src="/img/TigerVideo-4.jpg" width="360" height="640" alt><br><img src="/img/TigerVideo-5.jpg" width="640" height="360" alt><br><img src="/img/TigerVideo-6.jpg" width="360" height="640" alt>  </p>
<h2 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h2><p><a href="https://github.com/huyongli/TigerVideo" target="_blank" rel="noopener">猛戳这里</a></p>
<p>感兴趣的朋友欢迎去我的<a href="https://github.com/huyongli/TigerVideo" target="_blank" rel="noopener">github</a>上<code>star</code>和<code>fork</code></p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo搭建静态博客]]></title>
      <url>http://ittiger.cn/create-hexo-blog.html</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间因为我的WordPress博客进入后台非常慢，严重影响操作使用，再加上服务器时间的限制，所以就讲博客从WordPress迁移到了Hexo上，这篇文章记录下我创建Hexo博客的一些流程步骤。</p>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>Hexo是一个简单地、轻量地、基于NodeJS的一个静态博客框架，可以方便的生成静态网页托管在github或者是国内的coding.net上</p>
<a id="more"></a>
<h3 id="Github-Pages"><a href="#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h3><p>GitHub Pages 可以被认为是用户编写的、托管在github上的静态网页。因为Github的空间免费稳定， 因此可以用于将自己的静态站点托管在github上来搭建自己的个人博客站点。另外国内的coding.net也支持Pages服务，同样可以进行托管静态网页。</p>
<p>Github上生成的网站的默认域名一般都是<code>username.github.io</code>，这里的username是指你在github上注册的用户名，当然github的网站也支持自定义绑定域名。</p>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>因为我们要将最终的静态网页文件推送到github上，所以第一步我们需要先在机器上安装Git，Git下载地址：<a href="https://git-for-windows.github.io/，安装完成之后配置好相关全局参数，如user，email等" target="_blank" rel="noopener">https://git-for-windows.github.io/，安装完成之后配置好相关全局参数，如user，email等</a></p>
<h3 id="安装NodeJS"><a href="#安装NodeJS" class="headerlink" title="安装NodeJS"></a>安装NodeJS</h3><p>因为Hexo是基于NodeJS的，所以还需要安装NodeJS，下载地址：<a href="http://nodejs.org/" target="_blank" rel="noopener">http://nodejs.org/</a></p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>在磁盘上任意目录下右键鼠标选择Git Bash，使用如下命令进行Hexo的安装<br><code>npm install -g hexo</code></p>
<h3 id="创建Hexo项目"><a href="#创建Hexo项目" class="headerlink" title="创建Hexo项目"></a>创建Hexo项目</h3><h4 id="初始化Hexo项目"><a href="#初始化Hexo项目" class="headerlink" title="初始化Hexo项目"></a>初始化Hexo项目</h4><p>在磁盘上新建一个文件夹作为自己Hexo项目的根目录，如：<code>D:\Hexo</code>，在此目录下右键鼠标选择Git Bash，然后执行如下命令进行Hexo项目的初始化<br><code>hexo init</code></p>
<h4 id="安装Hexo项目依赖"><a href="#安装Hexo项目依赖" class="headerlink" title="安装Hexo项目依赖"></a>安装Hexo项目依赖</h4><p><code>npm install</code></p>
<h4 id="本地查看Hexo站点"><a href="#本地查看Hexo站点" class="headerlink" title="本地查看Hexo站点"></a>本地查看Hexo站点</h4><p>依赖安装完成之后，Hexo项目就算建好了，接下来我们使用如下命令检查项目是否成功创建：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate		//此命令表示生成静态文件</span><br><span class="line">hexo server       //比命令表示启动服务，启动之后在本地可以查看站点</span><br></pre></td></tr></table></figure></p>
<p>执行上述两个命令之后，可以在命令行上看到提示，在浏览器中访问<code>http://localhost:4000</code>，可以成功访问则表示你的Hexo项目创建成功了。</p>
<h3 id="创建Github仓库"><a href="#创建Github仓库" class="headerlink" title="创建Github仓库"></a>创建Github仓库</h3><p>在github上创建一个与自己账户名一致的仓库：账号名.github.io，当然没有github账号的赶紧先去注册一个账号。</p>
<h3 id="生成SSH密钥"><a href="#生成SSH密钥" class="headerlink" title="生成SSH密钥"></a>生成SSH密钥</h3><p>执行如下命令生成SSH密钥<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C “你的邮箱地址”，按3个回车，密码为空</span><br></pre></td></tr></table></figure></p>
<p>执行完成之后，在<code>C:\Users\Administrator\.ssh</code>下会生成两个文件<code>id_rsa</code>和<code>id_rsa.pub</code></p>
<p>打开<code>id_rsa.pub</code>，复制全文，打开<a href="https://github.com/settings/ssh，Add" target="_blank" rel="noopener">https://github.com/settings/ssh，Add</a> SSH key，粘贴复制的文本内容</p>
<p>这样设置之后，将静态文件从本地推送到github上时就不要输入用户名和密码了，当然也可以不设置github的ssh，这样的话在推送文件到github上时会提示你输入用户名和密码</p>
<h3 id="配置Hexo项目"><a href="#配置Hexo项目" class="headerlink" title="配置Hexo项目"></a>配置Hexo项目</h3><h4 id="Hexo目录结构"><a href="#Hexo目录结构" class="headerlink" title="Hexo目录结构"></a>Hexo目录结构</h4><p>Hexo项目创建成功之后，我们在项目根目录下会发现这样几个我们经常用到的目录</p>
<ol>
<li><code>source</code> 这个目录是用来存放我们写的博客文件</li>
<li><code>themes</code> 这个目录里是所有hexo安装的主题</li>
<li><code>_config.yml</code> 这个文件是Hexo项目的主配置文件</li>
</ol>
<h4 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h4><p>使用文本编辑器打开上面介绍的<code>_config.yml</code>文件，按照<a href="https://hexo.io/docs/configuration.html" target="_blank" rel="noopener">官网https://hexo.io/docs/configuration.html</a>上的提示配置好相关配置，具体配置细节我就不多介绍了，自己在官网上看吧</p>
<p>我只介绍一个配置项<code>deploy</code>配置，这个配置就是用来配置你的静态站点是要部署到哪个上面，一般都是用github，以我的配置为例：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="hljs-built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/huyongli/huyongli.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>注意配置参数与值之间是需要有一个空格的，不然配置是无法生效的，<code>type</code>表示我们使用的是<code>git</code>，<code>repo</code>表示你<code>github</code>上的仓库地址，<code>branch</code>表示你仓库的分支，一般默认都是<code>master</code></p>
<h4 id="部署Hexo"><a href="#部署Hexo" class="headerlink" title="部署Hexo"></a>部署Hexo</h4><p>配置完Hexo之后，就可以将Hexo站点部署到github上了，执行如下命令进行部署：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>如果在部署的过程中出现如下错误：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br><span class="line"></span><br><span class="line">执行如下命令：</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>在创建Hexo或是部署的过程中可能会多次出现类似的错误，一般都是使用<code>npm install hexo-deployer-XXX --save</code>类似的命令进行插件安装</p>
<p>上述命令执行成功后，重新部署，部署成功后，命令行上会提示<code>Deploy done: git</code></p>
<p>成功部署后，过个几分钟就可以在浏览器上通过你的仓库地址访问你的博客了，还是以我的为例：<code>http://huyongli.github.io</code></p>
<h3 id="安装Hexo主题"><a href="#安装Hexo主题" class="headerlink" title="安装Hexo主题"></a>安装Hexo主题</h3><p>Hexo默认的主题很丑，如果想自己的博客看着舒服的话，需要安装另外的主题插件，我使用主题的是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">next</a></p>
<p>进入<code>next</code>主题主页<code>https://github.com/iissnan/hexo-theme-next</code><br>将此主题代码完整下下来，然后解压放到<code>Hexo</code>根目录下的<code>themes</code>目录下，然后将hexo项目的主题配置修改为next：<code>theme: next</code></p>
<p>至于<code>next</code>主题的具体配置参考该主题的详细使用介绍吧<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a></p>
<p>到此，整个Hexo的安装部署就结束了</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Retrofit2文件上传下载及其进度显示]]></title>
      <url>http://ittiger.cn/retrofit2-upload-download-progress.html</url>
      <content type="html"><![CDATA[<h4 id="序"><a href="#序" class="headerlink" title="序"></a>序</h4><p>前面一篇文章介绍了<a href="http://ittiger.cn/2016/08/29/Retrofit2%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/">Retrofit2的基本使用</a>，这篇文章接着介绍使用Retrofit2实现文件上传和文件下载，以及上传下载过程中如何实现进度的显示。</p>
<h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><h5 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h5><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Multipart</span></span><br><span class="line"><span class="hljs-meta">@POST</span>(<span class="hljs-string">"fileService"</span>)</span><br><span class="line"><span class="hljs-function">Call&lt;User&gt; <span class="hljs-title">uploadFile</span><span class="hljs-params">(@Part MultipartBody.Part file)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="构造请求体上传"><a href="#构造请求体上传" class="headerlink" title="构造请求体上传"></a>构造请求体上传</h5><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="hljs-keyword">new</span> File(filePath);</span><br><span class="line">RequestBody body = RequestBody.create(MediaType.parse(<span class="hljs-string">"application/otcet-stream"</span>), file);</span><br><span class="line">MultipartBody.Part part = MultipartBody.Part.createFormData(<span class="hljs-string">"file"</span>, file.getName(), body);</span><br><span class="line">Call&lt;User&gt; call = getRetrofitService().uploadOneFile(part);</span><br><span class="line">call.enqueue(callback);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>这样就可以将这个文件上传到服务器，但就这样上传操作不够友好，最好加上文件上传进度。而Retrofit本身是不支持文件上传进度显示的，所以就需要我们自己扩展OkHttp来实现文件上传进度。</p>
<p>我的做法是直接扩展一个RequestBody来实现进度显示，实现完成之后只需要将上面body进行包装转换即可</p>
<h5 id="上传进度显示"><a href="#上传进度显示" class="headerlink" title="上传进度显示"></a>上传进度显示</h5><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">RetrofitCallback&lt;User&gt; callback = <span class="hljs-keyword">new</span> RetrofitCallback&lt;User&gt;() &#123;</span><br><span class="line">   <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        runOnUIThread(activity, response.body().toString());</span><br><span class="line">        <span class="hljs-comment">//进度更新结束</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(Call&lt;User&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        runOnUIThread(activity, t.getMessage());</span><br><span class="line">        <span class="hljs-comment">//进度更新结束</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLoading</span><span class="hljs-params">(<span class="hljs-keyword">long</span> total, <span class="hljs-keyword">long</span> progress)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">super</span>.onLoading(total, progress);</span><br><span class="line">        <span class="hljs-comment">//此处进行进度更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RequestBody body1 = RequestBody.create(MediaType.parse(<span class="hljs-string">"application/otcet-stream"</span>), file);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//通过该行代码将RequestBody转换成特定的FileRequestBody</span></span><br><span class="line">FileRequestBody body = <span class="hljs-keyword">new</span> FileRequestBody(body1, callback);</span><br><span class="line"></span><br><span class="line">MultipartBody.Part part = MultipartBody.Part.createFormData(<span class="hljs-string">"file"</span>, file.getName(), body);</span><br><span class="line">Call&lt;User&gt; call = getRetrofitService().uploadOneFile(part);</span><br><span class="line">call.enqueue(callback);</span><br></pre></td></tr></table></figure>
<h5 id="回调RetrofitCallback"><a href="#回调RetrofitCallback" class="headerlink" title="回调RetrofitCallback"></a>回调RetrofitCallback</h5><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RetrofitCallback</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Callback</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(Call&lt;T&gt; call, Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span>(response.isSuccessful()) &#123;</span><br><span class="line">            onSuccess(call, response);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            onFailure(call, <span class="hljs-keyword">new</span> Throwable(response.message()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(Call&lt;T&gt; call, Response&lt;T&gt; response)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLoading</span><span class="hljs-params">(<span class="hljs-keyword">long</span> total, <span class="hljs-keyword">long</span> progress)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="FileRequestBody"><a href="#FileRequestBody" class="headerlink" title="FileRequestBody"></a>FileRequestBody</h5><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 扩展OkHttp的请求体，实现上传时的进度提示</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileRequestBody</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">RequestBody</span> </span>&#123;</span><br><span class="line">  <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">   * 实际请求体</span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br><span class="line">  <span class="hljs-keyword">private</span> RequestBody requestBody;</span><br><span class="line">  <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">   * 上传回调接口</span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br><span class="line">  <span class="hljs-keyword">private</span> RetrofitCallback&lt;T&gt; callback;</span><br><span class="line">  <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">   * 包装完成的BufferedSink</span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br><span class="line">  <span class="hljs-keyword">private</span> BufferedSink bufferedSink;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileRequestBody</span><span class="hljs-params">(RequestBody requestBody, RetrofitCallback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>();</span><br><span class="line">    <span class="hljs-keyword">this</span>.requestBody = requestBody;</span><br><span class="line">    <span class="hljs-keyword">this</span>.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">contentLength</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> requestBody.contentLength();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> MediaType <span class="hljs-title">contentType</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> requestBody.contentType();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeTo</span><span class="hljs-params">(BufferedSink sink)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (bufferedSink == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">      <span class="hljs-comment">//包装</span></span><br><span class="line">      bufferedSink = Okio.buffer(sink(sink));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">//写入</span></span><br><span class="line">    requestBody.writeTo(bufferedSink);</span><br><span class="line">    <span class="hljs-comment">//必须调用flush，否则最后一部分数据可能不会被写入</span></span><br><span class="line">    bufferedSink.flush();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">   * 写入，回调进度接口</span></span><br><span class="line"><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> sink Sink</span></span><br><span class="line"><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Sink</span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">private</span> Sink <span class="hljs-title">sink</span><span class="hljs-params">(Sink sink)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ForwardingSink(sink) &#123;</span><br><span class="line">      <span class="hljs-comment">//当前写入字节数</span></span><br><span class="line">      <span class="hljs-keyword">long</span> bytesWritten = <span class="hljs-number">0L</span>;</span><br><span class="line">      <span class="hljs-comment">//总字节长度，避免多次调用contentLength()方法</span></span><br><span class="line">      <span class="hljs-keyword">long</span> contentLength = <span class="hljs-number">0L</span>;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-meta">@Override</span></span><br><span class="line">      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(Buffer source, <span class="hljs-keyword">long</span> byteCount)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>.write(source, byteCount);</span><br><span class="line">        <span class="hljs-keyword">if</span> (contentLength == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">          <span class="hljs-comment">//获得contentLength的值，后续不再调用</span></span><br><span class="line">          contentLength = contentLength();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//增加当前写入的字节数</span></span><br><span class="line">        bytesWritten += byteCount;</span><br><span class="line">        <span class="hljs-comment">//回调</span></span><br><span class="line">        callback.onLoading(contentLength, bytesWritten);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><h5 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h5><p>文件下载请求与普通的Get和Post请求是一样的，只是他们的返回值不一样而已，文件下载请求的返回值一般定义成<code>ResponseBody</code><br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//这里只举例POST方式进行文件下载</span></span><br><span class="line"><span class="hljs-meta">@FormUrlEncoded</span></span><br><span class="line"><span class="hljs-meta">@POST</span>(<span class="hljs-string">"fileService"</span>)</span><br><span class="line"><span class="hljs-function">Call&lt;ResponseBody&gt; <span class="hljs-title">downloadFile</span><span class="hljs-params">(@Field(<span class="hljs-string">"param"</span>)</span> String param)</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h5><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">RetrofitCallback&lt;ResponseBody&gt; callback = <span class="hljs-keyword">new</span> RetrofitCallback&lt;ResponseBody&gt;() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            InputStream is = response.body().byteStream();</span><br><span class="line">            String path = Util.getSdCardPath();</span><br><span class="line">            File file = <span class="hljs-keyword">new</span> File(path, <span class="hljs-string">"download.jpg"</span>);</span><br><span class="line">            FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(file);</span><br><span class="line">            BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(is);</span><br><span class="line">            <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];</span><br><span class="line">            <span class="hljs-keyword">int</span> len;</span><br><span class="line">            <span class="hljs-keyword">while</span> ((len = bis.read(buffer)) != -<span class="hljs-number">1</span>) &#123;</span><br><span class="line">                fos.write(buffer, <span class="hljs-number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            fos.flush();</span><br><span class="line">            fos.close();</span><br><span class="line">            bis.close();</span><br><span class="line">            is.close();</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(Call&lt;ResponseBody&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        runOnUIThread(activity, t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line">Call&lt;ResponseBody&gt; call = getRetrofitService(callback).downloadFile(param);</span><br><span class="line">call.enqueue(callback);</span><br></pre></td></tr></table></figure>
<h5 id="下载进度显示"><a href="#下载进度显示" class="headerlink" title="下载进度显示"></a>下载进度显示</h5><p>下载进度显示有两种方式实现，一种是通过OkHttp设置拦截器将ResponseBody进行转换成我们扩展后的ResponseBody（稍后介绍），另外一种则是在上面的回调Callback中将ResponseBody的流写入到文件时进行进度处理，下面分别进行介绍。</p>
<h6 id="扩展ResponseBody设置OkHttp拦截器"><a href="#扩展ResponseBody设置OkHttp拦截器" class="headerlink" title="扩展ResponseBody设置OkHttp拦截器"></a>扩展ResponseBody设置OkHttp拦截器</h6><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">RetrofitService <span class="hljs-title">getRetrofitService</span><span class="hljs-params">(<span class="hljs-keyword">final</span> RetrofitCallback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    OkHttpClient.Builder clientBuilder = <span class="hljs-keyword">new</span> OkHttpClient.Builder();</span><br><span class="line">    clientBuilder.addInterceptor(<span class="hljs-keyword">new</span> Interceptor() &#123;</span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-keyword">public</span> okhttp3.<span class="hljs-function">Response <span class="hljs-title">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">            okhttp3.Response response = chain.proceed(chain.request());</span><br><span class="line">            <span class="hljs-comment">//将ResponseBody转换成我们需要的FileResponseBody</span></span><br><span class="line">            <span class="hljs-keyword">return</span> response.newBuilder().body(<span class="hljs-keyword">new</span> FileResponseBody&lt;T&gt;(response.body(), callback)).build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Retrofit retrofit = <span class="hljs-keyword">new</span> Retrofit.Builder()</span><br><span class="line">            .baseUrl(BASE_URL)</span><br><span class="line">            .client(clientBuilder.build())</span><br><span class="line">            .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    RetrofitService service = retrofit.create(RetrofitService.class);</span><br><span class="line">    <span class="hljs-keyword">return</span> service ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//通过上面的设置后，我们需要在回调RetrofitCallback中实现onLoading方法来进行进度的更新操作，与上传文件的方法相同</span></span><br></pre></td></tr></table></figure>
<h6 id="FileResponseBody"><a href="#FileResponseBody" class="headerlink" title="FileResponseBody"></a>FileResponseBody</h6><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 扩展OkHttp的请求体，实现上传时的进度提示</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileResponseBody</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ResponseBody</span> </span>&#123;</span><br><span class="line">  <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">   * 实际请求体</span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br><span class="line">  <span class="hljs-keyword">private</span> ResponseBody mResponseBody;</span><br><span class="line">  <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">   * 下载回调接口</span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br><span class="line">  <span class="hljs-keyword">private</span> RetrofitCallback&lt;T&gt; mCallback;</span><br><span class="line">  <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">   * BufferedSource</span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br><span class="line">  <span class="hljs-keyword">private</span> BufferedSource mBufferedSource;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FileResponseBody</span><span class="hljs-params">(ResponseBody responseBody, RetrofitCallback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>();</span><br><span class="line">    <span class="hljs-keyword">this</span>.mResponseBody = responseBody;</span><br><span class="line">    <span class="hljs-keyword">this</span>.mCallback = callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> BufferedSource <span class="hljs-title">source</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (mBufferedSource == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">      mBufferedSource = Okio.buffer(source(mResponseBody.source()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> mBufferedSource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">contentLength</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> mResponseBody.contentLength();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-meta">@Override</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> MediaType <span class="hljs-title">contentType</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> mResponseBody.contentType();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">   * 回调进度接口</span></span><br><span class="line"><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> source</span></span><br><span class="line"><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Source</span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">private</span> Source <span class="hljs-title">source</span><span class="hljs-params">(Source source)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ForwardingSource(source) &#123;</span><br><span class="line">      <span class="hljs-keyword">long</span> totalBytesRead = <span class="hljs-number">0L</span>;</span><br><span class="line"></span><br><span class="line">      <span class="hljs-meta">@Override</span></span><br><span class="line">      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">read</span><span class="hljs-params">(Buffer sink, <span class="hljs-keyword">long</span> byteCount)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">long</span> bytesRead = <span class="hljs-keyword">super</span>.read(sink, byteCount);</span><br><span class="line">        totalBytesRead += bytesRead != -<span class="hljs-number">1</span> ? bytesRead : <span class="hljs-number">0</span>;</span><br><span class="line">        mCallback.onLoading(mResponseBody.contentLength(), totalBytesRead);</span><br><span class="line">        <span class="hljs-keyword">return</span> bytesRead;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="直接在回调中进行进度更新"><a href="#直接在回调中进行进度更新" class="headerlink" title="直接在回调中进行进度更新"></a>直接在回调中进行进度更新</h6><p>上面介绍了通过扩展ResponseBody同时设置OkHttp拦截器来实现进度条更新显示，另外也可以直接在请求回调onSuccess中将流转换成文件时实现进度更新，下面给出大致实现<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">RetrofitCallback&lt;ResponseBody&gt; callback = <span class="hljs-keyword">new</span> RetrofitCallback&lt;ResponseBody&gt;() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            InputStream is = response.body().byteStream();</span><br><span class="line">			<span class="hljs-comment">//获取文件总长度</span></span><br><span class="line">            <span class="hljs-keyword">long</span> totalLength = is.available();</span><br><span class="line">            </span><br><span class="line">            String path = Util.getSdCardPath();</span><br><span class="line">            File file = <span class="hljs-keyword">new</span> File(path, <span class="hljs-string">"download.jpg"</span>);</span><br><span class="line">            FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(file);</span><br><span class="line">            BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(is);</span><br><span class="line">            <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];</span><br><span class="line">            <span class="hljs-keyword">int</span> len;</span><br><span class="line">            <span class="hljs-keyword">while</span> ((len = bis.read(buffer)) != -<span class="hljs-number">1</span>) &#123;</span><br><span class="line">                fos.write(buffer, <span class="hljs-number">0</span>, len);</span><br><span class="line">                <span class="hljs-comment">//此处进行更新操作</span></span><br><span class="line">                <span class="hljs-comment">//len即可理解为已下载的字节数</span></span><br><span class="line">                <span class="hljs-comment">//onLoading(len, totalLength);</span></span><br><span class="line">            &#125;</span><br><span class="line">            fos.flush();</span><br><span class="line">            fos.close();</span><br><span class="line">            bis.close();</span><br><span class="line">            is.close();</span><br><span class="line">            <span class="hljs-comment">//此处就代表更新结束</span></span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(Call&lt;ResponseBody&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        runOnUIThread(activity, t.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>以上就是Retrofit中文件上传下载及其进度更新显示的实现，有疑问的可以加我微信和QQ与我联系，联系方式在这<a href="http://ittiger.cn/about/">关于</a></p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Retrofit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Retrofit2使用介绍]]></title>
      <url>http://ittiger.cn/retrofit2-introduction.html</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>对于还不知道Refrofit是什么的同学，我只能说你们太out了，赶紧去Google下，本文是针对Retrofit2.0的使用介绍，当然大家也可以直接去<a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">官网</a>上去看使用介绍</p>
<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>要使用Retrofit首先得添加gradle依赖<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.squareup.retrofit2:retrofit:2.0.2&apos;</span><br><span class="line">compile &apos;com.squareup.retrofit2:converter-gson:2.0.0&apos;</span><br></pre></td></tr></table></figure></p>
<h4 id="声明服务接口"><a href="#声明服务接口" class="headerlink" title="声明服务接口"></a>声明服务接口</h4><p>依赖添加完成之后，就可以开始撸代码了，首先我们要新建一个Interface，这个接口就是你要请求的接口服务类，就像这个样子</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RetrofitService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@GET</span>(<span class="hljs-string">"getModelService"</span>)</span><br><span class="line">    <span class="hljs-function">Call&lt;User&gt; <span class="hljs-title">getModelService</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个接口中暂时只声明了一个方法，而在Retrofit中想这样声明的一个方法就代表了一个具体的Http请求接口。Retrofit中方法上添加<code>@GET</code>注解就表示当前方法代表一个Get请求，我们声明的这个请求方法不带任何参数，且返回结果是User对象。<br><code>@GET</code>注解括号中的值<code>getModelService</code>就代表http请求地址的具体指向，这个值与下面baseUrl中配置的URL一起组成一个完整的请求地址<br>Retrofit就是这么任性，它可以帮我们把http的请求结果自动转换成Javabean对象，这将为我们减少不少编码工作。</p>
<h4 id="构造Retrofit对象"><a href="#构造Retrofit对象" class="headerlink" title="构造Retrofit对象"></a>构造Retrofit对象</h4><p>接口服务声明完成之后，我们接着需要新建一个Retrofit对象<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="hljs-keyword">new</span> Retrofit.Builder()</span><br><span class="line">         .baseUrl(<span class="hljs-string">"http://localhost:8080/AndroidService/"</span>)</span><br><span class="line">         .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">         .build();</span><br><span class="line">RetrofitService service = retrofit.create(RetrofitService.class);</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>通过上面的代码我们就创建了一个Retrofit对象，同时通过这个Retrofit对象将我们前面声明的服务接口进行了实例化，有了这个服务接口实例化对象，我们就可以调用接口里面声明的方法进行http请求了。</p>
<ol>
<li>另外需要说明是我们在设置baseUrl的时候一般在都是以/结尾，而不是在接口方法中的url以/开头</li>
<li>前面说的Retrofit会将请求结果自动转换成Javabean对象，其实这个是需要配置结果转换器的，就像上面我配置的<code>addConverterFactory(GsonConverterFactory.create())</code>，配置了这个转换器工厂之后，就会将请求得到的JSON数据自动转换成Javabean对象。同样如果请求得到的数据是xml类型的话，转换成Javabean对象则需要配置成其他类型的转换器</li>
<li>Retrofit其实已经为我们提供了多种转换器供我们选择：<blockquote>
<p>Gson: com.squareup.retrofit2:converter-gson<br>Jackson: com.squareup.retrofit2:converter-jackson<br>Moshi: com.squareup.retrofit2:converter-moshi<br>Protobuf: com.squareup.retrofit2:converter-protobuf<br>Wire: com.squareup.retrofit2:converter-wire<br>Simple XML: com.squareup.retrofit2:converter-simplexml<br>Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars</p>
</blockquote>
</li>
</ol>
<h4 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h4><p>前面准备工作都完成了，ok，可以开始发起请求了<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;User&gt; call = service.getModelServiceSync();</span><br><span class="line">Response&lt;User&gt; response = call.execute();</span><br><span class="line"><span class="hljs-keyword">if</span>(response.isSuccessful()) &#123;</span><br><span class="line">    User user = response.body();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就是Retrofit的基本使用流程：添加依赖–&gt;声明接口–&gt;创建Retrofit和接口对象–&gt;选择执行同步异步请求</p>
<h4 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h4><p>同步请求执行<code>call.execute()</code>即可，异步请求则是这样：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">call.enqueue(<span class="hljs-keyword">new</span> Callback&lt;User&gt;() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(response.isSuccessful()) &#123;</span><br><span class="line">            User user = response.body();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(Call&lt;User&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h4 id="带参Get请求"><a href="#带参Get请求" class="headerlink" title="带参Get请求"></a>带参Get请求</h4><p>如果要实现带参数的Get请求，则需要将我们上面的方法声明改成如下形式<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GET</span>(<span class="hljs-string">"getModelService"</span>)</span><br><span class="line"><span class="hljs-function">Call&lt;User&gt; <span class="hljs-title">getModelService</span><span class="hljs-params">(@Query(<span class="hljs-string">"param1"</span>)</span> <span class="hljs-keyword">boolean</span> param1, @<span class="hljs-title">Query</span><span class="hljs-params">(<span class="hljs-string">"param2"</span>)</span> <span class="hljs-keyword">boolean</span> param2)</span>;</span><br></pre></td></tr></table></figure></p>
<p>Retrofit中我们只需要将要传输到服务端的参数添加<code>@Query</code>注解即可，而<code>@Query</code>注解括号中的值<code>param1</code>和<code>param2</code>则是对应的参数名</p>
<p>Retrofit也为我们提供了另外一种形式，使用<code>@QueryMap</code>注解来声明一个集合作为请求参数<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GET</span>(<span class="hljs-string">"getModelService"</span>)</span><br><span class="line"><span class="hljs-function">Call&lt;User&gt; <span class="hljs-title">getModelService</span><span class="hljs-params">(@QueryMap Map&lt;String, String&gt; parmas)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="动态URL"><a href="#动态URL" class="headerlink" title="动态URL"></a>动态URL</h4><p>如果我们有两个这样的请求地址<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="hljs-comment">//localhost:8080/AndroidService/user/zhangsan</span></span><br><span class="line">http:<span class="hljs-comment">//localhost:8080/AndroidService/user/lisi</span></span><br></pre></td></tr></table></figure></p>
<p>这两个请求地址很明显，除了最后的一段不一样其他的都一样。因此如果按照上面的做法的话，我们要请求这两个服务就需要声明两个接口方法，如果这两个请求地址没有其他参数的话声明两个接口方法不是感觉很累赘，所以Retrofit为我们提供了动态构造URL的方式来声明类似请求地址的接口方法。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@GET</span>(<span class="hljs-string">"user/&#123;path&#125;"</span>)</span><br><span class="line"><span class="hljs-function">Call&lt;User&gt; <span class="hljs-title">getModelService</span><span class="hljs-params">(@Path(path)</span> String path, @<span class="hljs-title">Query</span><span class="hljs-params">(<span class="hljs-string">"param1"</span>)</span> <span class="hljs-keyword">boolean</span> param1, @<span class="hljs-title">Query</span><span class="hljs-params">(<span class="hljs-string">"param2"</span>)</span> <span class="hljs-keyword">boolean</span> param2)</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面的方法中，<code>@GET</code>注解中<code>{path}</code>就代表URL可以动态变化的那一部分，<code>@Path</code>注解则表示该方法参数的值就是<code>{path}</code>中的动态值</p>
<h4 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FormUrlEncoded</span></span><br><span class="line"><span class="hljs-meta">@POST</span>(<span class="hljs-string">"postService"</span>)</span><br><span class="line"><span class="hljs-function">Call&lt;String&gt; <span class="hljs-title">postModelService</span><span class="hljs-params">(@Field(<span class="hljs-string">"msg"</span>)</span> String msg, @<span class="hljs-title">Field</span><span class="hljs-params">(<span class="hljs-string">"string"</span>)</span> <span class="hljs-keyword">boolean</span> isString)</span>;</span><br></pre></td></tr></table></figure>
<p>Retrofit中的Post请求则需要将前面的<code>@GET</code>注解换成<code>@POST</code>注解，而Post请求的文本参数则用注解<code>@Field</code>来声明，同时还必须给方法添加注解<code>@FormUrlEncoded</code>来告知Retrofit参数为表单参数，如果只为参数增加<code>@Field</code>注解，而不给方法添加<code>@FormUrlEncoded</code>注解运行时会抛异常。</p>
<p>如果Post请求有很多参数同样也可以使用集合的方式进行声明<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FormUrlEncoded</span></span><br><span class="line"><span class="hljs-meta">@POST</span>(<span class="hljs-string">"&#123;path&#125;"</span>)</span><br><span class="line"><span class="hljs-function">Call&lt;User&gt; <span class="hljs-title">postModelService</span><span class="hljs-params">(@Path(<span class="hljs-string">"path"</span>)</span> String path, @FieldMap Map&lt;String, String&gt; map)</span>;</span><br></pre></td></tr></table></figure></p>
<p>Retrofit中提供了注解<code>@FieldMap</code>用来声明一个Map类型的集合作为Post请求的表单参数</p>
<p>Post请求的服务接口声明完成之后，讲得到的<code>Call</code>对象调用<code>execute</code>或者<code>enqueue</code>即可发起同步或异步的Post请求</p>
<p>以上就是Retrofit2的基本使用，下一篇文章我讲接着介绍Retrofit2中的文件上传和文件下载，以及如何实现文件上传和下载过程中的进度条</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Retrofit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[让RecyclerView更通用]]></title>
      <url>http://ittiger.cn/%E8%AE%A9RecyclerView%E6%9B%B4%E9%80%9A%E7%94%A8.html</url>
      <content type="html"><![CDATA[<h3 id="何为通用"><a href="#何为通用" class="headerlink" title="何为通用"></a>何为通用</h3><p>用过<code>RecyclerView</code>的都知道它没有为我们提供像<code>ListView</code>中类似<code>addHeaderView，addFooterView，setOnItemClickListener，setOnItemLongClickListener</code>的接口，另外还有底部自动加载更多，这些都是列表使用中很常见的功能，所以如果我们使用<code>RecyclerView</code>来实现列表的话就需要自己实现这些功能。本文主要介绍这些通用功能的实现方式，使得<code>RecyclerView</code>使用起来和<code>ListView</code>一样方便。</p>
<a id="more"></a>
<h3 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h3><h4 id="setOnItemClickListener，setOnItemLongClickListener"><a href="#setOnItemClickListener，setOnItemLongClickListener" class="headerlink" title="setOnItemClickListener，setOnItemLongClickListener"></a>setOnItemClickListener，setOnItemLongClickListener</h4><p><code>RecyclerView</code>中虽然没有提供上面这两个接口，但是给我们提供了另外一个接口：<code>OnItemTouchListener</code>看这个接口的文档描述我们知道此接口可以对<code>RecyclerView</code>中的手势进行监听处理，因此我们可以采用<code>OnItemTouchListener+GestureDetector</code>来实现<code>RecyclerView</code>的<code>OnItemClick</code>和<code>OnItemLongClick</code>。实现方式也比较简单，还是上代码吧…<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> OnItemClickListener mOnItemClickListener;</span><br><span class="line"><span class="hljs-keyword">private</span> OnItemLongClickListener mItemLongClickListener;</span><br><span class="line"> </span><br><span class="line">mGestureDetector = <span class="hljs-keyword">new</span> GestureDetector(context, <span class="hljs-keyword">new</span> GestureDetector.SimpleOnGestureListener() &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLongPress</span><span class="hljs-params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="hljs-keyword">super</span>.onLongPress(e);</span><br><span class="line">        <span class="hljs-keyword">if</span>(mItemLongClickListener != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            View childView = findChildViewUnder(e.getX(), e.getY());</span><br><span class="line">            <span class="hljs-keyword">if</span>(childView != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">int</span> position = getChildLayoutPosition(childView);</span><br><span class="line">                mItemLongClickListener.onItemLongClick(position, childView);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onSingleTapUp</span><span class="hljs-params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="hljs-keyword">if</span>(mOnItemClickListener != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            View childView = findChildViewUnder(e.getX(),e.getY());</span><br><span class="line">            <span class="hljs-keyword">if</span>(childView != <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">                <span class="hljs-keyword">int</span> position = getChildLayoutPosition(childView);</span><br><span class="line">                mOnItemClickListener.onItemClick(position, childView);</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onSingleTapUp(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">addOnItemTouchListener(<span class="hljs-keyword">new</span> SimpleOnItemTouchListener() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(RecyclerView rv, MotionEvent e)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="hljs-keyword">if</span> (mGestureDetector.onTouchEvent(e)) &#123;<span class="hljs-comment">//交由手势处理</span></span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Item项点击事件</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OnItemClickListener</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onItemClick</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, View itemView)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Item项长按点击事件</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OnItemLongClickListener</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onItemLongClick</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, View itemView)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="addHeaderView，addFooterView"><a href="#addHeaderView，addFooterView" class="headerlink" title="addHeaderView，addFooterView"></a>addHeaderView，addFooterView</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>前面写过一篇文章<code>RecyclerView</code>下拉刷新上拉加载 介绍过<code>RecyclerView</code>的上拉加载的实现方式，里面的上拉加载进度条其实也是<code>RecyclerView</code>的一个<code>FooterView</code>，其实现方式就是为<code>LoadMoreView</code>设置了一个特殊的<code>ItemViewType</code>来进行区分展示，因此我这里的<code>HeaderView</code>和<code>FooterView</code>也是通过为它们设置不同的<code>ItemViewType</code>来进行区分展示。</p>
<p>我们知道<code>ListView</code>中的<code>addHeaderView</code>和<code>addFooterView</code>都是可以添加多个View的，也就是说<code>RecyclerView</code>中也会出现添加多个完全不同的<code>HeaderView</code>或<code>FooterView</code>，所以我们必须为添加的每个<code>HeaderView</code>和<code>FooterView</code>都设置一个<code>ItemViewType</code>从而达到添加多个不同的<code>HeaderView</code>或<code>FooterView</code>的目的(如果所有的<code>HeaderView</code>或<code>FooterView</code>都设置同一个<code>ItemViewType</code>的话只能显示一种<code>View</code>的<code>HeaderView</code>或<code>FooterView</code>)。</p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>知道了实现原理，我们再来理一下实现步骤：</p>
<ol>
<li>因为每个<code>HeaderView</code>或<code>FooterView</code>都需要对应一个<code>ItemViewType</code>，所以我们需要分别为它们建立一个映射关系，我采用<code>SparseArray</code>实现映射</li>
<li>我们需要在添加<code>HeaderView</code>或<code>FooterView</code>的时候生成对应的<code>ItemViewType</code>值，也就是我们需要定义一个<code>ItemViewType</code>的生成规则，我采用了基准值+视图个数的方式生成<code>ItemViewType</code></li>
<li>自定义一个<code>Adapter</code>继承自<code>RecyclerView.Adapter</code>，重写里面的几个方法：<code>onCreateViewHolder，onBindViewHolder，getItemViewType，getItemCount</code></li>
<li><code>getItemCount</code>方法中返回的数据总数显然是：<code>HeaderView总数</code>+<code>FooterView总数</code>+<code>List列表展示的数据总数</code></li>
<li>重写<code>onBindViewHolder</code>，<code>getItemViewType</code>这两个方法时，显然需要根据<code>position</code>判断当前位置是否为<code>HeaderView</code>或是<code>FooterView</code>，而根据展示顺序来看当<code>0&lt;=position&lt;HeaderView总数</code>  时是<code>HeaderView</code>，而当<code>position&gt;=(HeaderView总数+List总数)</code>时则是<code>FooterView</code>，其余位置则是<code>List</code>数据对应的<code>View</code></li>
<li>而重写<code>onCreateViewHolder</code>方法时，则可用直接根据其方法参数<code>viewType</code>在SparseArray映射中查找是否存在该类型的<code>HeaderView</code>或是<code>FooterView</code>，有则返回，没有则返回List数据展示的<code>View</code><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3>分析完实现的步骤开始撸代码，下面是我实现的关键代码：<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//HeaderView的ItemViewType的生成基准值，生成规则为基准值+当前HeaderView的个数</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TYPE_HEADER = <span class="hljs-number">100000</span>;</span><br><span class="line"><span class="hljs-comment">//FooterView的ItemViewType的生成基准值，生成规则为基准值+当前的FooterView的个数</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TYPE_FOOTER = <span class="hljs-number">200000</span>;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">//存储HeaderView，key值作为对应HeaderView的ItemViewType</span></span><br><span class="line"><span class="hljs-keyword">private</span> SparseArray&lt;View&gt; mHeaderViews = <span class="hljs-keyword">new</span> SparseArray&lt;&gt;(<span class="hljs-number">0</span>);</span><br><span class="line"><span class="hljs-comment">//存储FooterView，key值作为对应HeaderView的ItemViewType</span></span><br><span class="line"><span class="hljs-keyword">private</span> SparseArray&lt;View&gt; mFooterViews = <span class="hljs-keyword">new</span> SparseArray&lt;&gt;(<span class="hljs-number">0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ViewHolder <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(isHeaderViewEnable() &amp;&amp; mHeaderViews.get(viewType) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ViewHolder(mHeaderViews.get(viewType));</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(isFooterViewEnable() &amp;&amp; mFooterViews.get(viewType) != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ViewHolder(mFooterViews.get(viewType));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> onCreateItemViewHolder(parent, viewType);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(ViewHolder holder, <span class="hljs-keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(isFooterView(position) || isHeaderView(position)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T item = getItem(position - getHeaderViewCount());</span><br><span class="line">    onBindItemViewHolder(holder, position, item);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemViewType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-keyword">if</span>(isHeaderView(position)) &#123;<span class="hljs-comment">//FooterView</span></span><br><span class="line">        <span class="hljs-keyword">return</span> mHeaderViews.keyAt(position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span>(isFooterView(position))&#123;<span class="hljs-comment">//HeaderView</span></span><br><span class="line">        <span class="hljs-keyword">return</span> mFooterViews.keyAt(position - getHeaderViewCount() - getItemDataCount());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> getItemViewTypeForData(position);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">* 展示的总数据数(包括HeaderView和FooterView)</span></span><br><span class="line"><span class="hljs-comment">*</span></span><br><span class="line"><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-comment">//从写此方法，数据总数需要包括HeaderView总数和FooterView总数</span></span><br><span class="line">    <span class="hljs-keyword">return</span> getItemDataCount() + getHeaderViewCount() + getFooterViewCount();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">* 要展示的有效数据数(不包括HeaderView和FooterView)</span></span><br><span class="line"><span class="hljs-comment">*</span></span><br><span class="line"><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemDataCount</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-keyword">return</span> mList == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : mList.size();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">* 获取HeaderView的总数</span></span><br><span class="line"><span class="hljs-comment">*</span></span><br><span class="line"><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHeaderViewCount</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-keyword">return</span> isHeaderViewEnable() ? mHeaderViews.size() : <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">* 获取FooterView的总数</span></span><br><span class="line"><span class="hljs-comment">*</span></span><br><span class="line"><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFooterViewCount</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-keyword">return</span> isFooterViewEnable() ? mFooterViews.size() : <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">* 判断position位置是否为FooterView</span></span><br><span class="line"><span class="hljs-comment">*</span></span><br><span class="line"><span class="hljs-comment">* <span class="hljs-doctag">@param</span> position</span></span><br><span class="line"><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFooterView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-keyword">return</span> isFooterViewEnable() &amp;&amp; isFooterViewPosition(position);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">* 判断position位置是否为HeaderView</span></span><br><span class="line"><span class="hljs-comment">*</span></span><br><span class="line"><span class="hljs-comment">* <span class="hljs-doctag">@param</span> position</span></span><br><span class="line"><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeaderView</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-keyword">return</span> isHeaderViewEnable() &amp;&amp; isHeaderViewPosition(position);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">* 判断position位置是否为FooterView的索引</span></span><br><span class="line"><span class="hljs-comment">*</span></span><br><span class="line"><span class="hljs-comment">* <span class="hljs-doctag">@param</span> position</span></span><br><span class="line"><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFooterViewPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-keyword">return</span> position &gt;= getItemDataCount() + getHeaderViewCount();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">* 判断position位置是否为HeaderView的索引</span></span><br><span class="line"><span class="hljs-comment">*</span></span><br><span class="line"><span class="hljs-comment">* <span class="hljs-doctag">@param</span> position</span></span><br><span class="line"><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeaderViewPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-keyword">return</span> position &lt; getHeaderViewCount();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 添加一个HeaderView</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> headerView</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addHeaderView</span><span class="hljs-params">(View headerView)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-keyword">if</span>(headerView == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"headerView is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mHeaderViews.put(TYPE_HEADER + getHeaderViewCount(), headerView);</span><br><span class="line">    notifyItemInserted(getHeaderViewCount() - <span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 添加一个FooterView</span></span><br><span class="line"><span class="hljs-comment"> *</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> footerView</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFooterView</span><span class="hljs-params">(View footerView)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-keyword">if</span>(footerView == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"footerView is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mFooterViews.put(TYPE_FOOTER + getFooterViewCount(), footerView);</span><br><span class="line">    notifyItemInserted(getHeaderViewCount() + getItemDataCount() + getFooterViewCount() - <span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="RecyclerView使用注意"><a href="#RecyclerView使用注意" class="headerlink" title="RecyclerView使用注意"></a>RecyclerView使用注意</h3><ol>
<li><p>这里需要注明一点<code>RecyclerView</code>使用中的坑，如果<code>RecyclerView</code>为<code>LinearLayoutManager</code>时在<code>onCreatViewHolder</code>中生成的View都必须关联上其<code>parent</code>，也就是关联到<code>RecyclerView</code>本身。我前面的一片文章记录了我遇到的这个问题<code>RecyclerView</code>子<code>View</code>宽度不充满父容器，所以在<code>addHeaderView</code>和<code>addFooterView</code>时也需要注意这个问题</p>
</li>
<li><p>如果你的<code>RecyclerView</code>的<code>LayoutManager</code>是<code>GridLayoutManager</code>或<code>StaggeredGridLayoutManager</code>时，如果就这样添加<code>HeaderView</code>或<code>FooterView</code>，会发现<code>HeaderView</code>或<code>FooterView</code>不会独立的占据一行。这是因为设置了<code>SpanSize</code>的缘故，所以我们需要针对这两种<code>LayoutManager</code>进行处理，处理方式如下：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAttachedToRecyclerView</span><span class="hljs-params">(RecyclerView recyclerView)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-keyword">super</span>.onAttachedToRecyclerView(recyclerView);</span><br><span class="line">    <span class="hljs-keyword">final</span> RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();</span><br><span class="line">    <span class="hljs-keyword">if</span>(layoutManager <span class="hljs-keyword">instanceof</span> GridLayoutManager) &#123;</span><br><span class="line">        ((GridLayoutManager) layoutManager).setSpanSizeLookup(<span class="hljs-keyword">new</span> GridLayoutManager.SpanSizeLookup() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSpanSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">                <span class="hljs-keyword">return</span> getNewSpanSize(((GridLayoutManager) layoutManager).getSpanCount(), position);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewAttachedToWindow</span><span class="hljs-params">(ViewHolder holder)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-keyword">super</span>.onViewAttachedToWindow(holder);</span><br><span class="line">    <span class="hljs-keyword">int</span> position = holder.getLayoutPosition();</span><br><span class="line">    <span class="hljs-keyword">if</span>(isHeaderView(position) || isFooterView(position)) &#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> ViewGroup.LayoutParams layoutParams = holder.itemView.getLayoutParams();</span><br><span class="line">        <span class="hljs-keyword">if</span>(layoutParams != <span class="hljs-keyword">null</span> &amp;&amp; layoutParams <span class="hljs-keyword">instanceof</span> StaggeredGridLayoutManager.LayoutParams) &#123;</span><br><span class="line">            StaggeredGridLayoutManager.LayoutParams lp = (StaggeredGridLayoutManager.LayoutParams) layoutParams;</span><br><span class="line">            lp.setFullSpan(<span class="hljs-keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNewSpanSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> spanCount, <span class="hljs-keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-keyword">if</span>(isHeaderView(position) || isFooterView(position)) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> spanCount;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="自动加载更多"><a href="#自动加载更多" class="headerlink" title="自动加载更多"></a>自动加载更多</h3><p>自动加载更多也是列表显示中比较常见的一个功能，我们可以为<code>RecyclerView</code>设置<code>ScrollListener</code>监听来进行实现，具体实现的关键代码如下；<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">super</span>.setOnScrollListener(<span class="hljs-keyword">new</span> OnScrollListener() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onScrollStateChanged</span><span class="hljs-params">(RecyclerView recyclerView, <span class="hljs-keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="hljs-keyword">super</span>.onScrollStateChanged(recyclerView, newState);</span><br><span class="line">        <span class="hljs-keyword">if</span>(newState == SCROLL_STATE_IDLE &amp;&amp; mIsAutoLoadMore &amp;&amp; mLoadMoreListener != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(mLastVisiblePosition + <span class="hljs-number">1</span> == getAdapter().getItemCount()) &#123;</span><br><span class="line">                mLoadMoreListener.onLoadMore();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span>(mOnScrollListener != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            mOnScrollListener.onScrollStateChanged(recyclerView, newState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onScrolled</span><span class="hljs-params">(RecyclerView recyclerView, <span class="hljs-keyword">int</span> dx, <span class="hljs-keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="hljs-keyword">super</span>.onScrolled(recyclerView, dx, dy);</span><br><span class="line">        <span class="hljs-keyword">if</span>(mIsAutoLoadMore &amp;&amp; mLoadMoreListener != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            mLastVisiblePosition = getLastVisiblePosition();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span>(mOnScrollListener != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            mOnScrollListener.onScrolled(recyclerView, dx, dy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>文章相关的完整代码和Demo：<a href="https://github.com/huyongli/AndroidDemo" target="_blank" rel="noopener">https://github.com/huyongli/AndroidDemo</a></p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> RecyclerView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RecyclerView子View宽度不充满父容器]]></title>
      <url>http://ittiger.cn/recyclerview-child-view-width.html</url>
      <content type="html"><![CDATA[<p>今天用<code>RecyclerView</code>写了简单的例子，使用的是<code>LinearLyaoutManager</code>，子<code>View</code>采用的<code>TextView</code>，准备写个简单的List展示，我的<code>RecyclerView</code>和<code>TextView</code>的宽度布局都采用的是<code>match_parent</code>，结果显示出来之后发现子<code>View</code>的宽度压根就没有充满屏幕。之前也用过<code>RecyclerView</code>，但是没有遇到过这个问题，很不解啊~~~网上查阅之后说是在<code>Adapter</code>的<code>onCreateViewHolder</code>方法中构造<code>View</code>的时候不能用如下方式：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View.inflate(mContext, R.layout.item_layout, <span class="hljs-keyword">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>必须要换成下面的构造方式把parent带进去：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater.from(mContext).inflate(R.layout.item_layout, parent, <span class="hljs-keyword">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>而我的<code>Adapter</code>中刚好就使用的是第一种方式，于是立马换成下面的第二种方式实现，运行看效果，果然充满了屏幕~~~这个问题还真是奇葩啊~<br><a id="more"></a></p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> RecyclerView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RecyclerView下拉刷新上拉加载]]></title>
      <url>http://ittiger.cn/recycleview-pulldown-refresh-pullup-loadmore.html</url>
      <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>作为<code>ListView</code>和<code>GridView</code>的替代者， <code>RecyclerView</code>以它的灵活性著称，而且有着更好更完善的缓存处理机制。但是在使用<code>RecyclerVew</code>的过程中有个很明显的问题：<code>RecyclerView</code>没有为开发者提供<code>addHeadView</code>和<code>addFooterView</code>两个接口，这就为<code>RecyclerView</code>的下拉刷新和上拉加载实现增加了难度，本文就为大家介绍<code>RecyclerView</code>的下拉刷新和上拉加载的实现方式。</p>
<a id="more"></a>
<h3 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h3><p>其实<code>RecyclerView</code>的下拉刷新使用<code>SwipeRefreshLayout</code>组件实现还是非常简单的。</p>
<p><code>SwipeRefreshLayout</code>也是<code>Android SDK</code>中为我们提供的一个布局容器类，它作为容器可以为它的子元素提供下拉刷新接口，而且使用方式也非常简单，我就直接上代码了<br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">android.support.v4.widget.SwipeRefreshLayout</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/swipeRefreshLayout"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">android.support.v7.widget.RecyclerView</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/recyclerView"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">android.support.v7.widget.RecyclerView</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">android.support.v4.widget.SwipeRefreshLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这就是<code>RecyclerView</code>结合<code>SwipeRefreshLayout</code>实现下拉刷新的布局方式，非常简单吧，写完布局文件之后，当然还要处理刷新的逻辑<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mSwipeRefreshLayout.setOnRefreshListener(<span class="hljs-keyword">new</span> SwipeRefreshLayout.OnRefreshListener() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//在此处实现刷新获取数据，然后更新RecyclerView的数据源即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>写完这两段代码之后，<code>RecyclerView</code>的下拉刷新就实现完成了，是不是很简单。不过还有个小小的问题需要注意下，那就是在刷新获取数据处理逻辑结束之后需要调用<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mSwipeRefreshLayout.setRefreshing(<span class="hljs-keyword">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个接口就是告诉<code>SwipRefreshLayout</code>刷新动作已经结束，刷新进度条可以不用再显示了，否则的话视图顶部的刷新进度条会一直存在，当然如果你手动调用<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mSwipeRefreshLayout.setRefreshing(<span class="hljs-keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个接口的话，刷新进度条就会显示出来。</p>
<h3 id="上拉加载"><a href="#上拉加载" class="headerlink" title="上拉加载"></a>上拉加载</h3><p>由于<code>RecyclerView</code>中没有提供<code>addFooterView</code>接口，所以我们没有办法像<code>ListView</code>中那样直接添加一个<code>FooterView</code>作为上拉加载的视图。但是<code>RecyclerView.Adapter</code>中也提供了<code>public int getItemViewType(int position)</code>接口，我们可以为<code>RecyclerView.Adapter</code>指定两种<code>ViewType</code>，一个作为普通的<code>ItemViewType</code>用来显示普通数据视图，一个作为<code>FooterViewType</code>用来显示上拉加载视图，这样的话我们就需要在展示数据的基础上为<code>RecyclerView.Adapter</code>额外增加一条数据用来显示添加的<code>FooterView</code>，这个特定<code>Adapter</code>的实现逻辑如下：</p>
<ol>
<li><p>定义两个<code>ViewType</code>分表用来区分普通是数据视图和上拉加载视图</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> VIEW_TYPE_FOOTER = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> VIEW_TYPE_ITEM = <span class="hljs-number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写<code>getItemCount()</code>方法，在原有数据的基础上增加一条数据用来显示<code>FooterView</code></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> mList.size() + <span class="hljs-number">1</span>;<span class="hljs-comment">//在原有数据的基础增加一个数据用来显示FooterView</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写<code>getItemViewType(int position)</code>方法，用来判断当前加载显示何种视图</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemViewType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span>(position + <span class="hljs-number">1</span> == getItemCount()) &#123;<span class="hljs-comment">//最后一条数据显示FooterView</span></span><br><span class="line">        <span class="hljs-keyword">return</span> VIEW_TYPE_FOOTER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> VIEW_TYPE_ITEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>onCreateViewHolder</code>方法中根据<code>viewType</code>初始化对应的视图</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-keyword">public</span> RecyclerView.<span class="hljs-function">ViewHolder <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span>(viewType == VIEW_TYPE_FOOTER) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> onCreateFooterViewHolder(parent, viewType);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(viewType == VIEW_TYPE_ITEM) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> onCreateItemViewHolder(parent, viewType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>onBindViewHolder</code>方法中根据<code>viewType</code>绑定显示对应的视图数据</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(RecyclerView.ViewHolder holder, <span class="hljs-keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">switch</span> (getItemViewType(position)) &#123;</span><br><span class="line">        <span class="hljs-keyword">case</span> VIEW_TYPE_ITEM:</span><br><span class="line">            onBindItemViewHolder(holder, position);</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        <span class="hljs-keyword">case</span> VIEW_TYPE_FOOTER:</span><br><span class="line">            onBindFooterViewHolder(holder, position, mLoadStatus);</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        <span class="hljs-keyword">default</span>:</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>整个<code>Adapter</code>完整的代码如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">Adapter</span>&lt;<span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> LoadStatus mLoadStatus = LoadStatus.CLICK_LOAD_MORE;<span class="hljs-comment">//上拉加载的状态</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> VIEW_TYPE_FOOTER = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> VIEW_TYPE_ITEM = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;String&gt; mList;</span><br><span class="line">    <span class="hljs-keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DemoAdapter</span><span class="hljs-params">(Context context, List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        mContext = context;</span><br><span class="line">        mList = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">public</span> RecyclerView.<span class="hljs-function">ViewHolder <span class="hljs-title">onCreateViewHolder</span><span class="hljs-params">(ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span>(viewType == VIEW_TYPE_FOOTER) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> onCreateFooterViewHolder(parent, viewType);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(viewType == VIEW_TYPE_ITEM) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> onCreateItemViewHolder(parent, viewType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(RecyclerView.ViewHolder holder, <span class="hljs-keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">switch</span> (getItemViewType(position)) &#123;</span><br><span class="line">            <span class="hljs-keyword">case</span> VIEW_TYPE_ITEM:</span><br><span class="line">                onBindItemViewHolder(holder, position);</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            <span class="hljs-keyword">case</span> VIEW_TYPE_FOOTER:</span><br><span class="line">                onBindFooterViewHolder(holder, position, mLoadStatus);</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            <span class="hljs-keyword">default</span>:</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> RecyclerView.<span class="hljs-function">ViewHolder <span class="hljs-title">onCreateFooterViewHolder</span><span class="hljs-params">(ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        View view = View.inflate(mContext, R.layout.footer_layout, <span class="hljs-keyword">null</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FooterViewHolder(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> RecyclerView.<span class="hljs-function">ViewHolder <span class="hljs-title">onCreateItemViewHolder</span><span class="hljs-params">(ViewGroup parent, <span class="hljs-keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        View view = View.inflate(mContext, R.layout.item_layout, <span class="hljs-keyword">null</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ItemViewHolder(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindFooterViewHolder</span><span class="hljs-params">(RecyclerView.ViewHolder holder, <span class="hljs-keyword">int</span> position, LoadStatus loadStatus)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        FooterViewHolder viewHolder = (FooterViewHolder) holder;</span><br><span class="line">        <span class="hljs-keyword">switch</span> (loadStatus) &#123;</span><br><span class="line">            <span class="hljs-keyword">case</span> CLICK_LOAD_MORE:</span><br><span class="line">                viewHolder.mLoadingLayout.setVisibility(View.GONE);</span><br><span class="line">                viewHolder.mClickLoad.setVisibility(View.VISIBLE);</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            <span class="hljs-keyword">case</span> LOADING_MORE:</span><br><span class="line">                viewHolder.mLoadingLayout.setVisibility(View.VISIBLE);</span><br><span class="line">                viewHolder.mClickLoad.setVisibility(View.GONE);</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBindItemViewHolder</span><span class="hljs-params">(RecyclerView.ViewHolder holder, <span class="hljs-keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ItemViewHolder viewHolder = (ItemViewHolder) holder;</span><br><span class="line">        viewHolder.mTextView.setText(getItem(position));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemCount</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> mList.size() + <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getItem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> mList.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addAll</span><span class="hljs-params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">this</span>.mList.addAll(list);</span><br><span class="line">        notifyDataSetChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getItemViewType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span>(position + <span class="hljs-number">1</span> == getItemCount()) &#123;<span class="hljs-comment">//最后一条为FooterView</span></span><br><span class="line">            <span class="hljs-keyword">return</span> VIEW_TYPE_FOOTER;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> VIEW_TYPE_ITEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reSetData</span><span class="hljs-params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">this</span>.mList = list;</span><br><span class="line">        notifyDataSetChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLoadStatus</span><span class="hljs-params">(LoadStatus loadStatus)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">this</span>.mLoadStatus = loadStatus;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItemViewHolder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> TextView mTextView;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ItemViewHolder</span><span class="hljs-params">(View itemView)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">super</span>(itemView);</span><br><span class="line">        mTextView = (TextView) itemView.findViewById(R.id.textView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooterViewHolder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">ViewHolder</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> LinearLayout mLoadingLayout;</span><br><span class="line">    <span class="hljs-keyword">public</span> TextView mClickLoad;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FooterViewHolder</span><span class="hljs-params">(View itemView)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">super</span>(itemView);</span><br><span class="line">        mLoadingLayout = (LinearLayout) itemView.findViewById(R.id.loading);</span><br><span class="line">        mClickLoad = (TextView) itemView.findViewById(R.id.click_load_txt);</span><br><span class="line">        mClickLoad.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;<span class="hljs-comment">//添加点击加载更多监听</span></span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                loadMore();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> LoadStatus &#123;</span><br><span class="line">   </span><br><span class="line">    CLICK_LOAD_MORE,<span class="hljs-comment">//点击加载更多</span></span><br><span class="line">    LOADING_MORE<span class="hljs-comment">//正在加载更多</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>FooterView</code>的布局如下：<br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="hljs-tag">              <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">              <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"40dp"</span></span></span><br><span class="line"><span class="hljs-tag">              <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"center_horizontal"</span></span></span><br><span class="line"><span class="hljs-tag">              <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"horizontal"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/loading"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"horizontal"</span>&gt;</span></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">ProgressBar</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"center_vertical"</span></span></span><br><span class="line"><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">"正在加载..."</span>/&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/click_load_txt"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:paddingTop</span>=<span class="hljs-string">"5dp"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:paddingBottom</span>=<span class="hljs-string">"5dp"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">"点击加载更多"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:visibility</span>=<span class="hljs-string">"gone"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ol start="6">
<li>写完<code>Adapter</code>的<code>FooterView</code>视图适配之后，我们还有一个重要的步骤需要做，在哪里实现加载更多的逻辑处理</li>
</ol>
<p>其实<code>RecyclerView</code>也为我们提供了<code>mRecyclerView.setOnScrollListener(new RecyclerView.OnScrollListener() )</code>接口，这样我们就看一看通过这个接口来判断什么时候调用加载更多的实现接口，关键代码如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mRecyclerView.setOnScrollListener(<span class="hljs-keyword">new</span> RecyclerView.OnScrollListener() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onScrollStateChanged</span><span class="hljs-params">(RecyclerView recyclerView, <span class="hljs-keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">super</span>.onScrollStateChanged(recyclerView, newState);</span><br><span class="line">        <span class="hljs-keyword">if</span> (newState == RecyclerView.SCROLL_STATE_IDLE</span><br><span class="line">                &amp;&amp; mLastVisibleItemPosition + <span class="hljs-number">1</span> == mAdapter.getItemCount()) &#123;</span><br><span class="line"></span><br><span class="line">            loadMore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onScrolled</span><span class="hljs-params">(RecyclerView recyclerView, <span class="hljs-keyword">int</span> dx, <span class="hljs-keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">super</span>.onScrolled(recyclerView, dx, dy);</span><br><span class="line">        mLastVisibleItemPosition = mLayoutManager.findLastVisibleItemPosition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>整个<code>Demo</code>的<code>Activity</code>的实现如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> RecyclerView mRecyclerView;</span><br><span class="line">    <span class="hljs-keyword">private</span> SwipeRefreshLayout mSwipeRefreshLayout;</span><br><span class="line">    <span class="hljs-keyword">private</span> DemoAdapter mAdapter;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mLastVisibleItemPosition = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> LinearLayoutManager mLayoutManager;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mRecyclerView = (RecyclerView) findViewById(R.id.recyclerView);</span><br><span class="line">        mSwipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.swipeRefreshLayout);</span><br><span class="line"></span><br><span class="line">mLayoutManager = <span class="hljs-keyword">new</span> LinearLayoutManager(<span class="hljs-keyword">this</span>);</span><br><span class="line">        mRecyclerView.setLayoutManager(mLayoutManager);</span><br><span class="line">        mRecyclerView.setItemAnimator(<span class="hljs-keyword">new</span> DefaultItemAnimator());</span><br><span class="line"> </span><br><span class="line">        mAdapter = <span class="hljs-keyword">new</span> DemoAdapter(<span class="hljs-keyword">this</span>, getData(<span class="hljs-string">"init"</span>));</span><br><span class="line">        mRecyclerView.setAdapter(mAdapter);</span><br><span class="line">        mSwipeRefreshLayout.setOnRefreshListener(<span class="hljs-keyword">new</span> SwipeRefreshLayout.OnRefreshListener() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRefresh</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">                <span class="hljs-keyword">new</span> Thread() &#123;</span><br><span class="line">                    <span class="hljs-meta">@Override</span></span><br><span class="line">                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">                        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="hljs-number">3000</span>);</span><br><span class="line">                            <span class="hljs-keyword">final</span> List&lt;String&gt; list = getData(<span class="hljs-string">"refresh"</span>);</span><br><span class="line">                            runOnUiThread(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">                                <span class="hljs-meta">@Override</span></span><br><span class="line">                                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">                                    mAdapter.reSetData(list);</span><br><span class="line">                                    mSwipeRefreshLayout.setRefreshing(<span class="hljs-keyword">false</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        mRecyclerView.setOnScrollListener(<span class="hljs-keyword">new</span> RecyclerView.OnScrollListener() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onScrollStateChanged</span><span class="hljs-params">(RecyclerView recyclerView, <span class="hljs-keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">                <span class="hljs-keyword">super</span>.onScrollStateChanged(recyclerView, newState);</span><br><span class="line">                <span class="hljs-keyword">if</span> (newState == RecyclerView.SCROLL_STATE_IDLE</span><br><span class="line">                        &amp;&amp; mLastVisibleItemPosition + <span class="hljs-number">1</span> == mAdapter.getItemCount()) &#123;</span><br><span class="line"> </span><br><span class="line">                    loadMore();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onScrolled</span><span class="hljs-params">(RecyclerView recyclerView, <span class="hljs-keyword">int</span> dx, <span class="hljs-keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">                <span class="hljs-keyword">super</span>.onScrolled(recyclerView, dx, dy);</span><br><span class="line">                mLastVisibleItemPosition = mLayoutManager.findLastVisibleItemPosition();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadMore</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        mAdapter.setLoadStatus(LoadStatus.LOADING_MORE);</span><br><span class="line">        <span class="hljs-keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="hljs-number">3000</span>);</span><br><span class="line">                    <span class="hljs-keyword">final</span> List&lt;String&gt; list = getData(<span class="hljs-string">"load more"</span>);</span><br><span class="line">                    runOnUiThread(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="hljs-meta">@Override</span></span><br><span class="line">                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">                            mAdapter.addAll(list);</span><br><span class="line">                            mAdapter.setLoadStatus(LoadStatus.CLICK_LOAD_MORE);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">getData</span><span class="hljs-params">(String flag)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="hljs-keyword">int</span> idx = <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span>(mAdapter != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            idx = mAdapter.getItemCount();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">10</span>);</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;</span><br><span class="line">            list.add(flag + <span class="hljs-string">":"</span> + (idx + i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上就是我针对<code>RecyclerView</code>的下拉刷新上拉加载的实现方式。</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> RecyclerView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AndroidStudio使用技巧]]></title>
      <url>http://ittiger.cn/AndroidStudio-tips.html</url>
      <content type="html"><![CDATA[<h3 id="AndroidStudio使用技巧"><a href="#AndroidStudio使用技巧" class="headerlink" title="AndroidStudio使用技巧"></a>AndroidStudio使用技巧</h3><p>本文主要是记录从我使用AndroidStudio以来遇到的一些问题和一些技巧。</p>
<hr>
<ol>
<li>初次使用AndroidStudio，第一次创建Android工程编译时会比较慢，这中间涉及到三个过程：<ol>
<li>可能会去下载最新的SDK，所以在创建工程之前可以先将SDK更新完成</li>
<li>AndroidStudio工程会使用gradle构建，因此会联网下载gradle，这个过程比较慢要耐心等待</li>
<li>下载工程中的一些依赖包，比如junit</li>
</ol>
</li>
<li>有时候使用AndroidStudio进行rebuild和clean时，会报错如下：<code>Failed to complete gradle execution cause by...</code>，一般此错误可以通过设置gradle的VM参数解决： -Xmx256m<code>(设置方式为：File &gt; Setting &gt; Gradle &gt; Gradle Vm Option)</code>，如果此方法无效，可以选择直接升级AS的版本到最新版本再试，还有其他可能的原因是工程JDK版本与AS设置的JDK版本不同</li>
<li>设置AndroidStudio的不同主题背景： <code>File &gt; Setting &gt; Appearance&amp;Behavior &gt; Appearance</code> 下的Theme可以选择你要使用的主题</li>
</ol>
<a id="more"></a>
<ol start="4">
<li>设置编辑区的字体和字体大小:<code>File &gt; Setting &gt; Editor &gt; Color&amp;Fonts &gt; Font</code>,在右边需要先将主题另存之后，再去编辑字体和大小</li>
<li>自定义AS的Logcat里不同级别的日志文字的颜色:<code>File &gt; Setting &gt; Editor &gt; Color&amp;Fonts &gt; Android Logcat</code>,同样需要先另存当前主题之后才能自定义给个级别的日志文字颜色</li>
<li>鼠标移动到某个变量和类上面显示提示信息的设置：<code>File &gt; Setting &gt; Editor &gt; 点击下面的General,在右边选中Show quick doc on mouse move Delay</code></li>
<li>设置代码行号一直显示而不是重启后又不显示了：<code>File &gt; Setting &gt; Editor &gt; General &gt; Appearance,在右边选中Show Line numbers</code></li>
<li>快速按Shift键两次，调出文件全局搜索对话框(根据文件名搜索)，可以搜索Java文件和资源文件</li>
<li>Ctrl+H   全局文本搜索快捷键，可以搜索全部文本内容，包括资源文件</li>
<li>Ctrl+T：打开某个方法的实现类，打开某个id的资源文件</li>
<li>工程中设置使用本地安装的gradle进行构建，而不是联网下载gradle最新版本： 打开android-studio/plugins/android/lib/templates/gradle/wrapper/gradle/wrapper/gradle-wrapper.properties，修改<br>distributionUrl=file\:/home/zzq/.gradle/distribution/gradle-2.2.1-all.zip</li>
<li>AndroidStudio启动时默认直接就打开了上次打开的工程，没有像第一次启动那样可以选择，此问题可以这样解决：<code>File &gt; Setting &gt; Appearance &amp; Behavior &gt; System Settings下将Reopen last project on startup</code>的选择取消掉，设置为非选中状态即可</li>
<li>支持驼峰命令选择<code>File &gt; Setting &gt; Editor &gt; General &gt; Smart Keys</code>，在右边选择<code>Use &quot;CamelHumps&quot; words</code>，此时如果仍然希望当鼠标在单词上双击之后选中整个单词，需要如下设置：<code>File &gt; Setting &gt; Editor &gt; General</code>，在右边取消选中 <code>Honor &quot;CamelHumps&quot; words settings when selecting  on double click</code></li>
<li>给代码的变量名添加前缀，如非静态成员变量以’m’开头，请如下设置：<code>File &gt; Setting &gt; Editor &gt; Code Style &gt; Java</code>，在右边选择<code>Code Generation</code>，然后给要配置的相关字的添加前缀</li>
<li><code>File &gt; Setting &gt; Appearance&amp;Behavior &gt;SystemSetting &gt; HttpProxy</code>下设置代理不起作用时，可以在工程目录下的gradle.properties文件中添加代理设置即可：<ol>
<li><code>systemProp.http.proxyHost=ip地址</code></li>
<li><code>systemProp.http.proxyPort=端口</code></li>
<li><code>systemProp.https.proxyHost=ip地址</code></li>
<li><code>systemProp.https.proxyPort=端口</code></li>
</ol>
</li>
<li>AS创建Module时，在资源目录res下只生成了mipmap等资源文件夹，此文件夹主要是用来存放应用启动图标的，其他的图片资源文件还是应该放在drawable等文件夹中。为了在创建Module时同时也生成对应的drawable文件夹，只需要做如下配置：<ol>
<li>进入Android Studio的安装目录</li>
<li>依次进入<code>plugins/android/lib/templates/gradle-projects/NewAndroidModule</code></li>
<li>用边界器打开<code>recipe.xml.ftl</code>文件，在<code>&lt;mkdir at=&quot;${escapeXmlAttribute(resOut)}/drawable&quot; /&gt;</code>下方依次加入下面三行配置：<ol>
<li><code>mkdir at=&quot;${escapeXmlAttribute(resOut)}/drawable-hdpi&quot;</code></li>
<li><code>mkdir at=&quot;${escapeXmlAttribute(resOut)}/drawable-xhdpi&quot;</code></li>
<li><code>mkdir at=&quot;${escapeXmlAttribute(resOut)}/drawable-xxhdpi&quot;</code></li>
</ol>
</li>
<li>通过类似的方式还可以在colors.xml文件中生成常用颜色</li>
<li>在<code>build.gralde</code>中生成自定义配置</li>
<li>在.gitignore文件中生成自定义忽略文件配置</li>
</ol>
</li>
<li>配置代码模板， Android Studio中提供了很多方便的活动模板<code>(Live Templates)</code>，例如：输入sout后按enter键，Android Studio会自动帮我们写入<code>System.out.println();</code>其实sout就是AS自带的一个活动模板：<ol>
<li>先打开：<code>File &gt; Setting &gt; Editor &gt; Live Templates</code></li>
<li>点击最右侧的加号并选择<code>Template Group</code></li>
<li>在弹出的对话框中输入一个活动模板分组的名称，如:<code>custom</code></li>
<li>在左侧选中上一步创建的custom分组，点击右边的加号</li>
<li>选择<code>Live Template</code>，在<code>Abbreviation</code>中对输入模板简写方式，如：sout</li>
<li>在<code>Description</code>中输入这个活动模板的描述</li>
<li>在<code>Template Text</code>中输入模板代码，如：<code>System.out.println();</code></li>
<li>点击下方的Define按钮，选中Java表示这个模板用于Java代码</li>
<li>点击右侧的<code>Edit variables</code></li>
<li>选择Expression下拉框中的<code>className</code>并勾选<code>Skip if...</code>   这个操作的作用是AS会自动将我们在上一步中用<code>&#39;$&#39;</code>符包裹的<code>className</code>自动替换为当前类不含包含的类名</li>
<li>点击<code>Apply</code>和<code>ok</code>让设置生效</li>
<li>至此，我们自定义的<code>custom</code>模板组中的psh活动模板就自定义完成</li>
</ol>
</li>
<li><code>Android Studio</code>添加本地jar包依赖，在Module的<code>build.gradle</code>文件中进行如下方式配置<ol>
<li><code>compile files(&#39;libs/TigerDB.jar&#39;)</code>添加某个单一jar包的依赖</li>
<li><code>compile fileTree(dir: &#39;libs&#39;,include: [&#39;*.jar&#39;])</code>  将libs目录下的jar包全部添加为依赖</li>
</ol>
</li>
<li>持续更新…</li>
</ol>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> AndroidStudio </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[UC浏览器首页滑动动画实现]]></title>
      <url>http://ittiger.cn/uc-main-page-for-animation.html</url>
      <content type="html"><![CDATA[<h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="/img/20160526232223237.gif" alt><br><a id="more"></a><br><img src="/img/20160526232223238.gif" alt></p>
<p><img src="/img/20160526232403427.gif" alt></p>
<h3 id="UC浏览器首页效果"><a href="#UC浏览器首页效果" class="headerlink" title="UC浏览器首页效果"></a>UC浏览器首页效果</h3><p>我们先来看下UC浏览器首页的滑动动画和我最终实现的动画效果<br><img src="/img/20160526232024470.gif" alt></p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">cn.ittiger.ucpage.view.UCIndexView</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">xmlns:ucindexview</span>=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/ucindexview"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">ucindexview:pageHeadViewHeight</span>=<span class="hljs-string">"@dimen/dp_40"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">ucindexview:isPageHeadViewFixed</span>=<span class="hljs-string">"false"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">ucindexview:isContentHeadViewEnable</span>=<span class="hljs-string">"true"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">ucindexview:isPullRestoreEnable</span>=<span class="hljs-string">"false"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">ucindexview:contentHeadViewHeight</span>=<span class="hljs-string">"@dimen/dp_40"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">ucindexview:pageNavigationViewHeight</span>=<span class="hljs-string">"@dimen/dp_200"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">ucindexview:pageHeadViewLayoutId</span>=<span class="hljs-string">"@layout/page_head_view_layout"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">ucindexview:pageNavigationViewLayoutId</span>=<span class="hljs-string">"@layout/page_navigation_view_layout"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">ucindexview:contentHeadViewLayoutId</span>=<span class="hljs-string">"@layout/content_head_view_layout"</span></span></span><br><span class="line"><span class="hljs-tag">    <span class="hljs-attr">ucindexview:contentViewLayoutId</span>=<span class="hljs-string">"@layout/content_view_layout"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">cn.ittiger.ucpage.view.UCIndexView</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用方式只需要如此布局即可，没有其他的任何代码操作，非常简单。几个重要属性如下：</p>
<ol>
<li><code>isPageHeadViewFixed：</code>设置<code>PageHeadView</code>是否固定显示(效果如上图2)</li>
<li><code>isContentHeadViewEnable：</code>设置<code>ContentHeadView</code>是否启用(效果如上图3)</li>
<li><code>isPullRestoreEnable：</code>设置是否可以通过下拉手势恢复到初始状态，UC首页下拉不能恢复初始状态</li>
<li><code>contentHeadViewHeight：</code>设置<code>contentHeadView</code>视图的高度</li>
<li><code>pageNavigationViewHeight：</code>设置<code>PageNavigationView</code>视图的高度</li>
<li><code>pageHeadViewLayoutId：</code>设置<code>PagetHeadView</code>视图的内容布局，如图中的文字UC头条布局</li>
<li><code>pageNavigationViewLayoutId：</code>设置<code>PageNavigationView</code>视图的内容布局，如图中的文字网址导航布局</li>
<li><code>contentHeadViewLayoutId：</code>设置<code>ContentHeadViev</code>视图的内容布局，如图中的文字新闻头部导航布局</li>
<li><code>contentViewLayoutId：</code>设置<code>ContentView</code>视图的内容布局，如图中的文字新闻内容区布局</li>
</ol>
<h3 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a>github地址</h3><p>实现及Demo地址：<a href="https://github.com/huyongli/UCIndexAnimation" target="_blank" rel="noopener">https://github.com/huyongli/UCIndexAnimation</a></p>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>下面来讲讲我的实现过程：</p>
<p><font color="red">首先来分析下UC首页这个动画中涉及到的元素和要点</font></p>
<ol>
<li>向上滑动过程顶部的UC头条会慢慢的显示出来，我把这部分视图称为：<code>PageHeadView(页面头部视图)</code>，很明显其初始化时是在屏幕外部的</li>
<li>向上滑动过程中UC漫站上面会有个新闻Tab菜单头部慢慢的显示出来，我把这部分视图称为：<code>ContentHeadView(新闻头部视图)</code>，初始时是被<code>ContentView</code>遮盖，而后慢慢滑出，显然它的滑动速度是比<code>ContentView</code>快的</li>
<li>向上滑动过程中天气、搜索、网站导航会稍微往上滑动一段距离最终隐藏，我把这部分视图称为：<code>PageNavigationView(页面导航视图)</code>，随着不断的滑动，会慢慢的被其余三个视图共同遮盖掉</li>
<li>UC漫站整个新闻内容视图慢慢的向上滑动直至跟UC头条相接，我把这部分称为：<code>ContentView(新闻内容视图)</code></li>
<li>根据动画效果来看，上面所说的四个不同的视图部分都是同时停止滑动，但是他们滑动的距离明显是不相同的</li>
<li><code>PageHeadView</code>滑动的距离为其自身高度，</li>
<li><code>ContentHeadView</code>的滑动距离为其自身高度与<code>ContentView</code>滑动的距离之和，而其相对<code>ContentView</code>视图的滑动距离为其自身高度</li>
<li><code>ContentView</code>滑动距离为其自身初始距离顶部的边距减去 <code>PageHeadView</code>和<code>ContentHeadView</code>两者的高度</li>
<li><code>PageNavigationView</code>的滑动距离很小</li>
<li>上面的分析把UC首页整体划分成四个不同的View部分，另外其首页中只有<code>ContentView、PageNavigationView</code>两个视图会处理滑动事件<h3 id="实现技术点和细节"><a href="#实现技术点和细节" class="headerlink" title="实现技术点和细节"></a>实现技术点和细节</h3>根据上面的分析我们知道有三个视图是从被遮盖到显示或者是从显示到遮盖，剩下的<code>ContentView</code>一直是遮盖其他的视图。根据视图遮盖很容易联想到<code>FrameLayout</code>布局，多个<code>FrameLayout</code>布局叠加在一起就类似PS中的图层叠加，滑动可以看成是不同层级的<code>FrameLayout</code>的<code>marginTop</code>不断变化的过程。</li>
</ol>
<h3 id="实现类结构图"><a href="#实现类结构图" class="headerlink" title="实现类结构图"></a>实现类结构图</h3><p>我的实现中先要说明两点：</p>
<ol>
<li>我把上滑称为展示状态或者叫Show状态</li>
<li>下滑称为恢复初始化状态或者叫Hide状态<br>下图是我的实现类结构图：<br><img src="/img/20160527182733173.png" alt></li>
</ol>
<h3 id="主要类实现解析"><a href="#主要类实现解析" class="headerlink" title="主要类实现解析"></a>主要类实现解析</h3><ol>
<li><code>UCIndexView：</code>模仿UC首页的最终实现，使用时在布局文件中使用此类即可</li>
<li><code>PageHeadView、PageNavigationView、ContentView、ContentHeadView：</code>这四个类的作用见我上面的分析</li>
<li><code>MoveView：</code>页面四个视图的基类，主要包含滑动过程中的一些基本属性和方法</li>
<li><code>mNeedMoveHeight：</code>视图需要滑动的距离(<code>ContentHeadView</code>的此属性设置为相对<code>ContentView</code>的滑动距离)，此属性主要用来计算各自视图在滑动过程中的步长</li>
<li><code>mShowStopMarginTop：</code>视图进行Show操作时，当视图的<code>marginTop</code>值等于该值时，结束Show操作。此值用来确定上滑过程中，视图滑动结束时的位置。</li>
<li><code>mHideStopMarginTop：</code>视图进行Hide操作时，当视图的<code>marginTop</code>值等于该值时，结束Hide操作。此值用来确定下滑过程中，视图滑动结束时的位置。通常此值为视图初始化成功后的<code>marginTop</code>值。</li>
<li><code>getMarginTop()：</code>获取视图当前的<code>marginTop</code>值</li>
<li><code>updateMarginTop(flaot step)：</code>根据当前的滑动步长更新视图的<code>marginTop</code>值</li>
<li><code>isHideFinish()：</code>判断当前视图的Hide操作是否完成</li>
<li><code>isShowFinish()：</code>判断当前视图的Show操作是否完成</li>
<li><code>getShowMoveStep(float step)：</code>获取视图<code>Show</code>过程中的实际可滑动步长，有可能计算得到的滑动步长超过了视图的可滑动距离</li>
<li><code>getHideMoveStep(float step)：</code>获取视图Hide过程中的实际可滑动步长，有可能计算得到的滑动步长超过了视图的可滑动距离</li>
<li><code>TouchMoveView：</code>用来处理手指触摸事件从而滑动的视图基类<h3 id="滑动事件处理"><a href="#滑动事件处理" class="headerlink" title="滑动事件处理"></a>滑动事件处理</h3>直接上代码：<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onTouchMoveEvent</span><span class="hljs-params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            mLastTouchY = event.getRawY();</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="hljs-comment">//手指滑动过程中的滑动步长</span></span><br><span class="line">            mDelY = event.getRawY() - mLastTouchY;</span><br><span class="line">            viewMove(mDelY, mIsPullRestoreEnable);</span><br><span class="line">            mLastTouchY = event.getRawY();</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="hljs-keyword">int</span> offset = <span class="hljs-number">0</span>;</span><br><span class="line">            <span class="hljs-keyword">if</span>(mDelY &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//hide，下拉</span></span><br><span class="line">                <span class="hljs-keyword">if</span>(!mIsPullRestoreEnable) &#123;<span class="hljs-comment">//当前不允许下拉恢复</span></span><br><span class="line">                    <span class="hljs-keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                offset = mContentView.getHideOffset();</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//show， 上拉</span></span><br><span class="line">                offset = mContentView.getShowOffset();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span>(offset &lt;= mPageHeadView.getNeedMoveHeight() / <span class="hljs-number">2</span>) &#123;<span class="hljs-comment">//没有滑过二分之一高度</span></span><br><span class="line">                slip(-mDelY, mIsPullRestoreEnable);</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                slip(mDelY, mIsPullRestoreEnable);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 对所有视图进行滑动操作</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> delY                  当前的滑动步长</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> isPullRestoreEnable   是否允许下拉恢复</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">viewMove</span><span class="hljs-params">(<span class="hljs-keyword">float</span> delY, <span class="hljs-keyword">boolean</span> isPullRestoreEnable)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-keyword">float</span> step = Math.abs(delY);</span><br><span class="line">    <span class="hljs-comment">//根据滑动距离的比例计算PageHeadView的滑动步长</span></span><br><span class="line">    <span class="hljs-keyword">float</span> pageHeadViewStep = step * mPageHeadView.getNeedMoveHeight() / mContentView.getNeedMoveHeight();</span><br><span class="line">    <span class="hljs-comment">//手指滑动距离作为ContentView的滑动步长</span></span><br><span class="line">    <span class="hljs-keyword">float</span> contentViewStep = step;</span><br><span class="line">    <span class="hljs-comment">//ContentHeadView初始不固定显示时，其实际滑动步长为ContentView的滑动步长加上其相对ContentView的滑动步长</span></span><br><span class="line">    <span class="hljs-keyword">float</span> contentHeadViewStep = mIsContentHeadViewEnable ? step + step * mContentHeadView.getNeedMoveHeight() / mContentView.getNeedMoveHeight() : <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">float</span> pageNavigationViewStep = step * mPageNavigationView.getNeedMoveHeight() / mContentView.getNeedMoveHeight();</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-keyword">if</span>(delY &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//下滑</span></span><br><span class="line">        <span class="hljs-keyword">if</span>(!isPullRestoreEnable) &#123;<span class="hljs-comment">//当前不允许下拉恢复</span></span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span>(!isHideFinish()) &#123;<span class="hljs-comment">//恢复状态是否已完成</span></span><br><span class="line">            <span class="hljs-keyword">if</span>(mIsPageHeadViewFixed == <span class="hljs-keyword">false</span>) &#123;</span><br><span class="line">                mPageHeadView.onHideAnimation(pageHeadViewStep);</span><br><span class="line">            &#125;</span><br><span class="line">            mContentView.onHideAnimation(contentViewStep);</span><br><span class="line">            <span class="hljs-keyword">if</span>(mIsContentHeadViewEnable) &#123;</span><br><span class="line">                mContentHeadView.onHideAnimation(contentHeadViewStep);</span><br><span class="line">            &#125;</span><br><span class="line">            mPageNavigationView.onHideAnimation(pageNavigationViewStep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//上滑</span></span><br><span class="line">        <span class="hljs-keyword">if</span>(!isShowFinish()) &#123;<span class="hljs-comment">//展示状态是否已完成</span></span><br><span class="line">            <span class="hljs-keyword">if</span>(mIsPageHeadViewFixed == <span class="hljs-keyword">false</span>) &#123;<span class="hljs-comment">//PageHeadView没有被固定时才进行滑动</span></span><br><span class="line">                mPageHeadView.onShowAnimation(pageHeadViewStep);</span><br><span class="line">            &#125;</span><br><span class="line">            mContentView.onShowAnimation(contentViewStep);</span><br><span class="line">            <span class="hljs-keyword">if</span>(mIsContentHeadViewEnable) &#123;<span class="hljs-comment">//ContentHeadView启用时才进行滑动</span></span><br><span class="line">                mContentHeadView.onShowAnimation(contentHeadViewStep);</span><br><span class="line">            &#125;</span><br><span class="line">            mPageNavigationView.onShowAnimation(pageNavigationViewStep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">```java</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 手指松开屏幕后，视图自动滑动</span></span><br><span class="line"><span class="hljs-comment"> * 每隔 mAutoSlipTimeStep 长时间滑动 mAutoSlipStep 距离</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> delY  当前的滑动距离</span></span><br><span class="line"><span class="hljs-comment"> *  <span class="hljs-doctag">@param</span> isPullRestoreEnable   是否允许下拉恢复</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">slip</span><span class="hljs-params">(<span class="hljs-keyword">float</span> delY, <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> isPullRestoreEnable)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-keyword">if</span>(delY &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//当前滑动为向下滑动，即处于恢复状态</span></span><br><span class="line">        <span class="hljs-keyword">if</span>(isHideFinish()) &#123;<span class="hljs-comment">//已经恢复结束</span></span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postDelayed(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">                viewMove(mAutoSlipStep, isPullRestoreEnable);</span><br><span class="line">                slip(mAutoSlipStep, isPullRestoreEnable);<span class="hljs-comment">//准备下一次滑动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, mAutoSlipTimeStep);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//当前滑动为向上滑动，即处于展示状态</span></span><br><span class="line">        <span class="hljs-keyword">if</span>(isShowFinish()) &#123;<span class="hljs-comment">//已经展示结束</span></span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postDelayed(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">                viewMove(-mAutoSlipStep, isPullRestoreEnable);</span><br><span class="line">                slip(-mAutoSlipStep, isPullRestoreEnable);<span class="hljs-comment">//准备下一次滑动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, mAutoSlipTimeStep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中我把手指每次的滑动距离当做<code>ContentView</code>的滑动步长，再根据<code>ContentView</code>的滑动步长计算其他视图的当前滑动步长，计算具体方式可以看代码中的注释。</p>
<p>其实上面代码里的实现步骤还是比较清晰简单的，主要是如下几个步骤：</p>
<ol>
<li>在<code>MotionEvent.MOVE</code>中先得到当前手指滑动的距离，此距离作为<code>ContentView</code>的此次滑动步长</li>
<li>根据<code>ContentView</code>的滑动步长计算其他三个视图的滑动步长</li>
<li>根据当前是上滑还是下滑，判断是否滑动结束，没有结束则按照计算得到的步长继续对View进行滑动处理</li>
<li>当手指松开后，在<code>MotionEvent.UP</code>中判断<code>ContentView</code>的滑动距离是否达到了<code>PageHeadView</code>高度的一半，从而决定是继续同方向滑动至结束还是恢复到原状态</li>
<li>手指松开后，最终调用slip方法开始自动循环滑动处理，直至滑动结束</li>
</ol>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RecyclerView绘制原理]]></title>
      <url>http://ittiger.cn/recyclerview-draw-principle.html</url>
      <content type="html"><![CDATA[<h3 id="RecyclerView基本使用"><a href="#RecyclerView基本使用" class="headerlink" title="RecyclerView基本使用"></a>RecyclerView基本使用</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//首先设置RecyclerView的布局管理模式</span></span><br><span class="line">mRecyclerView.setLayoutManager(<span class="hljs-keyword">new</span> LinearLayoutManager(<span class="hljs-keyword">this</span>));</span><br><span class="line">mAdapter = <span class="hljs-keyword">new</span> MyAdapter(getData());</span><br><span class="line"><span class="hljs-comment">//设置Item项的UI装饰器</span></span><br><span class="line">mRecyclerView.addItemDecoration(<span class="hljs-keyword">new</span> RecyclerItemDecoration(LinearLayoutManager.VERTICAL));</span><br><span class="line"><span class="hljs-comment">//设置Item项的不同操作的动画</span></span><br><span class="line">mRecyclerView.setItemAnimator(<span class="hljs-keyword">new</span> DefaultItemAnimator());</span><br><span class="line"><span class="hljs-comment">//设置数据开始装配</span></span><br><span class="line">mRecyclerView.setAdapter(mAdapter);</span><br><span class="line">RecyclerView原理分析</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Adapter数据适配"><a href="#Adapter数据适配" class="headerlink" title="Adapter数据适配"></a>Adapter数据适配</h3><p><code>RecyclerView.Adapter</code>类中有一个很重要的属性：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//Adapter中被观察对象</span></span><br><span class="line">Observale&lt;AdapterDataObserver&gt;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AdapterDataObservable mObservable = <span class="hljs-keyword">new</span> AdapterDataObservable();</span><br></pre></td></tr></table></figure></p>
<p><code>RecyclerView</code>中也有一个很重要的属性<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//数据观察者, AdapterDataObserver实例</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RecyclerViewDataObserver mObserver = <span class="hljs-keyword">new</span> RecyclerViewDataObserver();</span><br></pre></td></tr></table></figure></p>
<p>当使用<code>recyclerView.setAdapter(data)</code>设置数据时，会调用以下方法使得<code>RecyclerView</code>成为Adapter的观察者(间接)：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAdapterInternal</span><span class="hljs-params">(Adapter adapter, </span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> compatibleWithPrevious,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">boolean</span> removeAndRecycleViews)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="hljs-keyword">if</span> (adapter != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">//通过此处添加观察者，此时RecyclerView就会对Adapter中的数据进行观察监听</span></span><br><span class="line">        adapter.registerAdapterDataObserver(mObserver);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常当我们改变Adapter中的数据源时，一般都会通过调用<code>Adapter.notifyDataSetChanged()</code>方法来刷新列表，我们来看看这个方法的实现，看看Adapter是如何通过这个方法来刷新列表的：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyDataSetChanged</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    mObservable.notifyChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们接着看<code>AdapterDataObservable.notifyChanged()</code>方法实现：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//mObservers是Observable中的属性，是一个ArrayList&lt;T&gt;</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyChanged</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mObservers.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;</span><br><span class="line">        mObservers.get(i).onChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再来看<code>RecyclerViewDataObserver.onChanged()</code>方法：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onChanged</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="hljs-comment">//Adapter目前没有待更新的数据</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (!mAdapterHelper.hasPendingUpdates()) &#123;</span><br><span class="line">        requestLayout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到<code>requestLayout()</code>这个方法，我们就明白了，调用此方法后系统会重新<code>measure, layout, draw</code>，这样列表视图就会被更新。</p>
<h3 id="RecyclerView-onMeasure"><a href="#RecyclerView-onMeasure" class="headerlink" title="RecyclerView.onMeasure()"></a>RecyclerView.onMeasure()</h3><p>我们来看看<code>RecyclerView</code>的测量方法<code>onMeasure</code>：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMeasure</span><span class="hljs-params">(<span class="hljs-keyword">int</span> widthSpec, <span class="hljs-keyword">int</span> heightSpec)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="hljs-keyword">if</span> (mLayout.mAutoMeasure) &#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> widthMode = MeasureSpec.getMode(widthSpec);</span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> heightMode = MeasureSpec.getMode(heightSpec);</span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> skipMeasure = widthMode == MeasureSpec.EXACTLY  &amp;&amp; heightMode == MeasureSpec.EXACTLY;</span><br><span class="line">        <span class="hljs-comment">//委托给LayoutManager来进行测量</span></span><br><span class="line">        mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec);</span><br><span class="line">        <span class="hljs-keyword">if</span> (skipMeasure || mAdapter == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">            dispatchLayoutStep1();</span><br><span class="line">        &#125;</span><br><span class="line">        mLayout.setMeasureSpecs(widthSpec, heightSpec);</span><br><span class="line">        mState.mIsMeasuring = <span class="hljs-keyword">true</span>;</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">        mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec);</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面<code>onMeasure</code>方法中<code>mLayout</code>变量就是我们上面设置的<code>LinearLayoutManager</code>实例，而<code>LinearLayoutManager</code>的构造函数中给变量<code>mAutoMeasure</code>值设置为true，因此测量时就会执行上面的代码，通过上面的方法我们可以看到此处测量分为两种：</p>
<p>当<code>RecyclerView</code>的宽高设置为<code>match_parent</code>或具体值的时候，<code>skipMeasure=true</code>，此时会只需要测量其自身的宽高就可以知道RecyclerView的大小，这时是<code>onMeasure</code>方法测量结束。<br>当RecyclerView的宽高设置为<code>wrap_content</code>时，<code>skipMeasure=false</code>，<code>onMeasure</code>会继续执行下面的<code>dispatchLayoutStep2()</code>，其实就是测量RecyclerView的子视图的大小最终确定<code>RecyclerView</code>的实际大小，这种情况真正的测量操作都是在方法<code>dispatchLayoutStep2()</code>里执行的:<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchLayoutStep2</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mState.mItemCount = mAdapter.getItemCount();</span><br><span class="line">    <span class="hljs-comment">// Step 2: Run layout</span></span><br><span class="line">    mState.mInPreLayout = <span class="hljs-keyword">false</span>;</span><br><span class="line">    mLayout.onLayoutChildren(mRecycler, mState);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从这里也可以看出<code>RecyclerView</code>真正的测量是委托给<code>LayoutManager</code>在处理，我们看看<code>LinearLayoutManager</code>的<code>onLayoutChildren</code>方法：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLayoutChildren</span><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="hljs-keyword">if</span> (mAnchorInfo.mLayoutFromEnd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="hljs-keyword">false</span>);</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        fill(recycler, mLayoutState, state, <span class="hljs-keyword">false</span>);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很明显可以看到，最终执行了fill()方法：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fill</span><span class="hljs-params">(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, <span class="hljs-keyword">boolean</span> stopOnFocusable)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    LayoutChunkResult layoutChunkResult = <span class="hljs-keyword">new</span> LayoutChunkResult();</span><br><span class="line">    <span class="hljs-keyword">while</span> ((layoutState.mInfinite || remainingSpace &gt; <span class="hljs-number">0</span>) &amp;&amp; layoutState.hasMore(state)) &#123;</span><br><span class="line">        layoutChunkResult.resetInternal();</span><br><span class="line">        layoutChunk(recycler, state, layoutState, layoutChunkResult);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的while判断条件中remainingSpace可以理解为当前列表中是否还有多余的位置可用于添加绘制child，而<code>layoutState.hasMore(state)</code>则是判断当前绘制的child索引位置是否在Adapter数据范围内<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasMore</span><span class="hljs-params">(RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> mCurrentPosition &gt;= <span class="hljs-number">0</span> &amp;&amp; mCurrentPosition &lt; state.getItemCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再来看上面的<code>layoutChunk()</code>方法：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">layoutChunk</span><span class="hljs-params">(RecyclerView.Recycler recycler, RecyclerView.State state,</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        LayoutState layoutState, LayoutChunkResult result)</span> </span>&#123;</span><br><span class="line">    View view = layoutState.next(recycler);</span><br><span class="line">    ......</span><br><span class="line">    LayoutParams params = (LayoutParams) view.getLayoutParams();</span><br><span class="line">    <span class="hljs-keyword">if</span> (layoutState.mScrapList == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection</span><br><span class="line">                == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">            addView(view);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            addView(view, <span class="hljs-number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (mShouldReverseLayout == (layoutState.mLayoutDirection</span><br><span class="line">                == LayoutState.LAYOUT_START)) &#123;</span><br><span class="line">            addDisappearingView(view);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            addDisappearingView(view, <span class="hljs-number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    measureChildWithMargins(view, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="hljs-comment">// To calculate correct layout position, we subtract margins.</span></span><br><span class="line">    layoutDecorated(view, left + params.leftMargin, top + params.topMargin, right - params.rightMargin, bottom -  params.bottomMargin);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的方法中<code>addView</code>与<code>addDisappearingView</code>最终都是调用的<code>RecyclerView</code>的<code>addView</code>方法，也就是将子<code>child</code>添加到<code>RecyclerView</code>中。</p>
<p>我们再来看看<code>View view = layoutState.next(recycler);</code>这行代码的实现：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">View <span class="hljs-title">next</span><span class="hljs-params">(RecyclerView.Recycler recycler)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (mScrapList != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> nextViewFromScrapList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">final</span> View view = recycler.getViewForPosition(mCurrentPosition);</span><br><span class="line">    <span class="hljs-comment">//获取某个位置需要展示的View</span></span><br><span class="line"></span><br><span class="line">    mCurrentPosition += mItemDirection;</span><br><span class="line">    <span class="hljs-comment">//将当前绘制的child的索引下移一位，配合while循环</span></span><br><span class="line">    <span class="hljs-keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看看上面的获取position位置的view是如何获取的：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">View <span class="hljs-title">getViewForPosition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position, <span class="hljs-keyword">boolean</span> dryRun)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ViewHolder holder = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-comment">// 0) If there is a changed scrap, try to find from there</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (mState.isPreLayout()) &#123;</span><br><span class="line">        holder = getChangedScrapViewForPosition(position);</span><br><span class="line">        fromScrap = holder != <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 1) Find from scrap by position</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        holder = getScrapViewForPosition(position, INVALID_TYPE, dryRun);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offsetPosition = mAdapterHelper.findPositionOffset(position);</span><br><span class="line">        ......</span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> type = mAdapter.getItemViewType(offsetPosition);</span><br><span class="line">        <span class="hljs-comment">// 2) Find from scrap via stable ids, if exists</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (mAdapter.hasStableIds()) &#123;</span><br><span class="line">            holder = getScrapViewForId(mAdapter.getItemId(offsetPosition), type, dryRun);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">//mViewCacheExtension的缓存是由开发者自己实现来控制ViewHolder的缓存策略</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span> &amp;&amp; mViewCacheExtension != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-comment">// We are NOT sending the offsetPosition because LayoutManager does not</span></span><br><span class="line">            <span class="hljs-comment">// know it.</span></span><br><span class="line">            <span class="hljs-keyword">final</span> View view = mViewCacheExtension.getViewForPositionAndType(<span class="hljs-keyword">this</span>, position, type);</span><br><span class="line">            <span class="hljs-keyword">if</span> (view != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                holder = getChildViewHolder(view);</span><br><span class="line">               ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// fallback to recycler</span></span><br><span class="line">            ......</span><br><span class="line">            holder = getRecycledViewPool().getRecycledView(type);</span><br><span class="line">           ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            holder = mAdapter.createViewHolder(RecyclerView.<span class="hljs-keyword">this</span>, type);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">boolean</span> bound = <span class="hljs-keyword">false</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (mState.isPreLayout() &amp;&amp; holder.isBound()) &#123;</span><br><span class="line">        <span class="hljs-comment">// do not update unless we absolutely have to.</span></span><br><span class="line">        holder.mPreLayoutPosition = position;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123;</span><br><span class="line">        ......</span><br><span class="line">        holder.mOwnerRecyclerView = RecyclerView.<span class="hljs-keyword">this</span>;</span><br><span class="line">        <span class="hljs-comment">//此处就是调用Adapter中bindViewHolder方法</span></span><br><span class="line">        mAdapter.bindViewHolder(holder, offsetPosition);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="hljs-keyword">return</span> holder.itemView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将指定位置的View获取得到之后添加到RecyclerView中，紧接着再来看后面执行的<code>measureChildWithMargins</code>方法：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureChildWithMargins</span><span class="hljs-params">(View child, <span class="hljs-keyword">int</span> widthUsed, <span class="hljs-keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">    <span class="hljs-comment">//通过ItemDecorate获取offset</span></span><br><span class="line">    <span class="hljs-keyword">final</span> Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);</span><br><span class="line">    widthUsed += insets.left + insets.right;</span><br><span class="line">    heightUsed += insets.top + insets.bottom;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(), getPaddingLeft() + getPaddingRight() + lp.leftMargin + lp.rightMargin + widthUsed, lp.width, canScrollHorizontally());</span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(), getPaddingTop() + getPaddingBottom() + lp.topMargin + lp.bottomMargin + heightUsed, lp.height, canScrollVertically());</span><br><span class="line">    <span class="hljs-keyword">if</span> (shouldMeasureChild(child, widthSpec, heightSpec, lp)) &#123;</span><br><span class="line">        child.measure(widthSpec, heightSpec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法中调用<code>mRecyclerView.getItemDecorInsetsForChild(child);</code>获取child的offset，然后对child重新测量绘制：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">Rect <span class="hljs-title">getItemDecorInsetsForChild</span><span class="hljs-params">(View child)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> decorCount = mItemDecorations.size();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; decorCount; i++) &#123;</span><br><span class="line">        mTempRect.set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</span><br><span class="line">        mItemDecorations.get(i).getItemOffsets(mTempRect, child, <span class="hljs-keyword">this</span>, mState);</span><br><span class="line">        insets.left += mTempRect.left;</span><br><span class="line">        insets.top += mTempRect.top;</span><br><span class="line">        insets.right += mTempRect.right;</span><br><span class="line">        insets.bottom += mTempRect.bottom;</span><br><span class="line">    &#125;</span><br><span class="line">    lp.mInsetsDirty = <span class="hljs-keyword">false</span>;</span><br><span class="line">    <span class="hljs-keyword">return</span> insets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个里面的<code>mItemDecorations</code>就是文章开头例子中我通过<code>mRecyclerView.addItemDecoration(new RecyclerItemDecoration(LinearLayoutManager.VERTICAL));</code>添加的Item装饰器<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">layoutDecorated</span><span class="hljs-params">(View child, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> top, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> Rect insets = ((LayoutParams) child.getLayoutParams()).mDecorInsets;</span><br><span class="line">    child.layout(left + insets.left, top + insets.top, right - insets.right, bottom - insets.bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>layoutDecorated</code>方法中直接调用了View的layout方法对child视图进行layout布局。</p>
<p>到此RecyclerView列表中Item项视图的measure和layout实际上已经完成。</p>
<h3 id="RecyclerView-onLayout"><a href="#RecyclerView-onLayout" class="headerlink" title="RecyclerView.onLayout"></a>RecyclerView.onLayout</h3><p>看完<code>onMeasure</code>方法，再来看看<code>onLayout</code>方法：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLayout</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> changed, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> t, </span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);</span><br><span class="line">    dispatchLayout();</span><br><span class="line">    TraceCompat.endSection();</span><br><span class="line">    mFirstLayoutComplete = <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispatchLayout</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mState.mIsMeasuring = <span class="hljs-keyword">false</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (mState.mLayoutStep == State.STEP_START) &#123;</span><br><span class="line">        ......</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() || mLayout.getHeight() != getHeight()) &#123;</span><br><span class="line">        ......</span><br><span class="line">        dispatchLayoutStep2();</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// always make sure we sync them (to ensure mode is exact)</span></span><br><span class="line">        mLayout.setExactMeasureSpecsFrom(<span class="hljs-keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatchLayoutStep3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>dispatchLayout</code>方法可以看到onLayout中又执行了我们前面分析过的<code>dispatchLayoutStep2()</code>方法，在最后又执行了一个<code>dispatchLayoutStep3()</code>方法，我们再来看看这个：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dispatchLayoutStep3</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="hljs-keyword">if</span> (mState.mRunSimpleAnimations) &#123;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = mChildHelper.getChildCount() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;</span><br><span class="line">            ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i));</span><br><span class="line">            ......</span><br><span class="line">            <span class="hljs-keyword">final</span> ItemHolderInfo animationInfo = mItemAnimator</span><br><span class="line">                    .recordPostLayoutInformation(mState, holder);</span><br><span class="line">            ......</span><br><span class="line">            <span class="hljs-keyword">if</span> (oldChangeViewHolder != <span class="hljs-keyword">null</span> &amp;&amp; !oldChangeViewHolder.shouldIgnore()) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="hljs-keyword">if</span> (oldDisappearing &amp;&amp; oldChangeViewHolder == holder) &#123;</span><br><span class="line">                    <span class="hljs-comment">//此处会执行动画</span></span><br><span class="line">                    <span class="hljs-comment">// run disappear animation instead of change</span></span><br><span class="line">                    mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    ......</span><br><span class="line">                    <span class="hljs-keyword">if</span> (preInfo == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                        handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder);</span><br><span class="line">                    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                        <span class="hljs-comment">//此方法最终调用DefaultItemAnimate的相关动画</span></span><br><span class="line">                        animateChange(oldChangeViewHolder, holder, preInfo, postInfo, oldDisappearing, newDisappearing);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                mViewInfoStore.addToPostLayout(holder, animationInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// Step 4: Process view info lists and trigger animations</span></span><br><span class="line">        mViewInfoStore.process(mViewInfoProcessCallback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的方法中调用了<code>ItemAnimation</code>动画类的相关方法</p>
<h3 id="RecyclerView-onDraw"><a href="#RecyclerView-onDraw" class="headerlink" title="RecyclerView.onDraw"></a>RecyclerView.onDraw</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDraw</span><span class="hljs-params">(Canvas c)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>.onDraw(c);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mItemDecorations.size();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        mItemDecorations.get(i).onDraw(c, <span class="hljs-keyword">this</span>, mState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>ItemDecoration</code>的<code>onDraw</code>方法是在此处调用<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(Canvas c)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>.draw(c);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> count = mItemDecorations.size();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        mItemDecorations.get(i).onDrawOver(c, <span class="hljs-keyword">this</span>, mState);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个地方可以看到<code>ItemDecoration</code>的<code>onDrawOver</code>方法是在此处调用</p>
<p>到这里，RecyclerView使用过程中比较常用的几个类(<code>LayoutManager, ItemDecoration, ItemAnimation</code>)的主要作用及使用场景有了个大概的了解。</p>
<p>在RecyclerView中是没有为我们内置Item的单击和长按事件监听接口的，一般为Item设置单击和长按监听都是是直接在Adapter初始化Item视图时，为我们的Item视图直接设置单击监听和长按监听，这种方式与Adapter的耦合度比较高，而且频繁的为view设置监听对象，感觉不太好。其实RecyclerView中为我们提供了一个类<code>OnItemTouchListener</code>通过这个类再结合手势<code>GestureDetector</code>完全可以实现一个耦合度更低复用度更高的单击和长按监听。我们再来看看<code>OnItemTouchListener</code>的实现方式：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouchEvent</span><span class="hljs-params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="hljs-keyword">if</span> (dispatchOnItemTouch(e)) &#123;</span><br><span class="line">        cancelTouch();</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchOnItemTouch</span><span class="hljs-params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> action = e.getAction();</span><br><span class="line">    <span class="hljs-keyword">if</span> (mActiveOnItemTouchListener != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="hljs-comment">// Stale state from a previous gesture, we're starting a new one. Clear it.</span></span><br><span class="line">            mActiveOnItemTouchListener = <span class="hljs-keyword">null</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">//此处即调用OnItemTouchListener的方法</span></span><br><span class="line">            mActiveOnItemTouchListener.onTouchEvent(<span class="hljs-keyword">this</span>, e);</span><br><span class="line">            <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) &#123;</span><br><span class="line">                <span class="hljs-comment">// Clean up for the next gesture.</span></span><br><span class="line">                mActiveOnItemTouchListener = <span class="hljs-keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Listeners will have already received the ACTION_DOWN via dispatchOnItemTouchIntercept</span></span><br><span class="line">    <span class="hljs-comment">// as called from onInterceptTouchEvent; skip it.</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (action != MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> listenerCount = mOnItemTouchListeners.size();</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; listenerCount; i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">final</span> OnItemTouchListener listener = mOnItemTouchListeners.get(i);</span><br><span class="line">            <span class="hljs-comment">//此处即调用OnItemTouchListener的方法</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (listener.onInterceptTouchEvent(<span class="hljs-keyword">this</span>, e)) &#123;</span><br><span class="line">                mActiveOnItemTouchListener = listener;</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="hljs-keyword">if</span> (dispatchOnItemTouchIntercept(e)) &#123;</span><br><span class="line">        cancelTouch();</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dispatchOnItemTouchIntercept</span><span class="hljs-params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> action = e.getAction();</span><br><span class="line">    <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        mActiveOnItemTouchListener = <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> listenerCount = mOnItemTouchListeners.size();</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; listenerCount; i++) &#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> OnItemTouchListener listener = mOnItemTouchListeners.get(i);</span><br><span class="line">        <span class="hljs-keyword">if</span> (listener.onInterceptTouchEvent(<span class="hljs-keyword">this</span>, e) &amp;&amp; action != MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">            mActiveOnItemTouchListener = listener;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> RecyclerView </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于OkHttp的封装库TigerOkHttp的使用]]></title>
      <url>http://ittiger.cn/%E5%9F%BA%E4%BA%8EOkHttp%E7%9A%84%E5%B0%81%E8%A3%85%E5%BA%93TigerOkHttp%E7%9A%84%E4%BD%BF%E7%94%A8.html</url>
      <content type="html"><![CDATA[<p>在前面熟悉了OkHttp的用法之后，为了简化用法同时适用于我的项目，我针对OkHttp进行了更进一步的封装(源码及其Demo地址在<a href="https://github.com/huyongli/TigerOkHttp" target="_blank" rel="noopener">https://github.com/huyongli/TigerOkHttp</a>)</p>
<h3 id="TigerOKHttp特性"><a href="#TigerOKHttp特性" class="headerlink" title="TigerOKHttp特性"></a>TigerOKHttp特性</h3><p>封装之后其支持的功能特性包括如下：</p>
<ol>
<li><p>一般的get同步阻塞请求和异步请求</p>
</li>
<li><p>一般的post同步阻塞请求和异步请求</p>
</li>
<li><p>实现了文件上传功能（包含文件上传进度回调显示）</p>
</li>
<li><p>实现了大文件下载功能，只需要指定文件下载路径即可，也包含了下载进度的回调显示</p>
</li>
<li><p>实现了请求结果的自动解析，用户也可以根据需求扩展自定义结果解析类</p>
</li>
<li><p>对所有请求都支持直接将结果解析转换为JavaBean对象或集合</p>
</li>
<li><p>支持对返回结果结构的自定义，例如设置返回结果结构为：{flag：1|0，error：错误信息，result：请求结果}，结果解析的时候会按照此结构进行结果解析</p>
</li>
<li><p>支持取消某个请求</p>
</li>
</ol>
<a id="more"></a>
<p>如果还不知道如何使用OkHttp请参考我的上一篇文章 Android中OkHttp的使用 进行了解。</p>
<h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><p>所有的请求在使用之前，先在Application里执行<code>TigerOkHttp.init(new TigerHttpConfig(getApplicationContext()));</code>进行<code>TigerOkHttp</code>的初始化操作。</p>
<p>TigerHttpConfig中主要是设置请求的全局性配置：</p>
<ol>
<li><p><code>TigerHttpConfig.readTimeOut：</code>设置全局请求的数据读取超时时间，默认为30s</p>
</li>
<li><p><code>TigerHttpConfig.writeTimeOut：</code>设置全局请求的数据写入超时时间，默认为15s</p>
</li>
<li><p><code>TigerHttpConfig.connectTimeOut：</code>设置全局请求的连接超时时间，默认为15s</p>
</li>
<li><p><code>TigerHttpConfig.cacheSize：</code>设置全局请求的缓存大小，默认为10M</p>
</li>
<li><p><code>TigerHttpConfig.cacheDirectory：</code>设置全局请求的缓存存储路径，默认为系统给应用分配的缓存路径</p>
</li>
<li><p><code>TigerHttpConfig.isWrapperResult：</code>设置全局请求结果是否对结果进行了封装，默认为true</p>
</li>
<li><p><code>TigerHttpConfig.wrapperJsonResult：</code>设置全局请求结果的结构类型，在<code>isWrapperResult</code>为true时才起作用</p>
</li>
</ol>
<p>WrapperJson主要自定义设置全局请求结果的结构类型：</p>
<ol>
<li><p><code>WrapperJson.code_name：</code>设置请求成功与否的状态码字段，默认为：flag</p>
</li>
<li><p><code>WrapperJson.result_name：</code>设置请求成功后结果字段，默认为：result</p>
</li>
<li><p><code>WrapperJson.error_name：</code>设置请求失败后的错误信息字段(仅在请求失败时才有值)，默认为：error</p>
</li>
<li><p><code>WrapperJson.code_error_value：</code>设置请求失败的状态码值，当请求状态码与此值相等时代表请求失败</p>
</li>
</ol>
<h3 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/*-------------------- 以下为Get同步阻塞请求 -------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//根据请求URL构造请求对象，请求成功后直接返回结果为Model对象</span></span><br><span class="line">TigerJsonRequest&lt;Model&gt; request = <span class="hljs-keyword">new</span> TigerJsonRequest&lt;Model&gt;(URL, Model.class);</span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment"> * 如果要同步请求返回Model集合的话，请求对象这样构造</span></span><br><span class="line"><span class="hljs-comment"> * TigerJsonRequest&lt;List&lt;Model&gt;&gt; request = new TigerJsonRequest&lt;List&lt;Model&gt;&gt;(URL, Model.class);</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-comment">//以下添加三个请求参数</span></span><br><span class="line">request.addParam(<span class="hljs-string">"value"</span>, <span class="hljs-string">"同步get请求-返回Model"</span>)</span><br><span class="line">.addParam(<span class="hljs-string">"isModel"</span>, <span class="hljs-keyword">true</span>)</span><br><span class="line">.addParam(<span class="hljs-string">"isList"</span>, <span class="hljs-keyword">false</span>);</span><br><span class="line"><span class="hljs-comment">//同步阻塞请求，直接返回Model对象</span></span><br><span class="line">Model result = TigerOkHttp.getSync(request);</span><br><span class="line"><span class="hljs-comment">//同步阻塞请求，直接返回Model集合</span></span><br><span class="line"><span class="hljs-comment">//List&lt;Model&gt; result = TigerOkHttp.getSync(request);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*-------------------- 以下为Get异步请求 ------------------------------*/</span></span><br><span class="line"><span class="hljs-comment">//根据请求URL构造请求对象，请求成功直接返回结果为Model集合</span></span><br><span class="line">TigerJsonRequest&lt;List&lt;Model&gt;&gt; request = <span class="hljs-keyword">new</span> TigerJsonRequest&lt;List&lt;Model&gt;&gt;(URL);</span><br><span class="line"><span class="hljs-comment">//添加三个请求参数</span></span><br><span class="line">request.addParam(<span class="hljs-string">"value"</span>, <span class="hljs-string">"异步get请求-返回List&lt;Model&gt;"</span>)</span><br><span class="line">.addParam(<span class="hljs-string">"isModel"</span>, <span class="hljs-keyword">true</span>)</span><br><span class="line">.addParam(<span class="hljs-string">"isList"</span>, <span class="hljs-keyword">true</span>)</span><br><span class="line">.setRequestCallback(<span class="hljs-keyword">new</span> RequestCallback&lt;List&lt;Model&gt;&gt;() &#123;<span class="hljs-comment">//设置异步请求回调</span></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(List&lt;Model&gt;result)</span> </span>&#123;</span><br><span class="line">        showResult(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(TigerHttpException e)</span> </span>&#123;</span><br><span class="line">        showResult(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-comment">//开始异步请求</span></span><br><span class="line">TigerOkHttp.getAsync(request);</span><br></pre></td></tr></table></figure>
<p>上面即为一般Get同步阻塞请求和异步请求的方式，对这两个请求需要说明几点：</p>
<ol>
<li><p>首先根据请求URL构造一个请求对象TigerJsonRequest，如果为同步阻塞请求必须调用具有两个参数的构造函数以设置请求地址和设置请求返回的结果类型，如果是异步请求则只需要调用一个参数的构造函数设置请求地址即可(异步请求的返回结果类型会自动根据泛型判断)</p>
</li>
<li><p>在请求对象添加此请求相关的请求参数</p>
</li>
<li><p>如果是异步请求，在请求对象中添加异步请求回调接口RequestCallback</p>
</li>
<li><p>根据是否为异步请求在TigerOkHttp中选择对应的请求方法开始请求操作</p>
</li>
<li><p>如果解析后返回Model对象话，服务端返回的结果必须是JSON字符串，如果解析后返回Model集合的话，服务端返回的结果必须是JSON数组字符串</p>
</li>
</ol>
<h3 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h3><p>这里的Post同步、异步请求和上面的Get的同步异步请求方式基本上一样，构造请求对象TigerJsonRequest的方式是一模一样的，唯一的区别只是在最后发起请求操作上更换了请求方法</p>
<ol>
<li><p>post同步阻塞请求的发起方式为：<code>T result = TigerOkHttp.postSync(request);</code></p>
</li>
<li><p>post异步请求的发起方式为：<code>TigerOkHttp.postAsync(request);</code></p>
</li>
</ol>
<h3 id="自定义结果解析器"><a href="#自定义结果解析器" class="headerlink" title="自定义结果解析器"></a>自定义结果解析器</h3><p>当<code>TigerJsonRequest</code>自带的默认解析器<code>TigerJsonParser</code>无法满足你的功能需求时，我们只需要简单的两步即可为某次请求实现自定义解析器：</p>
<ol>
<li><p>继承<code>TigerParser&lt;T</code>&gt;(会自动根据设置的全局结果结构进行解析判断请求是否成功、拿到请求的真正结果数据)这个解析基类然后实现<code>public abstract T parser(BufferedSource source) throws TigerHttpException;</code>方法</p>
</li>
<li><p>通过<code>TigerJsonRequest</code>类中的方法<code>setDataParser(TigerParser dataParser)</code>设置此次请求的结果解析器</p>
</li>
</ol>
<h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>上传文件模块我是在<code>TigerJsonRequest</code>基础上扩展出了一个专门针对上传文件的请求对象<code>TigerUploadRequest</code>，具体的上传文件实现方式如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//根据上传请求地址和文件路径构造文件上传请求对象</span></span><br><span class="line">TigerUploadRequest&lt;String&gt; request = <span class="hljs-keyword">new</span> TigerUploadRequest&lt;String&gt;(url, filePath);</span><br><span class="line"><span class="hljs-comment">//设置上传回调监听 </span></span><br><span class="line">request.setRequestCallback(</span><br><span class="line">     <span class="hljs-keyword">new</span> RequestCallback&lt;String&gt;() &#123;</span><br><span class="line">         <span class="hljs-meta">@Override</span></span><br><span class="line">         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPreExecute</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">             <span class="hljs-keyword">super</span>.onPreExecute();</span><br><span class="line">             <span class="hljs-comment">//此处可以初始化显示上传进度UI</span></span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="hljs-meta">@Override</span></span><br><span class="line">         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(String result)</span> </span>&#123;</span><br><span class="line">             <span class="hljs-comment">//文件上传成功</span></span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="hljs-meta">@Override</span></span><br><span class="line">         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLoading</span><span class="hljs-params">(<span class="hljs-keyword">long</span> count, <span class="hljs-keyword">long</span> current)</span> </span>&#123;</span><br><span class="line">             <span class="hljs-keyword">super</span>.onLoading(count, current);</span><br><span class="line">             <span class="hljs-comment">//此处可以更新上传进度</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="hljs-meta">@Override</span></span><br><span class="line">         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(TigerHttpException e)</span> </span>&#123;</span><br><span class="line">             <span class="hljs-comment">//文件上传失败</span></span><br><span class="line">         &#125;</span><br><span class="line"> </span><br><span class="line">         <span class="hljs-meta">@Override</span></span><br><span class="line">         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAfterExecute</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">             <span class="hljs-keyword">super</span>.onAfterExecute();</span><br><span class="line">             <span class="hljs-comment">//此处可以隐藏上传进度条</span></span><br><span class="line">         &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="hljs-comment">//发起上传操作</span></span><br><span class="line"> TigerOkHttp.postAsync(request);</span><br></pre></td></tr></table></figure></p>
<h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><p>下载文件功能需要用到另外一个请求对象TigerFileRequest<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//根据下载请求地址和下载文件的保存路径构造请求对象</span></span><br><span class="line">TigerFileRequest request = <span class="hljs-keyword">new</span> TigerFileRequest(URL, fileSavePath);</span><br><span class="line"><span class="hljs-comment">//添加一个请求参数</span></span><br><span class="line">request.addParam(<span class="hljs-string">"method"</span>, <span class="hljs-string">"download"</span>)</span><br><span class="line"><span class="hljs-comment">//设置下载过程中的回调接口</span></span><br><span class="line">.setRequestCallback(<span class="hljs-keyword">new</span> RequestCallback&lt;File&gt;() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPreExecute</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>.onPreExecute();</span><br><span class="line">        <span class="hljs-comment">//此处初始化显示下载进度条UI</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(File result)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//下载成功，同时返回下载成功的文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onLoading</span><span class="hljs-params">(<span class="hljs-keyword">long</span> count, <span class="hljs-keyword">long</span> current)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>.onLoading(count, current);</span><br><span class="line">        <span class="hljs-comment">//更新下载进度UI</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(TigerHttpException e)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//下载失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAfterExecute</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>.onAfterExecute();</span><br><span class="line">        <span class="hljs-comment">//隐藏下载进度条UI</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="hljs-comment">//发起下载请求</span></span><br><span class="line">TigerOkHttp.getAsync(request);</span><br></pre></td></tr></table></figure></p>
<h3 id="取消某个请求"><a href="#取消某个请求" class="headerlink" title="取消某个请求"></a>取消某个请求</h3><p>取消某个请求只需要调用<code>TigerOkHttp.cancel(request.getTag())</code>即可，如果没有手动设置请求对象request的tag值，请求的时候会自动为这次请求生成一个唯一的tag</p>
<p>以上基本上就是TigerOkHttp框架的所有功能的使用方法，欢迎各位下载使用。</p>
<p>由于本人能力有限，此框架可能存在某些不足的地方，如果各位发现问题，欢迎提出，我会尽快解决，另外我会不断丰富完善此框架的功能。</p>
<p>write by laohu</p>
<p>2016-1-6 </p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> OkHttp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android中OkHttp的使用]]></title>
      <url>http://ittiger.cn/Use-OkHttp-In-Android.html</url>
      <content type="html"><![CDATA[<p>前段时间研究了下Android里面非常火爆的网络请求库OkHttp，这篇文章主要来介绍下OkHttp的常用请求的使用方式，后面一篇文章会介绍本人基于OkHttp封装的一个操作更简单、更适用于项目的网络请求库TigerOkHttp，其源码及Demo地址为：<a href="https://github.com/huyongli/TigerOkHttp" target="_blank" rel="noopener">https://github.com/huyongli/TigerOkHttp</a></p>
<h3 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h3><p>对于OkHttp的基本介绍，以及为什么要使用OkHttp而不再使用HttpURLConnection或者是HttpClient，各位自己找度娘去，我这里就不再废话了。</p>
<p>使用OkHttp之前，需要先下载OkHttp.jar包，大家可以在<a href="https://github.com/square/okhttp去下载OkHttp的最新jar包以及源码，" target="_blank" rel="noopener">https://github.com/square/okhttp去下载OkHttp的最新jar包以及源码，</a></p>
<p>同时因为OkHttp内部依赖okio，所以大家还要自行下载okio.jar包，下载地址在这里<a href="https://github.com/square/okio" target="_blank" rel="noopener">https://github.com/square/okio</a></p>
<a id="more"></a>
<h3 id="二、使用教程"><a href="#二、使用教程" class="headerlink" title="二、使用教程"></a>二、使用教程</h3><h4 id="1-Get请求"><a href="#1-Get请求" class="headerlink" title="1.Get请求"></a>1.Get请求</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//创建OkHttpClient对象，用于稍后发起请求</span></span><br><span class="line">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();</span><br><span class="line"><span class="hljs-comment">//根据请求URL创建一个Request对象</span></span><br><span class="line">Request request = <span class="hljs-keyword">new</span> Request.Builder().url(<span class="hljs-string">"https://github.com/huyongli/TigerOkHttp"</span>).build();</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">//根据Request对象发起Get同步Http请求</span></span><br><span class="line">Response response = client.newCall(request).execute();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">//根据Request对象发起Get异步Http请求，并添加请求回调</span></span><br><span class="line">client.newCall(request).enqueue(<span class="hljs-keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Response response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="hljs-comment">//请求成功，此处对请求结果进行处理</span></span><br><span class="line">       <span class="hljs-comment">//String result = response.body().string();</span></span><br><span class="line">       <span class="hljs-comment">//InputStream is = response.body().byteStream();</span></span><br><span class="line">       <span class="hljs-comment">//byte[] bytes = response.body().bytes();</span></span><br><span class="line">    &#125;</span><br><span class="line">			</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(Request request, IOException e)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//请求失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码示例演示了OkHttp中一个普通的Http  get请求是如何实现的，对于上面的代码，作一下简单的说明</p>
<ol>
<li><p>既然是get请求，当然得先构造好你要请求的URL</p>
</li>
<li><p>有了请求URL，紧接着就是需要通过这个URL构造一个请求对象Request</p>
</li>
<li><p>当然有时候可能你需要对这个Http请求添加一些自定义的请求头信息header，这时你在构造Request对象之前通过<code>Request.Builder builder = new Request.Builder()</code>创建的builder 对象来添加自己需要添加的请求头信息<code>builder.addHeader(key, value)</code></p>
</li>
<li><p>OkHttp是自带请求缓存控制策略的，如果你想改变某个请求的缓存控制策略，你也可以通过builder对象来修改缓存策略<code>builder.cacheControl()</code></p>
</li>
<li><p>通过上述步骤构造好请求对象Request之后，通过OkHttpClient创建一个Call任务对象，这个对象有execute()和cancel()等方法对Call任务对象进行执行和取消</p>
</li>
<li><p>如果是同步阻塞请求的话，直接执行Call对象的<code>execute()</code>方法即可得到请求结果。</p>
</li>
<li><p>如果是异步请求的话，就需要执行Call对象的<code>enqueue(new Callback(){})</code>方法，将任务对象添加到任务请求调度队列中，同时添加请求回调接口。</p>
</li>
<li><p>请求成功之后，可以得到一个Response对象，如果想获得返回的字符串结果则可以通过<code>response.body().string()</code>，如果想获得返回结果的二进制数据的话可以通过<code>response.body().bytes()</code>，如果想获得返回的InputStream的话可以通过<code>response.body().byteStream()</code></p>
</li>
<li><p>通过上面我们可以发现在Response对象中我们可以获取InputStream对象，所以从此处我们可以看出在异步请求<code>onResponse(Response response)</code>回调方法中我们可以通过IO方式来进行写文件，所以在此回调中我们可以进行大文件的下载处理，同时也说明此回调并不是在UI线程中执行的，所以此处如果要进行UI操作的话各位需要自行处理下。</p>
</li>
</ol>
<h4 id="2-Post请求"><a href="#2-Post请求" class="headerlink" title="2.Post请求"></a>2.Post请求</h4><p>上面对OkHttp的Get请求分析完之后，OkHttp的整个请求流程和处理流程就清晰，Post请求和Get请求的流程都是一样，区别只是在于Request对象构造上有区别。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//创建OkHttpClient对象</span></span><br><span class="line">OkHttpClient client = <span class="hljs-keyword">new</span> OkHttpClient();</span><br><span class="line"><span class="hljs-comment">//通过FormEncodingBuilder对象添加多个请求参数键值对</span></span><br><span class="line">FormEncodingBuilder builder = <span class="hljs-keyword">new</span> FormEncodingBuilder();</span><br><span class="line">builder.add(<span class="hljs-string">"method"</span>, <span class="hljs-string">"post"</span>).add(<span class="hljs-string">"param"</span>, value);</span><br><span class="line"><span class="hljs-comment">//通过FormEncodingBuilder对象构造Post请求体</span></span><br><span class="line">RequestBody body = builder.build();</span><br><span class="line"><span class="hljs-comment">//通过请求地址和请求体构造Post请求对象Request</span></span><br><span class="line">Request request = <span class="hljs-keyword">new</span> Request.Builder().url(url).post(body).build();</span><br></pre></td></tr></table></figure></p>
<p>上面的代码演示了如何构造普通Post请求(不包含文件上传)的请求体和请求对象，请求对象构造成功之后，后面的请求过程和处理流程就和Get请求是一样的了。</p>
<h4 id="3-文件上传"><a href="#3-文件上传" class="headerlink" title="3.文件上传"></a>3.文件上传</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//多个图片文件列表 </span></span><br><span class="line">List&lt;File&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;File&gt;();</span><br><span class="line"><span class="hljs-comment">//多文件表单上传构造器</span></span><br><span class="line">MultipartBuilder multipartBuilder = <span class="hljs-keyword">new</span> MultipartBuilder().type(MultipartBuilder.FORM);</span><br><span class="line"><span class="hljs-comment">//添加一个文本表单参数</span></span><br><span class="line">multipartBuilder.addFormDataPart(<span class="hljs-string">"method"</span>, <span class="hljs-string">"upload上传"</span>);</span><br><span class="line"><span class="hljs-keyword">for</span>(File file : list) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(file.exists()) &#123;</span><br><span class="line">        multipartBuilder.addFormDataPart(file.getName(), file.getName(), RequestBody.create(MediaType.parse(<span class="hljs-string">"image/png"</span>), file));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//构造文件上传时的请求对象Request</span></span><br><span class="line">Request request = <span class="hljs-keyword">new</span> Request.Builder().url(url).post(multipartBuilder.build()).build();</span><br></pre></td></tr></table></figure>
<p>文件上传时的重点是通过<code>MultipartBuilder</code>构造器添加要上传的文件和表单参数，OkHttp中文件上传时，没有可以直接实现上传进度显示的接口，这个需要手动对OkHttp中的请求体进行扩展，这篇文章中就不写了，在下篇文章介绍<code>TigerOkHttp</code>时我会进行介绍。</p>
<h4 id="4-文件下载"><a href="#4-文件下载" class="headerlink" title="4.文件下载"></a>4.文件下载</h4><p>文件下载功能在第一点Get请求的几点说明中已经介绍过了，无论你是通过Get请求还是Post请求，只需要从请求结果对象Response中获取到结果输入流InputStream，然后通过IO操作进行写文件即可实现文件下载功能。在通过IO操作写文件时，也可以自行实现下载进度显示的功能。</p>
<h4 id="5-编码问题"><a href="#5-编码问题" class="headerlink" title="5.编码问题"></a>5.编码问题</h4><p>在OkHttp中，无论是Get请求还是Post请求所有参数的编码方式都是默认采用UTF-8的编码方式进行编码。</p>
<p>所以在进行Get请求或Post请求时，文本参数都不需要我们进行手动编码，但是在服务端进行参数解析时，需要做简单的处理，这里我只说明tomcat下运行的Java后台服务的处理方式：</p>
<ol>
<li><p>针对Get请求，我们只需要在tomcat的server.xml文件中设置默认编码方式<code>(URIEncoding=”UTF-8″ )</code>为UTF-8即可，注意此编码设置只对Get请求有效。</p>
</li>
<li><p>针对Post请求，我们在解析获取参数值之前需要手动设置请求的编码方式为UTF-8，如：<code>req.setCharacterEncoding(“UTF-8”);</code></p>
</li>
</ol>
<h3 id="OkHttp封装框架–TigerOkHttp"><a href="#OkHttp封装框架–TigerOkHttp" class="headerlink" title="OkHttp封装框架–TigerOkHttp"></a>OkHttp封装框架–TigerOkHttp</h3><p>以上就是OkHttp最基本的用法，下篇文章我会介绍我自己基于OkHttp更进一步封装的网络请求库TigerOkHttp，它主要包含了如下功能特点：</p>
<ol>
<li><p>一般的get同步阻塞请求和异步请求</p>
</li>
<li><p>一般的post同步阻塞请求和异步请求</p>
</li>
<li><p>实现了文件上传功能（包含文件上传进度回调显示）</p>
</li>
<li><p>实现了大文件下载功能，只需要指定文件下载路径即可，也包含了下载进度的回调显示</p>
</li>
<li><p>实现了请求结果的自动解析，用户也可以根据需求扩展自定义结果解析类</p>
</li>
<li><p>对所有请求都支持直接将结果解析转换为JavaBean对象或集合</p>
</li>
<li><p>支持对返回结果结构的自定义，例如设置返回结果结构为：{flag：1|0，error：错误信息，result：请求结果}，结果解析的时候会按照此结构进行结果解析</p>
</li>
<li><p>支持取消某个请求</p>
</li>
</ol>
<p>write by laohu</p>
<p>2016-1-5 </p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> OkHttp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android百度地图导航功能的那些坑]]></title>
      <url>http://ittiger.cn/problem-of-baiduMap-navigation-android.html</url>
      <content type="html"><![CDATA[<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li>首先要先在AndroidManifest.xml中注册导航服务</li>
</ol>
<p><code>&lt;service android:name=&quot;com.baidu.navi.location.f&quot; android:enabled=&quot;true&quot;&gt;&lt;/service&gt;</code></p>
<ol start="2">
<li><p>添加相关的权限，我也不知道哪些是必须的，我直接把Demo里面的相关权限配置全部拉过来了</p>
</li>
<li><p>在导航之前要先调用<code>BaiduNaviManager.getInstance().initEngine</code>对导航引擎进行初始化。可以通过<code>NaviEngineInitListener</code>接口检查导航引擎初始化是否成功，同时通过<code>LBSAuthManagerListener</code>接口对API-Key进行Key校验是否成功，status结果为0代表key校验成功。</p>
</li>
<li><p>必须将Demo中assert目录下的两个文件<code>BaiduNaviSDK_Resource_v1_0_0.png</code>，channel拷贝到自己项目的assert目录下去，否则导航引擎无法初始化成功。</p>
</li>
<li><p>在导航引擎初始化成功后，调用导航功能前调用<code>BaiduNaviManager.getInstance().checkEngineStatus(context)</code>检测导航引擎是否初始化成功。</p>
</li>
<li><p>调用<code>BaiduNaviManager.getInstance().launchNavigator</code>开始导航。</p>
</li>
</ol>
<a id="more"></a>
<h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><p>相关代码如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line">   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">launchNavi</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Activity activity, List points )</span></span>&#123;</span><br><span class="line">    	<span class="hljs-keyword">if</span>(points.size() &lt; <span class="hljs-number">2</span>) &#123;</span><br><span class="line">    		Toast.makeText(activity, <span class="hljs-string">"数据不合法，暂时无法导航"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    		<span class="hljs-keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	BaiduNaviManager.getInstance().launchNavigator(activity,</span><br><span class="line">            points,                                          <span class="hljs-comment">//路线点列表</span></span><br><span class="line">            NE_RoutePlan_Mode.ROUTE_PLAN_MOD_MIN_TIME,       <span class="hljs-comment">//算路方式</span></span><br><span class="line">            <span class="hljs-keyword">false</span>,                                            <span class="hljs-comment">//真实导航</span></span><br><span class="line">            BaiduNaviManager.STRATEGY_FORCE_ONLINE_PRIORITY, <span class="hljs-comment">//在离线策略</span></span><br><span class="line">            <span class="hljs-keyword">new</span> OnStartNavigationListener() &#123;                <span class="hljs-comment">//跳转监听</span></span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onJumpToNavigator</span><span class="hljs-params">(Bundle configParams)</span> </span>&#123;</span><br><span class="line">                    Intent intent = <span class="hljs-keyword">new</span> Intent(activity, NaviBdMapActivity.class);</span><br><span class="line">                    intent.putExtras(configParams);</span><br><span class="line">                    activity.startActivityForResult(intent,REQUESTCODE_NAVI_FINISH);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onJumpToDownloader</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 初始化导航引擎</span></span><br><span class="line"><span class="hljs-comment">     * Author: hyl</span></span><br><span class="line"><span class="hljs-comment">     * Time: 2015-7-9下午4:56:18</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> activity</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initNaviEngine</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Activity activity)</span> </span>&#123;</span><br><span class="line">    	BaiduNaviManager.getInstance().initEngine(activity, Utils.getRootPath(),</span><br><span class="line">            <span class="hljs-keyword">new</span> SPMNaviEngineInitListener(), <span class="hljs-keyword">new</span> LBSAuthManagerListener() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAuthResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> status, String msg)</span> </span>&#123;</span><br><span class="line">                    String str = <span class="hljs-keyword">null</span>;</span><br><span class="line">                    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == status) &#123;</span><br><span class="line">                        str = <span class="hljs-string">"key校验成功!"</span>;</span><br><span class="line">                    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                        str = <span class="hljs-string">"key校验失败, "</span> + msg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    	);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SPMNaviEngineInitListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">NaviEngineInitListener</span> </span>&#123;</span><br><span class="line">    	</span><br><span class="line">		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">engineInitSuccess</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">			Log.i(<span class="hljs-string">"Navi"</span>, <span class="hljs-string">"导航初始化成功"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">engineInitStart</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">engineInitFail</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">			Log.i(<span class="hljs-string">"Navi"</span>, <span class="hljs-string">"导航初始化失败"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NaviBdMapActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">		<span class="hljs-keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">		<span class="hljs-comment">// 创建NmapView</span></span><br><span class="line">		<span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="hljs-number">14</span>) &#123;</span><br><span class="line">			BaiduNaviManager.getInstance().destroyNMapView();</span><br><span class="line">		&#125;</span><br><span class="line">		MapGLSurfaceView nMapView = BaiduNaviManager.getInstance().createNMapView(<span class="hljs-keyword">this</span>);</span><br><span class="line"></span><br><span class="line">		<span class="hljs-comment">// 创建导航视图</span></span><br><span class="line">		View navigatorView = BNavigator.getInstance().init(</span><br><span class="line">				NaviBdMapActivity.<span class="hljs-keyword">this</span>, getIntent().getExtras(),</span><br><span class="line">				nMapView);</span><br><span class="line"></span><br><span class="line">		<span class="hljs-comment">// 填充视图</span></span><br><span class="line">		setContentView(navigatorView);</span><br><span class="line">		BNavigator.getInstance().setListener(mBNavigatorListener);</span><br><span class="line">		BNavigator.getInstance().startNav();</span><br><span class="line"></span><br><span class="line">		<span class="hljs-comment">// 初始化TTS. 开发者也可以使用独立TTS模块，不用使用导航SDK提供的TTS</span></span><br><span class="line">		BNTTSPlayer.initPlayer();</span><br><span class="line">		<span class="hljs-comment">// 设置TTS播放回调</span></span><br><span class="line">		BNavigatorTTSPlayer.setTTSPlayerListener(<span class="hljs-keyword">new</span> IBNTTSPlayerListener() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="hljs-meta">@Override</span></span><br><span class="line">			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">playTTSText</span><span class="hljs-params">(String arg0, <span class="hljs-keyword">int</span> arg1)</span> </span>&#123;</span><br><span class="line">				<span class="hljs-comment">// 开发者可以使用其他TTS的API</span></span><br><span class="line">				<span class="hljs-keyword">return</span> BNTTSPlayer.playTTSText(arg0, arg1);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="hljs-meta">@Override</span></span><br><span class="line">			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">phoneHangUp</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">				<span class="hljs-comment">// 手机挂断</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="hljs-meta">@Override</span></span><br><span class="line">			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">phoneCalling</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">				<span class="hljs-comment">// 通话中</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="hljs-meta">@Override</span></span><br><span class="line">			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTTSState</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">				<span class="hljs-comment">// 开发者可以使用其他TTS的API,</span></span><br><span class="line">				<span class="hljs-keyword">return</span> BNTTSPlayer.getTTSState();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		BNRoutePlaner.getInstance().setObserver(</span><br><span class="line">				<span class="hljs-keyword">new</span> RoutePlanObserver(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> IJumpToDownloadListener() &#123;</span><br><span class="line">					<span class="hljs-meta">@Override</span></span><br><span class="line">					<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onJumpToDownloadOfflineData</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-keyword">private</span> IBNavigatorListener mBNavigatorListener = <span class="hljs-keyword">new</span> IBNavigatorListener() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-meta">@Override</span></span><br><span class="line">		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onYawingRequestSuccess</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">			<span class="hljs-comment">// TODO 偏航请求成功</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-meta">@Override</span></span><br><span class="line">		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onYawingRequestStart</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">			<span class="hljs-comment">// TODO 开始偏航请求</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-meta">@Override</span></span><br><span class="line">		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPageJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span> jumpTiming, Object arg)</span> </span>&#123;</span><br><span class="line">			<span class="hljs-comment">// TODO 页面跳转回调</span></span><br><span class="line">			<span class="hljs-keyword">if</span> (IBNavigatorListener.PAGE_JUMP_WHEN_GUIDE_END == jumpTiming) &#123;</span><br><span class="line">				finishActivity();</span><br><span class="line">			&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (IBNavigatorListener.PAGE_JUMP_WHEN_ROUTE_PLAN_FAIL == jumpTiming) &#123;</span><br><span class="line">				finishActivity();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-meta">@Override</span></span><br><span class="line">		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyGPSStatusData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg0)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-meta">@Override</span></span><br><span class="line">		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyLoacteData</span><span class="hljs-params">(LocData arg0)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-meta">@Override</span></span><br><span class="line">		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyNmeaData</span><span class="hljs-params">(String arg0)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-meta">@Override</span></span><br><span class="line">		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifySensorData</span><span class="hljs-params">(SensorData arg0)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-meta">@Override</span></span><br><span class="line">		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyStartNav</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">			BaiduNaviManager.getInstance().dismissWaitProgressDialog();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="hljs-meta">@Override</span></span><br><span class="line">		<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyViewModeChanged</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg0)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">		BNavigator.getInstance().resume();</span><br><span class="line">		<span class="hljs-keyword">super</span>.onResume();</span><br><span class="line">		BNMapController.getInstance().onResume();</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">		BNavigator.getInstance().pause();</span><br><span class="line">		<span class="hljs-keyword">super</span>.onPause();</span><br><span class="line">		BNMapController.getInstance().onPause();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onConfigurationChanged</span><span class="hljs-params">(Configuration newConfig)</span> </span>&#123;</span><br><span class="line">		BNavigator.getInstance().onConfigurationChanged(newConfig);</span><br><span class="line">		<span class="hljs-keyword">super</span>.onConfigurationChanged(newConfig);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBackPressed</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">		BNavigator.getInstance().onBackPressed();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">		BNavigator.destory();</span><br><span class="line">		BNRoutePlaner.getInstance().setObserver(<span class="hljs-keyword">null</span>);</span><br><span class="line">		<span class="hljs-keyword">super</span>.onDestroy();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishActivity</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">		finish();</span><br><span class="line">		overridePendingTransition(R.anim.in_from_right,R.anim.out_to_left);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> 百度地图 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于openfire+smack开发Android即时聊天应用[五]-简易IM客户端效果图]]></title>
      <url>http://ittiger.cn/%E5%9F%BA%E4%BA%8Eopenfire-smack%E5%BC%80%E5%8F%91Android%E5%8D%B3%E6%97%B6%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8-%E4%BA%94-%E7%AE%80%E6%98%93IM%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%88%E6%9E%9C%E5%9B%BE.html</url>
      <content type="html"><![CDATA[<p>经过几天时间对Openfire+Smack的研究，写了一个简单的Android端的IM客户端，给大家看看我的客户端的效果图，支持发送文本、图片、语音三种消息，群聊功能暂时没有集成上去。整个应用做的比较粗糙。</p>
<p>Demo代码地址请戳：<a href="https://github.com/huyongli/TigerIM" target="_blank" rel="noopener">https://github.com/huyongli/TigerIM</a></p>
<a id="more"></a>
<h3 id="1-登陆界面"><a href="#1-登陆界面" class="headerlink" title="1.登陆界面"></a>1.登陆界面</h3><p><img src="/img/chat_1.jpg" width="360" height="640" alt></p>
<h3 id="2-好友列表"><a href="#2-好友列表" class="headerlink" title="2.好友列表"></a>2.好友列表</h3><p><img src="/img/chat_2.jpg" width="360" height="640" alt></p>
<h3 id="3-聊天界面的几种效果图："><a href="#3-聊天界面的几种效果图：" class="headerlink" title="3.聊天界面的几种效果图："></a>3.聊天界面的几种效果图：</h3><p><img src="/img/chat_3.jpg" width="360" height="640" alt>  </p>
<p><img src="/img/chat_4.jpg" width="360" height="640" alt>  </p>
<p><img src="/img/chat_5.jpg" width="360" height="640" alt>  </p>
<p><img src="/img/chat_6.jpg" width="360" height="640" alt>  </p>
<p>聊天界面是仿着QQ的聊天界面做的。</p>
<p>write by laohu</p>
<p>2015-10-30 </p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> IM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于openfire+smack开发Android即时聊天应用[四]-单人聊天、群聊、发送接收文件等]]></title>
      <url>http://ittiger.cn/%E5%9F%BA%E4%BA%8Eopenfire-smack%E5%BC%80%E5%8F%91Android%E5%8D%B3%E6%97%B6%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8-%E5%9B%9B-%E5%8D%95%E4%BA%BA%E8%81%8A%E5%A4%A9%E3%80%81%E7%BE%A4%E8%81%8A%E3%80%81%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6%E6%96%87%E4%BB%B6%E7%AD%89.html</url>
      <content type="html"><![CDATA[<p>这篇文章主要介绍如何实现点对点单人聊天、多人的群聊、以及如何给对方发送文件，如何发送图片消息和语音消息等功能。</p>
<a id="more"></a>
<h3 id="1-单人聊天"><a href="#1-单人聊天" class="headerlink" title="1.单人聊天"></a>1.单人聊天</h3><p>首先创建聊天对象<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">  * 创建聊天窗口</span></span><br><span class="line"><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> jid   好友的JID</span></span><br><span class="line"><span class="hljs-comment">  * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">  */</span></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">public</span> Chat <span class="hljs-title">createChat</span><span class="hljs-params">(String jid)</span> </span>&#123;</span><br><span class="line"> 	<span class="hljs-keyword">if</span>(isConnected()) &#123;</span><br><span class="line"> 	    ChatManager chatManager = ChatManager.getInstanceFor(connection);</span><br><span class="line"> 	    <span class="hljs-keyword">return</span> chatManager.createChat(jid);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"服务器连接失败，请先连接服务器"</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>创建聊天对象时，参数JID记得传聊天JID(解释请参考我的系列文章之基于openfire+smack开发Android即时聊天应用[三]-账号信息、添加好友、JID理解等)给好友发送文本消息<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chat.sendMessage(message);</span><br></pre></td></tr></table></figure></p>
<h3 id="2-获取聊天对象管理器"><a href="#2-获取聊天对象管理器" class="headerlink" title="2.获取聊天对象管理器"></a>2.获取聊天对象管理器</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">  * 获取聊天对象管理器</span></span><br><span class="line"><span class="hljs-comment">  * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">  */</span></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">public</span> ChatManager <span class="hljs-title">getChatManager</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"> 	<span class="hljs-keyword">if</span>(isConnected()) &#123;</span><br><span class="line"> 	    ChatManager chatManager = ChatManager.getInstanceFor(connection);</span><br><span class="line"> 	    <span class="hljs-keyword">return</span> chatManager;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"服务器连接失败，请先连接服务器"</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-接收文本消息"><a href="#3-接收文本消息" class="headerlink" title="3.接收文本消息"></a>3.接收文本消息</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//创建聊天对象管理器监听</span></span><br><span class="line"><span class="hljs-keyword">private</span> ChatManagerListener chatManagerListener = <span class="hljs-keyword">new</span> ChatManagerListener() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">chatCreated</span><span class="hljs-params">(Chat chat, <span class="hljs-keyword">boolean</span> createdLocally)</span> </span>&#123;</span><br><span class="line">        chat.addMessageListener(<span class="hljs-keyword">new</span> ChatMessageListener() &#123;</span><br><span class="line">	    <span class="hljs-meta">@Override</span></span><br><span class="line">	    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processMessage</span><span class="hljs-params">(Chat chat, Message message)</span> </span>&#123;</span><br><span class="line">	        <span class="hljs-comment">//接收到消息Message之后进行消息展示处理，这个地方可以处理所有人的消息</span></span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//设置聊天对象管理器处理监听</span></span><br><span class="line">getChatManager().addChatListener(chatManagerListener);</span><br></pre></td></tr></table></figure>
<p>上述代码会在你创建聊天对象时对该聊天对象设置消息处理监听，当接收到消息之后，会自动调用processMessage方法进行处理，我们可以在该方法中对接收到的消息进行展示或其他处理，所有好友发送过来的消息都会通过该方法处理。所以该监听最好在登陆之后进行设置，同时在断开连接或是注销时移除该监听。</p>
<h3 id="4-创建群聊聊天室"><a href="#4-创建群聊聊天室" class="headerlink" title="4.创建群聊聊天室"></a>4.创建群聊聊天室</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">  <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">    * 创建群聊聊天室</span></span><br><span class="line"><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> roomName		聊天室名字</span></span><br><span class="line"><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> nickName		创建者在聊天室中的昵称</span></span><br><span class="line"><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> password		聊天室密码</span></span><br><span class="line"><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">    */</span></span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">public</span> MultiUserChat <span class="hljs-title">createChatRoom</span><span class="hljs-params">(String roomName, String nickName, String password)</span> </span>&#123;</span><br><span class="line">   	<span class="hljs-keyword">if</span>(!isConnected()) &#123;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"服务器连接失败，请先连接服务器"</span>);</span><br><span class="line">   	&#125;</span><br><span class="line">   	MultiUserChat muc = <span class="hljs-keyword">null</span>;  </span><br><span class="line"><span class="hljs-keyword">try</span> &#123;  </span><br><span class="line">    <span class="hljs-comment">// 创建一个MultiUserChat  </span></span><br><span class="line">	muc = MultiUserChatManager.getInstanceFor(connection).getMultiUserChat(roomName + <span class="hljs-string">"@conference."</span> + connection.getServiceName());</span><br><span class="line">    <span class="hljs-comment">// 创建聊天室  </span></span><br><span class="line">    <span class="hljs-keyword">boolean</span> isCreated = muc.createOrJoin(nickName);</span><br><span class="line">    <span class="hljs-keyword">if</span>(isCreated) &#123;</span><br><span class="line">        <span class="hljs-comment">// 获得聊天室的配置表单  </span></span><br><span class="line">        Form form = muc.getConfigurationForm();  </span><br><span class="line">        <span class="hljs-comment">// 根据原始表单创建一个要提交的新表单。  </span></span><br><span class="line">        Form submitForm = form.createAnswerForm();</span><br><span class="line">        <span class="hljs-comment">// 向要提交的表单添加默认答复  </span></span><br><span class="line">        List fields = form.getFields();</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; fields != <span class="hljs-keyword">null</span> &amp;&amp; i &lt; fields.size(); i++) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(FormField.Type.hidden != fields.get(i).getType() &amp;&amp;</span><br><span class="line">                                          fields.get(i).getVariable() != <span class="hljs-keyword">null</span>) &#123;  </span><br><span class="line">        	<span class="hljs-comment">// 设置默认值作为答复  </span></span><br><span class="line">        	submitForm.setDefaultAnswer(fields.get(i).getVariable());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 设置聊天室的新拥有者  </span></span><br><span class="line">        List owners = <span class="hljs-keyword">new</span> ArrayList();  </span><br><span class="line">        owners.add(connection.getUser());<span class="hljs-comment">// 用户JID  </span></span><br><span class="line">        submitForm.setAnswer(<span class="hljs-string">"muc#roomconfig_roomowners"</span>, owners);  </span><br><span class="line">        <span class="hljs-comment">// 设置聊天室是持久聊天室，即将要被保存下来  </span></span><br><span class="line">        submitForm.setAnswer(<span class="hljs-string">"muc#roomconfig_persistentroom"</span>, <span class="hljs-keyword">true</span>);  </span><br><span class="line">       	<span class="hljs-comment">// 房间仅对成员开放  </span></span><br><span class="line">       	submitForm.setAnswer(<span class="hljs-string">"muc#roomconfig_membersonly"</span>, <span class="hljs-keyword">false</span>);  </span><br><span class="line">       	<span class="hljs-comment">// 允许占有者邀请其他人  </span></span><br><span class="line">       	submitForm.setAnswer(<span class="hljs-string">"muc#roomconfig_allowinvites"</span>, <span class="hljs-keyword">true</span>);  </span><br><span class="line">       	<span class="hljs-keyword">if</span>(password != <span class="hljs-keyword">null</span> &amp;&amp; password.length() != <span class="hljs-number">0</span>) &#123;  </span><br><span class="line">       	<span class="hljs-comment">// 进入是否需要密码  </span></span><br><span class="line">       	submitForm.setAnswer(<span class="hljs-string">"muc#roomconfig_passwordprotectedroom"</span>,  <span class="hljs-keyword">true</span>);  </span><br><span class="line">       	<span class="hljs-comment">// 设置进入密码  </span></span><br><span class="line">       	submitForm.setAnswer(<span class="hljs-string">"muc#roomconfig_roomsecret"</span>, password);  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="hljs-comment">// 能够发现占有者真实 JID 的角色  </span></span><br><span class="line">     <span class="hljs-comment">// submitForm.setAnswer("muc#roomconfig_whois", "anyone");  </span></span><br><span class="line">    <span class="hljs-comment">// 登录房间对话  </span></span><br><span class="line">    submitForm.setAnswer(<span class="hljs-string">"muc#roomconfig_enablelogging"</span>, <span class="hljs-keyword">true</span>);  </span><br><span class="line">    <span class="hljs-comment">// 仅允许注册的昵称登录  </span></span><br><span class="line">    submitForm.setAnswer(<span class="hljs-string">"x-muc#roomconfig_reservednick"</span>, <span class="hljs-keyword">true</span>);  </span><br><span class="line">    <span class="hljs-comment">// 允许使用者修改昵称  </span></span><br><span class="line">    submitForm.setAnswer(<span class="hljs-string">"x-muc#roomconfig_canchangenick"</span>, <span class="hljs-keyword">false</span>);  </span><br><span class="line">    <span class="hljs-comment">// 允许用户注册房间  </span></span><br><span class="line">    submitForm.setAnswer(<span class="hljs-string">"x-muc#roomconfig_registration"</span>, <span class="hljs-keyword">false</span>);  </span><br><span class="line">    <span class="hljs-comment">// 发送已完成的表单（有默认值）到服务器来配置聊天室  </span></span><br><span class="line">    muc.sendConfigurationForm(submitForm);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="hljs-keyword">catch</span> (XMPPException | SmackException e) &#123;  </span><br><span class="line">    e.printStackTrace();  </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">       <span class="hljs-keyword">return</span> muc; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上面这段创建群聊聊天室设置表单属性的那段代码引用于网上的代码段。</p>
<h3 id="5-加入群聊聊天室"><a href="#5-加入群聊聊天室" class="headerlink" title="5.加入群聊聊天室"></a>5.加入群聊聊天室</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">  * 加入一个群聊聊天室</span></span><br><span class="line"><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> roomName		聊天室名字</span></span><br><span class="line"><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> nickName		用户在聊天室中的昵称</span></span><br><span class="line"><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> password		聊天室密码</span></span><br><span class="line"><span class="hljs-comment">  * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">  */</span></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">public</span> MultiUserChat <span class="hljs-title">joinChatRoom</span><span class="hljs-params">(String roomName,  String nickName, String password)</span> </span>&#123;  </span><br><span class="line"> 	<span class="hljs-keyword">if</span>(!isConnected()) &#123;</span><br><span class="line">  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"服务器连接失败，请先连接服务器"</span>);</span><br><span class="line"> 	&#125;  </span><br><span class="line">     <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">         <span class="hljs-comment">// 使用XMPPConnection创建一个MultiUserChat窗口  </span></span><br><span class="line">         MultiUserChat muc = MultiUserChatManager.getInstanceFor(connection).</span><br><span class="line">                          getMultiUserChat(roomName + <span class="hljs-string">"@conference."</span> + connection.getServiceName());  </span><br><span class="line">         <span class="hljs-comment">// 聊天室服务将会决定要接受的历史记录数量  </span></span><br><span class="line">         DiscussionHistory history = <span class="hljs-keyword">new</span> DiscussionHistory();  </span><br><span class="line">         history.setMaxChars(<span class="hljs-number">0</span>);  </span><br><span class="line">         <span class="hljs-comment">// history.setSince(new Date());  </span></span><br><span class="line">         <span class="hljs-comment">// 用户加入聊天室  </span></span><br><span class="line">         muc.join(nickName, password);  </span><br><span class="line">         <span class="hljs-keyword">return</span> muc;  </span><br><span class="line">     &#125; <span class="hljs-keyword">catch</span> (XMPPException | SmackException e) &#123;  </span><br><span class="line">         e.printStackTrace();  </span><br><span class="line">         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在实现加入群聊聊天室的这段代码中有这么一段代码：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getMultiUserChat(roomName + <span class="hljs-string">"@conference."</span> + connection.getServiceName());</span><br></pre></td></tr></table></figure></p>
<p>在@与ServiceName中间必须加上conference这个字符串，我也不知道为什么，我最开始时不知道没有加，然后无论如何都加入失败，后来在网上查资料查了半天，有人说是要加上这个，然后我加上就成功了，暂时没搞明白为什么，先把程序跑通会用了再研究其他的原因。</p>
<h3 id="6-群聊发送消息"><a href="#6-群聊发送消息" class="headerlink" title="6.群聊发送消息"></a>6.群聊发送消息</h3><p>当你创建或是加入群聊聊天室后，即可获得群聊对象MultiUserChat，通过该对象即可发送群聊消息：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiUserChat.sendMessage(msg);<span class="hljs-comment">//发送群聊消息</span></span><br></pre></td></tr></table></figure></p>
<h3 id="7-接收群聊消息"><a href="#7-接收群聊消息" class="headerlink" title="7.接收群聊消息"></a>7.接收群聊消息</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//聊天室消息监听</span></span><br><span class="line"><span class="hljs-keyword">private</span> MessageListener messageListener = <span class="hljs-keyword">new</span> MessageListener() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processMessage</span><span class="hljs-params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//与单聊接收处理消息类似，聊天室里所有人(包括发送人自己)发送的消息都会通过此方法进行回调处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="hljs-comment">//设置聊天室消息监听</span></span><br><span class="line">multiUserChat.addMessageListener(messageListener);</span><br></pre></td></tr></table></figure>
<p>群聊接收消息与单聊接收消息还是很像的，只是监听对象，监听方式稍稍有点区别，整个来说，消息接收还是很简单的。</p>
<h3 id="8-获取文件传输对象"><a href="#8-获取文件传输对象" class="headerlink" title="8.获取文件传输对象"></a>8.获取文件传输对象</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">  * 获取发送文件的发送器</span></span><br><span class="line"><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> jid	一个完整的jid(如：laohu@192.168.0.108/Smack</span></span><br><span class="line"><span class="hljs-comment">  *                         后面的Smack应该客户端类型，不加这个会出错)</span></span><br><span class="line"><span class="hljs-comment">  * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">  */</span></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">public</span> OutgoingFileTransfer <span class="hljs-title">getSendFileTransfer</span><span class="hljs-params">(String jid)</span> </span>&#123;</span><br><span class="line"> 	<span class="hljs-keyword">if</span>(isConnected()) &#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> FileTransferManager.getInstanceFor(connection).createOutgoingFileTransfer(jid);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"服务器连接失败，请先连接服务器"</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>获取文件传输对象时的参数JID记得为文件传输JID：<font color="red">解释请参考我的系列文章之</font><a href="/2015/10/30/基于openfire+smack开发Android即时聊天应用[三]-账号信息、添加好友、JID理解等" target="_blank">基于openfire+smack开发Android即时聊天应用[三]-账号信息、添加好友、JID理解等</a></p>
<h3 id="9-发送文件"><a href="#9-发送文件" class="headerlink" title="9.发送文件"></a>9.发送文件</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//获取文件传输对象</span></span><br><span class="line">OutgoingFileTransfer transfer = getSendFileTransfer(jid);</span><br><span class="line"><span class="hljs-comment">//发送文件</span></span><br><span class="line">transfer.sendFile(File file, String description);</span><br><span class="line"><span class="hljs-comment">//此处执行文件发送状态监听</span></span><br><span class="line">以上代码为发送文件file，参数description为对这次文件传输的描述</span><br></pre></td></tr></table></figure>
<h3 id="10-文件传输-包括文件发送与接收-过程监听-传输开始、完成、进度百分比"><a href="#10-文件传输-包括文件发送与接收-过程监听-传输开始、完成、进度百分比" class="headerlink" title="10.文件传输(包括文件发送与接收)过程监听(传输开始、完成、进度百分比)"></a>10.文件传输(包括文件发送与接收)过程监听(传输开始、完成、进度百分比)</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//文件传输过程中的状态监听分析</span></span><br><span class="line"><span class="hljs-keyword">if</span>(transfer.getProgress() &lt; <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//开始传输</span></span><br><span class="line"><span class="hljs-comment">//传输进度，值为0~1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">while</span>(!transfer.isDone()) &#123;<span class="hljs-comment">//判断传输是否完成，传输取消、传输完成、传输发生错误都会返回true</span></span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="hljs-number">200</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span>(FileTransfer.Status.complete.equals(transfer.getStatus())) &#123;</span><br><span class="line">    <span class="hljs-comment">//传输完成	</span></span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(FileTransfer.Status.cancelled.equals(transfer.getStatus())) &#123;</span><br><span class="line">    <span class="hljs-comment">//传输取消</span></span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(FileTransfer.Status.error.equals(transfer.getStatus())) &#123;</span><br><span class="line">    <span class="hljs-comment">//传输错误</span></span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(FileTransfer.Status.refused.equals(transfer.getStatus())) &#123;</span><br><span class="line">    <span class="hljs-comment">//传输拒绝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码需在子线程执行，可以在文件传输(发送、接收)开始时设置进度条，传输完成时去掉进度条，同时可以通过<code>getProgress()</code>方法获得文件传输的具体进度百分比。</p>
<h3 id="11-接收文件"><a href="#11-接收文件" class="headerlink" title="11.接收文件"></a>11.接收文件</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 添加文件接收的监听</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> fileTransferListener</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFileTransferListener</span><span class="hljs-params">(FileTransferListener fileTransferListener)</span> </span>&#123;</span><br><span class="line">    	<span class="hljs-keyword">if</span>(isConnected()) &#123;</span><br><span class="line">	    FileTransferManager.getInstanceFor(connection).addFileTransferListener(fileTransferListener);</span><br><span class="line">	    <span class="hljs-keyword">return</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"服务器连接失败，请先连接服务器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">addFileTransferListener(<span class="hljs-keyword">new</span> FileTransferListener() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fileTransferRequest</span><span class="hljs-params">(FileTransferRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">// Accept it</span></span><br><span class="line">	IncomingFileTransfer transfer = request.accept();</span><br><span class="line">	<span class="hljs-keyword">try</span> &#123;</span><br><span class="line">	    String description = request.getDescription();</span><br><span class="line">	    <span class="hljs-comment">//在目录fileDir目录下新建一个名字为request.getFileName()的文件</span></span><br><span class="line">            File file = <span class="hljs-keyword">new</span> File(fileDir ,request.getFileName());</span><br><span class="line">            <span class="hljs-comment">//开始接收文件(将传输过来的文件内容输出到file中)</span></span><br><span class="line">	    transfer.recieveFile(file);</span><br><span class="line">	    <span class="hljs-comment">//此处执行文件传输监听</span></span><br><span class="line">	&#125; <span class="hljs-keyword">catch</span> (SmackException | IOException e) &#123;</span><br><span class="line">	    e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码为设置文件接收监听</p>
<h3 id="12-发送语音、图片消息"><a href="#12-发送语音、图片消息" class="headerlink" title="12.发送语音、图片消息"></a>12.发送语音、图片消息</h3><p>我查看了半天的Smack的API，但是没有找到直接发送语音、图片消息的API，我说说我的实现思路。</p>
<ul>
<li><p>其实图片、语音都是文件，我们可以把它们当做文件发送给好友。</p>
</li>
<li><p>在发送文件的同时，用描述字段进行标记传输过来的是图片还是语音。</p>
</li>
<li><p>然后在接收到该文件后通过描述字段进行区分当前接收的是图片文件还是语音文件，然后进行区分展示即可，这样就可以达到发送图片消息和语音消息。</p>
</li>
<li><p>但是我的这种实现方式还是有问题的，因为这种方式对于单聊还是可以实现的。但是如果是群聊的话，我就必须给每个人都发一个相同的文件，这样的话一条语音或图片消息，其实是要发送N次的，对于发送人来说流量就多消耗了N-1倍，所以这种方式对于实现群聊是行不通的。</p>
</li>
</ul>
<p>对于群聊发送语音和图片消息，我的<font color="red">思路</font>是这样的：</p>
<ol>
<li>自己写一个上传文件的服务。</li>
<li>发送语音或图片消息时，将图片或语音通过上述上传服务上传到服务器上。</li>
<li>在上传完语音或图片后，再向聊天室里发送一个文本消息，发送内容为文件的类似下载地址这样的信息，同时还要告诉群成员这个文件是图片还是语音。</li>
<li>群成员接收到这样的特殊文本消息后去自动下载这个文件然后进行展示或是其他处理。</li>
<li>群聊天里发送图片或语音消息的这个实现方式我没有验证，但我觉得应该是可行的。至于单聊发送语音或图片消息的思路我是实现验证成功了的，是可行的。</li>
</ol>
<p>write by laohu</p>
<p>2015-10-30 </p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> IM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于openfire+smack开发Android即时聊天应用[三]-账号信息、添加好友、JID理解等]]></title>
      <url>http://ittiger.cn/%E5%9F%BA%E4%BA%8Eopenfire-smack%E5%BC%80%E5%8F%91Android%E5%8D%B3%E6%97%B6%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8-%E4%B8%89-%E8%B4%A6%E5%8F%B7%E4%BF%A1%E6%81%AF%E3%80%81%E6%B7%BB%E5%8A%A0%E5%A5%BD%E5%8F%8B%E3%80%81JID%E7%90%86%E8%A7%A3%E7%AD%89.html</url>
      <content type="html"><![CDATA[<p>这一篇文章主要介绍账号的属性及几个重要属性的理解，同时介绍如何添加好友，获取好友列表信息，最后介绍我对JID这个属性字段的几种理解。</p>
<a id="more"></a>
<h3 id="1-账号信息"><a href="#1-账号信息" class="headerlink" title="1.账号信息"></a>1.账号信息</h3><p>获取账号的所有额外属性信息</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">   * 获取账户所有属性信息</span></span><br><span class="line"><span class="hljs-comment">   * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> Set <span class="hljs-title">getAccountAttributes</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  	<span class="hljs-keyword">if</span>(isConnected()) &#123;</span><br><span class="line">  	    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">  		<span class="hljs-keyword">return</span> AccountManager.getInstance(connection).getAccountAttributes();</span><br><span class="line">   &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);</span><br><span class="line">   &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"服务器连接失败，请先连接服务器"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上面取出的属性集合里主要包含如下几个属性值：</p>
<p><img src="/img/account_att.png" alt></p>
<p>上述几个属性中的name属性即为用户的昵称属性，另外用户账号名、密码是不在这些属性当中的，账号名可以理解为是JID，可以通过RosterEntry.getUser这个方法获取，关于JID的理解请看下面的介绍</p>
<h3 id="2-获取当前登录用户的所有好友信息"><a href="#2-获取当前登录用户的所有好友信息" class="headerlink" title="2.获取当前登录用户的所有好友信息"></a>2.获取当前登录用户的所有好友信息</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">  * 获取当前登录用户的所有好友信息</span></span><br><span class="line"><span class="hljs-comment">  * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">  */</span></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">public</span> Set <span class="hljs-title">getAllFriends</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"> 	<span class="hljs-keyword">if</span>(isConnected()) &#123;</span><br><span class="line"> 	    <span class="hljs-keyword">return</span> Roster.getInstanceFor(connection).getEntries();</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"服务器连接失败，请先连接服务器"</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-获取指定账号好友信息"><a href="#3-获取指定账号好友信息" class="headerlink" title="3.获取指定账号好友信息"></a>3.获取指定账号好友信息</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">  * 获取指定账号的好友信息</span></span><br><span class="line"><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> user	账号</span></span><br><span class="line"><span class="hljs-comment">  * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">  */</span></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">public</span> RosterEntry <span class="hljs-title">getFriend</span><span class="hljs-params">(String user)</span> </span>&#123;</span><br><span class="line"> 	<span class="hljs-keyword">if</span>(isConnected()) &#123;</span><br><span class="line"> 	    <span class="hljs-keyword">return</span> Roster.getInstanceFor(connection).getEntry(user);</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"服务器连接失败，请先连接服务器"</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-添加好友"><a href="#4-添加好友" class="headerlink" title="4.添加好友"></a>4.添加好友</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">   * 添加好友</span></span><br><span class="line"><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> user         用户账号</span></span><br><span class="line"><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> nickName	   用户昵称</span></span><br><span class="line"><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> groupName    所属组名</span></span><br><span class="line"><span class="hljs-comment">   * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">   */</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addFriend</span><span class="hljs-params">(String user, String nickName, String groupName)</span> </span>&#123;</span><br><span class="line">  	<span class="hljs-keyword">if</span>(isConnected()) &#123;</span><br><span class="line">  		<span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    Roster.getInstanceFor(connection).createEntry(user, nickName, <span class="hljs-keyword">new</span> String[]&#123;groupName&#125;);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125; <span class="hljs-keyword">catch</span> (NotLoggedInException | NoResponseException | XMPPErrorException </span><br><span class="line">                              | NotConnectedException e) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">"服务器连接失败，请先连接服务器"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-关于对JID的理解"><a href="#5-关于对JID的理解" class="headerlink" title="5.关于对JID的理解"></a>5.关于对JID的理解</h3><p>我对JID的理解主要是根据我在基于smack开发即时通信聊天应用时遇到的几种情况做的一个归纳，我碰到的JID的介绍主要有三种：</p>
<ol>
<li>每个用户的好友列表中有一个JID，这个可以根据Openfire后台管理系统可以看出来，如下图：Smack_JID上面图中可以清晰的看到每个好友都对应有一个JID，而在我通过<code>addFriend(String user, String nickName, String groupName)</code>这个方法添加好友的时候，参数用户账号user最终就变成了上面的JID，是没有包含@符号和后面的服务器名的，我称这种JID为好友JID，如管理员账号的JID为：admin。这个JID通过官方提供的接口<code>RosterEntry.getUser</code>是可以获取到的。</li>
</ol>
<ol start="2">
<li>好友之间聊天时有一个JID，在我创建聊天窗口对象Chat时(怎么创建请看我下一篇文章)，所传的参数也是JID，但是这个JID和上面的JID的值却又不是一样的，不然会创建失败，我们来看看官方API：</li>
</ol>
<p><img src="/img/Chat_JID.png" alt></p>
<p>官方API中很明显的指出了参数为JID，但是我如果真的出好友列表中的JID的话创建聊天对象失败，必须这样传好友<code>JID@ServiceName</code> ，这是第二种JID，我称为聊天JID,比如和管理员聊天时的JID为：<a href="mailto:`admin@192.168.0.108" target="_blank" rel="noopener">`admin@192.168.0.108</a>`</p>
<ol start="3">
<li>好友之间传输文件时又有一个JID，在创建文件传输对象时也需要传递一个参数为JID，我们也来看看官方API：</li>
</ol>
<p><img src="/img/transfer_JID.png" alt></p>
<p>官方API中也显示了在获取文件传输对象时需要传递参数为JID，但是这个JID我给的是聊天JID的时候，根本创建不了文件传输对象，后来在网上查了半天，看到别人都在后面加了个Smack，我也试了下，结果竟然成功了，坑爹啊，反正我还没搞清楚这是为什么，格式是这样的：好友<code>JID@ServiceNam/Smack</code>，我称这种JID为文件传输JID，比如聊天时给管理员传文件时的JID为：<a href="mailto:`admin@192.168.0.108" target="_blank" rel="noopener">`admin@192.168.0.108</a>/Smack`</p>
<p>这就是我碰到的JID的三种使用情况</p>
<p>write by laohu</p>
<p>2015-10-30 </p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> IM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于openfire+smack开发Android即时聊天应用[二]-用户注册、登陆、修改密码、注销等]]></title>
      <url>http://ittiger.cn/%E5%9F%BA%E4%BA%8Eopenfire-smack%E5%BC%80%E5%8F%91Android%E5%8D%B3%E6%97%B6%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8-%E4%BA%8C-%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E3%80%81%E7%99%BB%E9%99%86%E3%80%81%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E3%80%81%E6%B3%A8%E9%94%80%E7%AD%89.html</url>
      <content type="html"><![CDATA[<h3 id="1-开发准备"><a href="#1-开发准备" class="headerlink" title="1. 开发准备"></a>1. 开发准备</h3><p>在官网上下载最新的Smack开发包，我下载的是smack4.1.4版本的，导入相应的jar包即可开始开发工作</p>
<a id="more"></a>
<p><img src="/img/smack_jar.png" alt></p>
<h3 id="2-Openfire服务连接-连接服务器"><a href="#2-Openfire服务连接-连接服务器" class="headerlink" title="2. Openfire服务连接(连接服务器)"></a>2. Openfire服务连接(连接服务器)</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 连接服务器</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> XMPPTCPConnection <span class="hljs-title">connect</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">	<span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    	XMPPTCPConnectionConfiguration config = XMPPTCPConnectionConfiguration.builder()</span><br><span class="line">    	.setHost(SERVER_IP)<span class="hljs-comment">//服务器IP地址</span></span><br><span class="line">    	<span class="hljs-comment">//服务器端口</span></span><br><span class="line">    	.setPort(PORT)</span><br><span class="line">    	<span class="hljs-comment">//服务器名称</span></span><br><span class="line">    	.setServiceName(SERVER_NAME)</span><br><span class="line">    	<span class="hljs-comment">//是否开启安全模式</span></span><br><span class="line">    	.setSecurityMode(XMPPTCPConnectionConfiguration.SecurityMode.disabled)</span><br><span class="line">    	<span class="hljs-comment">//是否开启压缩</span></span><br><span class="line">    	.setCompressionEnabled(<span class="hljs-keyword">false</span>)</span><br><span class="line">    	<span class="hljs-comment">//开启调试模式</span></span><br><span class="line">    	.setDebuggerEnabled(<span class="hljs-keyword">true</span>).build();</span><br><span class="line">    	</span><br><span class="line">    	XMPPTCPConnection connection = <span class="hljs-keyword">new</span> XMPPTCPConnection(config);</span><br><span class="line">            connection.connect();</span><br><span class="line">            <span class="hljs-keyword">return</span> connection;</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    	<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-登陆Openfire服务"><a href="#3-登陆Openfire服务" class="headerlink" title="3.登陆Openfire服务"></a>3.登陆Openfire服务</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">   <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 是否连接成功</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConnected</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    	<span class="hljs-keyword">if</span>(connection == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">    		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="hljs-keyword">if</span>(!connection.isConnected()) &#123;</span><br><span class="line">    	    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">		connection.connect();</span><br><span class="line">		<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">	    &#125; <span class="hljs-keyword">catch</span> (SmackException | IOException | XMPPException e) &#123;</span><br><span class="line">		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 登陆</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user		用户账号</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> password		用户密码</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception </span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">login</span><span class="hljs-params">(String user, String password)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    	<span class="hljs-keyword">if</span>(!isConnected()) &#123;</span><br><span class="line">    	    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            connection.login(user, password);</span><br><span class="line">            <span class="hljs-keyword">return</span>  <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="hljs-keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 4.用户注册</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">该功能会在服务器上创建一个新的账号信息</span><br><span class="line">```java</span><br><span class="line">   <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 注册用户信息</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user        账号，是用来登陆用的，不是用户昵称</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> password    账号密码</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> attributes  账号其他属性，参考AccountManager.getAccountAttributes()的属性介绍</span></span><br><span class="line"><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">registerUser</span><span class="hljs-params">(String user, String password, Map&lt;String, String&gt; attributes)</span> </span>&#123;</span><br><span class="line">    	<span class="hljs-keyword">if</span>(!isConnected()) &#123;</span><br><span class="line">    	    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="hljs-keyword">try</span> &#123;</span><br><span class="line">	    AccountManager.getInstance(connection).createAccount(user, password, attributes);</span><br><span class="line">	    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">	&#125; <span class="hljs-keyword">catch</span> (NoResponseException | XMPPErrorException | NotConnectedException e) &#123;</span><br><span class="line">	    Log.e(TAG, <span class="hljs-string">"注册失败"</span>, e);</span><br><span class="line">	    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-修改账号密码"><a href="#5-修改账号密码" class="headerlink" title="5.修改账号密码"></a>5.修改账号密码</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">    * 修改密码</span></span><br><span class="line"><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> newpassword    新密码</span></span><br><span class="line"><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">    */</span></span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">changePassword</span><span class="hljs-params">(String newpassword)</span> </span>&#123;</span><br><span class="line">   	<span class="hljs-keyword">if</span>(!isConnected()) &#123;</span><br><span class="line">   	    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">   	&#125;</span><br><span class="line"><span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    AccountManager.getInstance(connection).changePassword(newpassword);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125; <span class="hljs-keyword">catch</span> (NoResponseException | XMPPErrorException | NotConnectedException e) &#123;</span><br><span class="line">    Log.e(TAG, <span class="hljs-string">"密码修改失败"</span>, e);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-注销-断开连接"><a href="#6-注销-断开连接" class="headerlink" title="6.注销(断开连接)"></a>6.注销(断开连接)</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">  * 注销</span></span><br><span class="line"><span class="hljs-comment">  * <span class="hljs-doctag">@return</span></span></span><br><span class="line"><span class="hljs-comment">  */</span></span><br><span class="line"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">logout</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"> 	<span class="hljs-keyword">if</span>(!isConnected()) &#123;</span><br><span class="line"> 	    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line">     <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">         connection.instantShutdown();</span><br><span class="line">         <span class="hljs-keyword">return</span>  <span class="hljs-keyword">true</span>;</span><br><span class="line">     &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">         <span class="hljs-keyword">return</span>  <span class="hljs-keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-删除账号"><a href="#7-删除账号" class="headerlink" title="7.删除账号"></a>7.删除账号</h3><pre><code class="java"><span class="comment">/**</span>
<span class="comment">  * 删除当前登录的用户信息(从服务器上删除当前用户账号)</span>
<span class="comment">  * <span class="doctag">@return</span></span>
<span class="comment">  */</span>
 <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteUser</span><span class="params">()</span> </span>{
     <span class="keyword">if</span>(!isConnected()) {
         <span class="keyword">return</span> <span class="keyword">false</span>;
     }
     <span class="keyword">try</span> {
     AccountManager.getInstance(connection).deleteAccount();<span class="comment">//删除该账号</span>
     <span class="keyword">return</span> <span class="keyword">true</span>;
 } <span class="keyword">catch</span> (NoResponseException | XMPPErrorException | NotConnectedException e) {
     <span class="keyword">return</span> <span class="keyword">false</span>;
 }
 }
</code></pre>
<p>代码都非常简单，smack的api调用很方便。</p>
<p>write by laohu</p>
<p>2015-10-30 </p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> IM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于openfire+smack开发Android即时聊天应用[一]—openfire安装部署]]></title>
      <url>http://ittiger.cn/%E5%9F%BA%E4%BA%8Eopenfire-smack%E5%BC%80%E5%8F%91Android%E5%8D%B3%E6%97%B6%E8%81%8A%E5%A4%A9%E5%BA%94%E7%94%A8-%E4%B8%80-%E2%80%94openfire%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2.html</url>
      <content type="html"><![CDATA[<p>Java领域的即时通信解决方案可以考虑基于xmpp协议的openfire+smack+spark来实现，都是开源的。最近一直在研究这个，也做了一个简单的Android即时聊天客户端，支持文本、图片、语音消息。</p>
<p>Demo地址请见此系列文章最后一篇</p>
<a id="more"></a>
<h3 id="XMPP协议"><a href="#XMPP协议" class="headerlink" title="XMPP协议"></a>XMPP协议</h3><p>大家自行到百度google上去补脑吧。</p>
<h3 id="openfire、smack、spark"><a href="#openfire、smack、spark" class="headerlink" title="openfire、smack、spark"></a>openfire、smack、spark</h3><ul>
<li>openfire是基于XMPP 协议的即时通信的服务器端的一个实现，如果你要实现一个简单的点对点通信或是简单的群聊，你完全可以使用该服务openfire本身提供的服务而不需要编写一行服务端的代码，非常方便。同时openfire还支持插件的扩展，如果你需要丰富增加服务端的功能，你可以基于openfire进行插件二次开发，或者直接修改openfire的源码实现。</li>
<li>smack是XMPP传输协议的Java实现，提供了一套API接口(类似于JDK中的HttpUrlConnection提供Http连接请求)，它是连接openfire服务、发送通信信息的桥梁。</li>
<li>spark是基于smack实现的一个XMPP即时通信客户端(PC端的)，spark貌似也是可以进行插件扩展的。<br>官网：<a href="http://www.igniterealtime.org/，我目前用的都是最新版本的openfire3.10.2，smack4.1.4" target="_blank" rel="noopener">http://www.igniterealtime.org/，我目前用的都是最新版本的openfire3.10.2，smack4.1.4</a><br>在smack4.1版本之前，smack本身是不支持Android平台的，不过当时有一个替代品asmack，github地址：<a href="https://github.com/flowdalic/asmack，在smack4.1之前我们可以通过asmack来配合openfire来实现Android端的即时通信应用，asmack和smack貌似api都差不多(我没看过asmack)。smack4.1之后就开始支持Android平台了，所以现在可以放弃asmack了。" target="_blank" rel="noopener">https://github.com/flowdalic/asmack，在smack4.1之前我们可以通过asmack来配合openfire来实现Android端的即时通信应用，asmack和smack貌似api都差不多(我没看过asmack)。smack4.1之后就开始支持Android平台了，所以现在可以放弃asmack了。</a><h3 id="Windows下的Openfire安装部署"><a href="#Windows下的Openfire安装部署" class="headerlink" title="Windows下的Openfire安装部署"></a>Windows下的Openfire安装部署</h3>去官网上下载最新的Openfire安装包，我下载的是不包含JDK的压缩包(Does not include Java JRE)，解压就可以用了，前提是你已经装了JDK了，而且JDK版本必须是1.7或以上的版本，Openfire不支持JDK6，解压之后在Openfire的根目录bin目录下执行openfire.exe即可，启动之后如下图</li>
</ul>
<p><img src="/img/openfire_0.png" alt></p>
<p>在启动服务配置之前，先在你的数据库中创建一个名为openfire的数据库(支持多种数据库)，点击图中的Launch Admin即会在浏览器上打开Openfire的配置界面，如下图：</p>
<p><img src="/img/openfire_1.png" alt></p>
<p>上图中选择简体中文，然后继续：</p>
<p><img src="/img/openfire_2.png" alt></p>
<p>上图中配置域，最好配置为你的服务器ip地址或者是域名，其他的默认不管，然后继续：</p>
<p><img src="/img/openfire_3.png" alt></p>
<p>上图中选择标准数据库连接，继续：</p>
<p><img src="/img/openfire_4.png" alt></p>
<p>上图中选择你的数据库类型，然后在数据库URL中填写正确的连接字符串，再填上你的数据库用户名和密码，然后继续</p>
<p><img src="/img/openfire_5.png" alt></p>
<p>上图中直接默认选择初始设置，然后继续：</p>
<p><img src="/img/openfire_6.png" alt></p>
<p>上图中填上管理员账户admin的邮件地址，然后填上该管理员账户的密码，然后继续：</p>
<p><img src="/img/openfire_7.png" alt></p>
<p>到上图即表示你的Openfire服务安装配置完成，然后点击登录后进入到管理员登录界面：</p>
<p><img src="/img/openfire_8.png" alt></p>
<p>Openfire默认的管理员账户为admin，秘密即为上面你设置的密码，登录成功之后，你可以通过这个Openfire管理平台管理该服务商所有的账户信息，服务器信息等。</p>
<h3 id="Linux环境下Openfire的安装部署"><a href="#Linux环境下Openfire的安装部署" class="headerlink" title="Linux环境下Openfire的安装部署"></a>Linux环境下Openfire的安装部署</h3><p>在官网上下载最新的源码安装包(如： openfire_3_10_2.tar.gz )，我选择的也是不包含jdk的源码安装包，将该包上传至服务器某个目录下，在该目录下执行命令 tar -zxvf openfire_3_10_2.tar.gz，解压完成后切换到Openfire/bin目录下执行命令： ./openfire start 启动Openfire服务，然后在你自己的pc机浏览器上打开http://服务器ip:9090,即会进入Openfire的配置界面，前提是必须准备好一个数据库，配置过程与Windows下的配置过程一样，请参考上面的操作步骤。</p>
<p>OK，Openfire服务的安装配置就介绍完了，下面一篇我就开始介绍smack的用法。</p>
<p>write by laohu</p>
<p>2015-10-30 15:59:54</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> IM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android开发问题汇总–持续更新]]></title>
      <url>http://ittiger.cn/android-tips-for-develop.html</url>
      <content type="html"><![CDATA[<p>Android开发中遇到的小问题汇总，会持续更新。</p>
<p>提供网上一个Android开放问题汇总贴：<a href="https://github.com/JohnTsaiAndroid/AndroidTips" target="_blank" rel="noopener">https://github.com/JohnTsaiAndroid/AndroidTips</a></p>
<a id="more"></a>
<ol>
<li><p>TextView控件中给文本添加下划线的几种方式:</p>
<p> 1.资源文件中用HTML标签<u>把文本包起来即可</u></p>
<figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hello"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Java代码中可以这样处理：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TextView textView = (TextView)findViewById(R.id.tv_test); </span><br><span class="line">textView.setText(Html.fromHtml(<span class="hljs-string">"&lt;u&gt;"</span>+<span class="hljs-string">"hello"</span>+<span class="hljs-string">"&lt;/u&gt;"</span>));</span><br><span class="line"><span class="hljs-comment">//或者这样处理</span></span><br><span class="line">textView .getPaint().setFlags(Paint.UNDERLINE_TEXT_FLAG ); <span class="hljs-comment">//下划线</span></span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>当将一个Android工程设置为Library之后，在另外一个Android工程中如果通过Configure build Path –&gt; Java Build Path –&gt; Project选项 –&gt; Add刚刚设置的library工程的话，是无法识别library工程中的资源文件的(引用资源文件编译不通过)。应该这样设置Configure build Path –&gt; Android –&gt; library选项 –&gt; Add刚刚设置的library工程。</li>
</ol>
<ol start="3">
<li>Java中三目运算符如果和自动拆箱一起用会出现空指针异常，如下代码：<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Boolean&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, Boolean&gt;();</span><br><span class="line">Boolean b = (map != <span class="hljs-keyword">null</span> ? map.get(<span class="hljs-string">"test"</span>) : <span class="hljs-keyword">false</span>);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>出现空指针的原因是因为Java三目运算符中第二、三位操作数为基本类型和对象时，会自动将对象拆箱为基本类型数据进行运算(大家可以自己去看官方文档)，上述代码中刚好符合这种情况(第二位为对象，第三位为基本类型)，map.get(“test”)在实际执行中是这样执行的：((Boolean)map.get(“test”)).booleanValue()，将map中取得的Boolean对象自动拆箱为基本类型，而这个地方map.get(“test”)取出的值为null，自动拆箱的时候就会出现空指针了。如果这个地方一定要用三目运算符，只需要保证第二、三位操作数均为对象即可<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Boolean&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Boolean b = (map != <span class="hljs-keyword">null</span> ? map.get(<span class="hljs-string">"test"</span>) : Boolean.valueOf(<span class="hljs-keyword">false</span>));</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li>Activity中两个Fragment进行切换时，例如：有FragmentA和FragmentB，进入Activity的时候，默认显示FragmentA，我点击FragmentA中的某个按钮切换到FragmentB，同时调用addToBackStack加入到返回栈，当我在FragmentB中点击返回按钮回到FragmentA时，FragmentA中的onResume方法却不执行。遇到这个问题的话可以看看在Activity中是否还保持了对FragmentB的引用，比如加入到了某个集合中或是声明成了Activity的成员变量，都会引发此问题。</li>
</ol>
<ol start="5">
<li>Android中内部类就算实现了Serializable接口，也不能通过Intent进行序列化传参。如果传递的参数为序列化对象，该对象类不能是某个类里面的内部类。</li>
</ol>
<ol start="6">
<li><code>java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState。</code>出现问题的时机：我在进行Activity跳转时，会调用super.onBackPressed()方法手动finish掉当前的Activity（继承自android.support.v4.app.FragmentActivity），当屏幕处于竖屏状态时没有任何问题，但是当我设置为横屏在进行跳转操作时，会出现上述异常。 异常信息如下：<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: Can not perform <span class="hljs-keyword">this</span> action after onSaveInstanceState</span><br><span class="line">	</span><br><span class="line">at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:<span class="hljs-number">1343</span>)</span><br><span class="line">	</span><br><span class="line">at android.support.v4.app.FragmentManagerImpl.popBackStackImmediate(FragmentManager.java:<span class="hljs-number">486</span>)</span><br><span class="line">	</span><br><span class="line">at android.support.v4.app.FragmentActivity.onBackPressed(FragmentActivity.java:<span class="hljs-number">179</span>)</span><br><span class="line">	</span><br><span class="line">at com.emap.base.BaseActivity.finishActivity(BaseActivity.java:<span class="hljs-number">360</span>)</span><br><span class="line">	</span><br><span class="line">at com.emap.air.activity.IndexActivity$<span class="hljs-number">1</span>.handleMessage(IndexActivity.java:<span class="hljs-number">128</span>)</span><br><span class="line">	</span><br><span class="line">at android.os.Handler.dispatchMessage(Handler.java:<span class="hljs-number">99</span>)</span><br><span class="line">	</span><br><span class="line">at android.os.Looper.loop(Looper.java:<span class="hljs-number">137</span>)</span><br><span class="line">	</span><br><span class="line">at android.app.ActivityThread.main(ActivityThread.java:<span class="hljs-number">5119</span>)</span><br><span class="line">	</span><br><span class="line">at java.lang.reflect.Method.invokeNative(Native Method)</span><br><span class="line">	</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="hljs-number">511</span>)</span><br><span class="line">	</span><br><span class="line">at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:<span class="hljs-number">834</span>)</span><br><span class="line">	</span><br><span class="line">at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:<span class="hljs-number">601</span>)</span><br><span class="line">	</span><br><span class="line">at dalvik.system.NativeStart.main(Native Method)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通过上述异常可以看出错误出现的原因并不是我自己写的代码导致的，猜测的话可能跟系统版本有关。</p>
<p>解决办法：将super.onBackPressed()替换成finish()方法来结束当前Activity即可。</p>
<p>参考文章：<a href="http://zhiweiofli.iteye.com/blog/1539467" target="_blank" rel="noopener">http://zhiweiofli.iteye.com/blog/1539467</a></p>
<ol start="7">
<li>TextView通过代码设置字体大小要使用如下方式<code>textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, getResources().getDimensionPixelSize(R.dimen.dp_10));</code>必须要使用该方法设置单位类型，否则设置的字体效果会和你预期的不一样</li>
</ol>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[红米Note调用系统相机拍照后应用崩溃问题分析解决]]></title>
      <url>http://ittiger.cn/%E7%BA%A2%E7%B1%B3Note%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%9B%B8%E6%9C%BA%E6%8B%8D%E7%85%A7%E5%90%8E%E5%BA%94%E7%94%A8%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E8%A7%A3%E5%86%B3.html</url>
      <content type="html"><![CDATA[<p>这几天突然发现红米Note手机只要调用系统相机进行拍照时，我的应用必定会崩溃。这个问题折腾了好久才解决，现在记录下问题跟踪解决的过程和方法。(红米Note手机的系统太坑爹了%&gt;_&lt;%)</p>
<p>####解决办法<br>请直接从第7条开始看，1~5条为我的问题处理过程，第6条为问题原因分析。</p>
<a id="more"></a>
<p>####问题原因分析</p>
<ol>
<li><p>问题刚出现的时候，当然是想调试，在调用系统相机拍照的前后代码出打好断点准备调试，结果发现这段代码没有任何异常(其实想想也是正常的，因为其他手机都是好的，唯独红米Note有问题，要是这段代码有问题，其他手机应该也有问题，这一步真是多余)</p>
</li>
<li><p>既然暂时找不到系统崩溃时代码的出错行，那只有去查看系统崩溃日志了(这里提一下，应用开发时一定要通过UncaughtExceptionHandler捕获系统未处理的系统，并在uncaughtException(Thread thread, Throwable ex)方法中记录异常日志，不然应用运行中崩溃了完全无法快速准确的定位错误信息)。</p>
</li>
<li><p>当我打开日志文件一看，傻眼了，这日志记录完全无法定位错误信息(日志记录不完全，也没有准确记录，没有记录出错的代码行以及相关的方法运行栈信息)。没办法，我只能想办法重新改写记录日志的方式，下面是我记录异常信息日志的方法，可以准确的定位到出错的代码行和方法，以及其运行前后的方法栈信息：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uncaughtException</span><span class="hljs-params">(Thread thread, Throwable ex)</span> </span>&#123;</span><br><span class="line">	String logdir = logPath ;  </span><br><span class="line">        File file = <span class="hljs-keyword">new</span> File(logdir);  </span><br><span class="line">        <span class="hljs-keyword">boolean</span> mkSuccess;  </span><br><span class="line">        <span class="hljs-keyword">if</span> (!file.isDirectory()) &#123;  </span><br><span class="line">            mkSuccess = file.mkdirs();  </span><br><span class="line">            <span class="hljs-keyword">if</span> (!mkSuccess) &#123;  </span><br><span class="line">                mkSuccess = file.mkdirs();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();</span><br><span class="line">        DateFormat formatter = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd-HH-mm-ss"</span>);</span><br><span class="line">        Writer writer = <span class="hljs-keyword">new</span> StringWriter();  </span><br><span class="line">        PrintWriter printWriter = <span class="hljs-keyword">new</span> PrintWriter(writer);  </span><br><span class="line">        ex.printStackTrace(printWriter);  </span><br><span class="line">        Throwable cause = ex.getCause();  </span><br><span class="line">        <span class="hljs-keyword">while</span> (cause != <span class="hljs-keyword">null</span>) &#123;  </span><br><span class="line">            cause.printStackTrace(printWriter);  </span><br><span class="line">            cause = cause.getCause();  </span><br><span class="line">        &#125;  </span><br><span class="line">        printWriter.close();  </span><br><span class="line">        String result = writer.toString();  </span><br><span class="line">        sb.append(result);  </span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;  </span><br><span class="line">            String time = formatter.format(<span class="hljs-keyword">new</span> Date());</span><br><span class="line">            String logFile = logdir + File.separator + time + <span class="hljs-string">".log"</span>;</span><br><span class="line">            </span><br><span class="line">            FileOutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(logFile);  </span><br><span class="line">            fos.write(sb.toString().getBytes());</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            Log.e(TAG, <span class="hljs-string">"an error occured while writing file..."</span>, e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    </span><br><span class="line">	<span class="hljs-keyword">if</span> (!handleException(ex) &amp;&amp; mDefaultHandler != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">	    mDefaultHandler.uncaughtException(thread, ex);</span><br><span class="line">	&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">	    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">	        Thread.sleep(<span class="hljs-number">1000</span>);</span><br><span class="line">	    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">	        Log.e(TAG, <span class="hljs-string">"Error : "</span>, e);</span><br><span class="line">	    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class="line">	System.exit(<span class="hljs-number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新运行了几次，发现每次出错的地方竟然还不一样(但每次出错都是空指针异常引起的)，有时候是调用系统相机的那个Activity的onCreate方法调用的时候出现空指针，有时候是调用系统相机的前面一个Activity的onCreate方法中出现空指针(假设界面A跳到界面B，在B中调用系统相机，出错的时候A和B中的onCreate方法里都有空指针异常信息)，知道出现错误的代码行数这救你好办了，赶紧打好断点准备调试，结果竟然发现不管怎么操作，代码就是不进断点。</p>
</li>
<li><p>代码不进断点，就没法找到问题根源，只能分析代码寻求解决办法了，我在出现空指针错误的地方加上非空判断，重新运行发现这几个地方虽然不出错了，但是又在其他的地方出现空指针异常了，经过分析发现所有出现空指针的地方都是我的自定义Application里面的某几个static引用型变量为空了。分析到这里，在加上前面的代码不进断点以及空指针出现onCreate方法中，猜测是不是应用直接被系统回收了。</p>
</li>
<li><p>调用系统相机的时候，应用被系统回收(Application、处于后台和前台的Activity都被销毁，静态变量全部消失)，此时拍照完成之后重新恢复创建Activity(重新创建的时候，手机与编辑器的调试状态肯定就断掉了，因此通过onCreate重新创建Activity时无法进到断点)，重新调用onCreate时，因为该方法中有用到自定义Application里的static变量(此时已被销毁)，所以会出现空指针异常。至于为什么界面A和B对应的onCreate方法中都会出现空指针，那是因为B调用系统相机完成之后会重新创建，创建失败之后按照Activity的栈顺序会接着创建界面A，而A中的onCreate方法里也用到了自定义Application里的static变量，所以也出现了空指针。</p>
</li>
<li><p>既然知道了问题原因，那就来寻求解决办法，我在onSaveInstanceState(Bundle outState)方法中保存当前Activity里操作过的所有变量信息，然后在重新创建该Activity时通过onRestoreInstanceState(Bundle savedInstanceState)方法来恢复这些数据信息(这两个方法的执行机制请参考我的另外一篇文章：Android基础篇之：Activity生命周期)，同时在onCreate中用到自定义Application里的static变量的地方进行非空判断(为空的时候进行重新初始化)，进过这一系列的代码处理之后，再次运行正常，完美解决问题。</p>
</li>
<li><p>不过在步骤7中解决问题时发现，在处理应用被回收重新创建时要注意如下几点：</p>
</li>
</ol>
<ul>
<li>Activity里用户操作的所有数据全部需要保存</li>
<li>Activity中第一次初始化时获取到的变量也需要保存</li>
<li>用户登陆后所有拥有的相关权限也需要进行处理保存</li>
<li>数据恢复时要考虑当前Activity引用的其他Activity或Application里面的变量的再次初始化</li>
<li>所有自定义对象都最好能被序列化，否则无法进行状态保存</li>
<li>尽量少用static类型的变量</li>
<li>有些服务能不在Application中初始化，最好不要在Application中初始化。</li>
<li>在Application中定义的变量最后都在Application中进行初始化创建，不要部分在Application进行初始化，部分在其他的Activity里进行初始化</li>
<li>应用开发时要考虑到应用被回收的情况，以便真正被回收后能方便的解决(虽然应用被回收的几率很低，但是不排除某些坑爹的手机很容易被回收，就像红米Note一样)。</li>
</ul>
<p>write by laohu</p>
<p>2015年10月22日</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android基础之TableLayout中TextView文本无法自动换行]]></title>
      <url>http://ittiger.cn/android-textview-unable-to-switch-lines-automatically-in-tableLayout.html</url>
      <content type="html"><![CDATA[<p>最近项目中用到了TableLayout布局，发现该布局下的TextView控件的内容无法达到自动换行的效果，布局代码如下：</p>
<a id="more"></a>
<figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="hljs-tag">     <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"fill_parent"</span></span></span><br><span class="line"><span class="hljs-tag">     <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"fill_parent"</span></span></span><br><span class="line"><span class="hljs-tag">     <span class="hljs-attr">android:background</span>=<span class="hljs-string">"@drawable/sys_shade_bg_color"</span></span></span><br><span class="line"><span class="hljs-tag">     <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"vertical"</span></span></span><br><span class="line"><span class="hljs-tag">     <span class="hljs-attr">android:paddingLeft</span>=<span class="hljs-string">"@dimen/gap_20"</span></span></span><br><span class="line"><span class="hljs-tag">     <span class="hljs-attr">android:paddingTop</span>=<span class="hljs-string">"@dimen/gap_30"</span> </span></span><br><span class="line"><span class="hljs-tag">     <span class="hljs-attr">android:paddingRight</span>=<span class="hljs-string">"@dimen/gap_20"</span>&gt;</span></span><br><span class="line">     <span class="hljs-tag">&lt;<span class="hljs-name">TableLayout</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">"40dp"</span>&gt;</span></span><br><span class="line">         <span class="hljs-tag">&lt;<span class="hljs-name">TableRow</span></span></span><br><span class="line"><span class="hljs-tag">             <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">             <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">             <span class="hljs-attr">android:paddingBottom</span>=<span class="hljs-string">"10dp"</span> &gt;</span></span><br><span class="line">                  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"right"</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:text</span>=<span class="hljs-string">"@string/about_company_address"</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">"@color/white"</span> /&gt;</span></span><br><span class="line">                  <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:singleLine</span>=<span class="hljs-string">"false"</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:text</span>=<span class="hljs-string">"公司地址1公司地址2公司地址3公司地址4公司地址5公司地址6"</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">"@color/white"</span> /&gt;</span></span><br><span class="line">         <span class="hljs-tag">&lt;/<span class="hljs-name">TableRow</span>&gt;</span></span><br><span class="line">         <span class="hljs-tag">&lt;<span class="hljs-name">TableRow</span></span></span><br><span class="line"><span class="hljs-tag">             <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">             <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">             <span class="hljs-attr">android:paddingBottom</span>=<span class="hljs-string">"@dimen/gap_10"</span> &gt;</span></span><br><span class="line">                 <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"right"</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:text</span>=<span class="hljs-string">"@string/about_company_phone"</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">"@color/white"</span> /&gt;</span></span><br><span class="line">                <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:text</span>=<span class="hljs-string">"XXX-XXXXXXX"</span></span></span><br><span class="line"><span class="hljs-tag">                     <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">"@color/white"</span> /&gt;</span></span><br><span class="line">           <span class="hljs-tag">&lt;/<span class="hljs-name">TableRow</span>&gt;</span></span><br><span class="line">      <span class="hljs-tag">&lt;/<span class="hljs-name">TableLayout</span>&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样布局后，理所当然的认为没问题，毕竟我的TextView中添加了singline属性为false，结果发现效果不是我</p>
<p>想要的</p>
<p><img src="/img/2016072834.png" alt></p>
<p>查看布局效果，发现跟我预期的不一样，公司地址的文本虽然换行了，但是有部分字被隐藏了没有显示出来，而且可以明显的看到展示公司地址文本的TextView的宽度已经超出了屏幕，很显然这就是导致部分文字没显示出来的原因。</p>
<p>既然子布局TextView的宽度超出了TableLayout的宽度，那就想办法让子布局的宽度根据容器的宽度进行收缩，而TableLayout刚好有个属性shrinkColumns可以设置其子布局的宽度收缩以适应容器的大小。</p>
<p>我设置<code>TableLayout</code>的属性<code>android:shrinkColumns=”1″</code>后，立马就达到了我想要的效果。</p>
<p>另外<code>TableLayout</code>还有个属性<code>stretchColumns</code>是用来设置子布局的宽度进行拉伸适应容器大小的</p>
<p>这两个属性的具体用法，大家自行去补脑吧。</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> View </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android基础之Activity生命周期]]></title>
      <url>http://ittiger.cn/Android-Activity-LifeCycle.html</url>
      <content type="html"><![CDATA[<p>之前一直对Activity的生命周期不是很清楚，感觉很模糊。前两天也看了下任玉刚书里对Activity生命周期的讲解，今天特意写了个程序验证了下Activity的生命周期内各个回调的执行情况，为了避免多段时日又忘了，干脆对这次的理解总结下，俗话说好记性不如烂笔头，没事的时候可以回过头来再看看。</p>
<p>我们先来看一张非常经典的Activity生命周期流程图：<br><a id="more"></a></p>
<p><img src="/img/2016072822.png" alt></p>
<p>Activity的生命周期大致有如下几个成果：</p>
<ol>
<li>启动Activity：系统会先调用onCreate，然后调用onStart，最后调用onResume，此时Activity进入前台处于运行状态。如图：</li>
</ol>
<p><img src="/img/2016072823.png" alt></p>
<p><img src="/img/2016072824.png" alt></p>
<ol start="2">
<li>当前Activity被其他Activity覆盖，且覆盖的这个Activity是为透明：系统只会调用onPause，此时Activity处于后台可见暂停运行状态。如图：</li>
</ol>
<p><img src="/img/2016072825.png" alt></p>
<p><img src="/img/2016072826.png" alt></p>
<ol start="3">
<li>当前Activity被其他Activity覆盖，且覆盖的这个Activity为非透明：系统处理过程与步骤4中的过程是一样的。如图：</li>
</ol>
<p><img src="/img/2016072827.png" alt></p>
<p><img src="/img/2016072828.png" alt></p>
<ol start="4">
<li>手机锁屏或按下了Home键：系统会先调用onPause，最后调用onStop，此时Activity处于后台非可见暂停运行状态。如图：</li>
</ol>
<p><img src="/img/2016072829.png" alt></p>
<ol start="5">
<li>如果在步骤2时，用户后退回到了此Activity：系统会调用onResume，此时Activity回到前台继续运行。如图：</li>
</ol>
<p><img src="/img/2016072830.png" alt></p>
<ol start="6">
<li>如果在步骤3和4时，用户后退或解锁回到了此Activity：系统会调用onRestart，然后调用onStart，最后调用onResume，然后此Activity回到前台继续运行。如图：</li>
</ol>
<p><img src="/img/2016072831.png" alt></p>
<ol start="7">
<li><p>当Activity处于被覆盖或后台不可见时(即步骤3和4)，系统内存不足时会杀死该Activity(系统杀死Activity时，步骤3与4的Activity的被杀优先级会比步骤2高)，这时如果用户后退回到该Activity，系统会重新执行onCreate，onStart，onResume进入运行状态。此过程不好验证，不提供图片了。</p>
</li>
<li><p>用户退出Activity时：系统会先执行onPause，然后执行onStop，最后执行onDestory方法结束此Activity的运行。如图：</p>
</li>
</ol>
<p><img src="/img/2016072832.png" alt></p>
<ol start="9">
<li>系统内存不足杀死Activity结束运行时的生命周期函数执行情况我目前无法验证，暂时不是很清楚。</li>
</ol>
<p>从上面的生命周期过程来看，主要涉及到了7个生命周期函数，下面是我对于每个生命周期主要作用的理解：</p>
<ol>
<li><p><code>onCreate：</code>用于Activity的初始化，例如设置布局，初始化相关布局控件等。</p>
</li>
<li><p><code>onStart：</code>设置Activity窗口可见</p>
</li>
<li><p><code>onResume：</code>让Activity窗口处于系统前台</p>
</li>
<li><p><code>onRestart：</code>在Activity由不可见回到可见时，需要通过此方法唤起onStart的执行</p>
</li>
<li><p><code>onPause：</code>让Activity窗口退出系统前台(参照上面的过程2理解)，与onResume方法刚好是一对</p>
</li>
<li><p><code>onStop：</code>让Activity窗口不可见(参照上面的过程3和过程4理解)，与onStart方法刚好是一对</p>
</li>
<li><p><code>onDestory：</code>结束Activity，销毁相关资源</p>
</li>
</ol>
<p>光说了这些理论的东西是不够，只有亲自测试验证过了记忆才够深刻，下面是我测试验证的主要代码：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifeCycle_A_Activity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> </span>&#123;</span><br><span class="line">	<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String TAG = getClass().getSimpleName();</span><br><span class="line">	<span class="hljs-keyword">private</span> Button btn1;</span><br><span class="line">	<span class="hljs-keyword">private</span> Button btn2;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_lifecycle_a_layout);</span><br><span class="line">		btn1 = (Button) findViewById(R.id.btn_lifecycle);</span><br><span class="line">		btn2 = (Button) findViewById(R.id.btn_lifecycle2);</span><br><span class="line">		btn1.setText(<span class="hljs-string">"跳转到LifeCycle_B_Activity(透明)"</span>);</span><br><span class="line">		btn2.setText(<span class="hljs-string">"跳转到LifeCycle_C_Activity(非透明)"</span>);</span><br><span class="line">		</span><br><span class="line">		btn1.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			<span class="hljs-meta">@Override</span></span><br><span class="line">			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;</span><br><span class="line">		            toAnotherActivity(LifeCycle_B_Activity.class);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		btn2.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener() &#123;</span><br><span class="line">			<span class="hljs-meta">@Override</span></span><br><span class="line">			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;</span><br><span class="line">			    toAnotherActivity(LifeCycle_C_Activity.class);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		Log.i(TAG, <span class="hljs-string">"LifeCycle----onCreate"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toAnotherActivity</span><span class="hljs-params">(Class&lt;?&gt; claxx)</span> </span>&#123;</span><br><span class="line">            startActivity(<span class="hljs-keyword">new</span> Intent(LifeCycle_A_Activity.<span class="hljs-keyword">this</span>, claxx));</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStart</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">super</span>.onStart();</span><br><span class="line">		Log.i(TAG, <span class="hljs-string">"LifeCycle----onStart"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRestart</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">super</span>.onRestart();</span><br><span class="line">		Log.i(TAG, <span class="hljs-string">"LifeCycle----onRestart"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResume</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">super</span>.onResume();</span><br><span class="line">		Log.i(TAG, <span class="hljs-string">"LifeCycle----onResume"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStop</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">super</span>.onStop();</span><br><span class="line">		Log.i(TAG, <span class="hljs-string">"LifeCycle----onStop"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPause</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">super</span>.onPause();</span><br><span class="line">		Log.i(TAG, <span class="hljs-string">"LifeCycle----onPause"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">super</span>.onDestroy();</span><br><span class="line">		Log.i(TAG, <span class="hljs-string">"LifeCycle----onDestroy"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSaveInstanceState</span><span class="hljs-params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">		outState.putInt(<span class="hljs-string">"stateParam"</span>, <span class="hljs-number">1</span>);</span><br><span class="line">		Log.i(TAG, <span class="hljs-string">"LifeCycle----onSaveInstanceState,save value is:"</span> + <span class="hljs-number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRestoreInstanceState</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">		<span class="hljs-keyword">int</span> value = savedInstanceState.getInt(<span class="hljs-string">"stateParam"</span>);</span><br><span class="line">		Log.i(TAG, <span class="hljs-string">"LifeCycle----onRestoreInstanceState,restore value is:"</span> + value);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onWindowFocusChanged</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> hasFocus)</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">super</span>.onWindowFocusChanged(hasFocus);</span><br><span class="line">		Log.i(TAG, <span class="hljs-string">"LifeCycle----onWindowFocusChanged, focus is:"</span> + hasFocus);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该Activity对应的布局文件代码如下：<br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="hljs-tag">     <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">     <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">     <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"center_horizontal"</span></span></span><br><span class="line"><span class="hljs-tag">     <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"vertical"</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">     <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> </span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/btn_lifecycle"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line">     <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> </span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/btn_lifecycle2"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Activity跳转后覆盖的透明与非透明的Activity代码及布局文件如下：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//透明的Activity，在注册Activity时需要添加theme属性</span></span><br><span class="line"><span class="hljs-comment">//android:theme="@android:style/Theme.Translucent"</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifeCycle_B_Activity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> </span>&#123;</span><br><span class="line">	<span class="hljs-keyword">private</span> Button btn;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_lifecycle_b_layout);</span><br><span class="line">		btn = (Button) findViewById(R.id.btn_lifecycle);</span><br><span class="line">		btn.setText(<span class="hljs-string">"当前为LifeCycle_B_Activity(透明)"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">//非透明的Activity</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifeCycle_C_Activity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> </span>&#123;</span><br><span class="line">	<span class="hljs-keyword">private</span> Button btn;</span><br><span class="line">	</span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_lifecycle_b_layout);</span><br><span class="line">		btn = (Button) findViewById(R.id.btn_lifecycle);</span><br><span class="line">		btn.setText(<span class="hljs-string">"当前为LifeCycle_C_Activity(非透明)"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="hljs-tag">     <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">     <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span></span></span><br><span class="line"><span class="hljs-tag">     <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">"center"</span></span></span><br><span class="line"><span class="hljs-tag">     <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"vertical"</span> &gt;</span></span><br><span class="line"> </span><br><span class="line">     <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> </span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/btn_lifecycle"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span></span></span><br><span class="line"><span class="hljs-tag">         <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>/&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>很明显，上面的验证代码中我多写了三个方法<code>onWindowFocusChanged</code>，<code>onSaveInstanceState</code>，<code>onRestoreInstanceState</code>，这三个方法都不属于Activity生命周期函数，只是这三个函数在Activity生命周期变化时，对于我们的应用开发还是紧密相关的，所以我给加进来一起看下他们的执行时机。</p>
<ol>
<li><p><code>onWindowFocusChanged：</code>看名字就可以知道，这个函数是Activity窗体焦点发生变化时的回调，比如Activity在前台显示，被覆盖，手机截屏，按下Home键等等，都会触发该方法。再结合我上面生命周期过程验证结果，其实更容易理解，该函数只会在Activity是否前台显示发生变化时触发，也就是在<code>onResume</code>或<code>onPause</code>调用后触发该函数。当我们想在Activity初始化时获取某个特定组件的大小时，在<code>onCreate</code>中是无法获取的，因为这个时候Window对象还没有创建完成，这个时候，我们可以通过<code>onWindowFocusChanged</code>函数来获取指定组件的大小。</p>
</li>
<li><p><code></code>onSaveInstanceState：`</p>
<ol start="3">
<li>当系统资源不足杀死Activity时会调用该函数。</li>
<li>当屏幕方向发生变化时也会调用该函数。</li>
<li>当Activity被覆盖或锁屏或按下Home键时都会调用该函数。该方法主要用于保存当前窗体各个视图组件View的状态信息，当然我们也可以手动保存一些临时变量以避免资源不足Activity被杀死或屏幕发生变化后无法恢复到之前状态。根据上面的生命周期过程验证发现<code>onSaveInstanceState</code>是在Activity由前台显示变为不显示时触发，也就是在onPause调用后触发该函数。这个也很容易理解，当Activity由前台显示变为后台显示时，只有先将当前的窗体各个视图组件状态保存起来，系统后续恢复起来才有依据才知道恢复到什么样子。</li>
</ol>
</li>
<li><p><code>onRestoreInstanceState：</code>该函数与<code>onSaveInstanceState</code>相对的，它主要用于恢复用户保存的一些临时数据以及系统之前通过<code>onSaveInstanceState</code>保存的各个组件的状态信息。此方法目前经过验证只在屏幕方向发生变化时才会调用。系统资源不足杀死Activity后重新恢复创建Activity这种情况无法验证，这种情况是否执行待验证。</p>
</li>
</ol>
<p>屏幕方向发生变化时验证如下结果如下图(在手机设置中先设置为自动旋转屏幕，在AndroidMainfest.xml中注册Activity时不要设置android:screenOrientation属性)：</p>
<p><img src="/img/2016072833.png" alt></p>
<p>上面日志中清晰的记载了Activity销毁之前保存的临时变量通过<code>onRestoreInstanceState</code>可用获取得到。</p>
<p>write by laohu</p>
<p>2015年10月8日21:56:06</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[简单实用的Android ORM框架TigerDB]]></title>
      <url>http://ittiger.cn/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8%E7%9A%84Android-ORM%E6%A1%86%E6%9E%B6TigerDB.html</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/huyongli/TigerDB" target="_blank" rel="noopener">TigerDB</a>是一个简单的<code>Android ORM</code>框架，它能让你一句话实现数据库的增删改查，同时支持实体对象的持久化和自动映射，同时你也不必关心表结构的变化，因为它会自动检测新增字段来更新你的表结构。</p>
<p>该库主要包括如下几个要点：</p>
<ol>
<li>根据实体对象自动建表、新增字段(SQLite不支持删除字段列)</li>
<li>支持注解配置表名、字段名、字段默认值、主键是否自增长以及哪些字段不作为数据表中的映射字段</li>
<li>直接映射实体对象到SQLite数据库，实现一行代码对SQLite数据库增删改查</li>
<li>支持在SDCard中新建数据库db</li>
<li>解决在onCreate，onUpgrade中执行数据库其他操作时出现的异常(java.lang.IllegalStateException: getDatabase called recursively)</li>
<li>支持原生SQL语句操作数据库</li>
</ol>
<a id="more"></a>
<p>该ORM库使用过程中的主要类说明：</p>
<ol>
<li><code>SQLiteDBConfig</code>：主要用于设置数据库的名字、创建路径、版本号、数据创建更新时的监听</li>
<li><code>SQLiteDB</code>：创建完数据库之后，主要通过此类来操作数据库的增删改查</li>
<li><code>SQLiteDBFactory</code>：该类主要用于创建SQLite数据库，同时缓存当前创建的SQLiteDB对象</li>
<li><code>CursorUtil</code>：查询数据库时，检测游标对象Cursor是否正常，解析Cursor数据为实体对象</li>
<li><code>IDBListener</code>：数据库创建、升级时的监听类，提供了空实现SimpleDBListener</li>
<li><code>Column</code>：该注解用来设置字段名、字段默认值</li>
<li><code>PrimaryKey</code>：该注解用来设置主键、主键字段名、以及主键是否为自增长</li>
<li><code>Table</code>：该注解用来设置表名，不设置的话默认类名为表名</li>
<li><code>NotDBColumn</code>：该注解用来设置哪些实体属性不映射到数据表中</li>
</ol>
<p>主要用法如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//新建实体，可以通过注解@Table设置表名,如果不设置默认以类名User作为表名</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">	<span class="hljs-comment">//设置主键id为自增长，也可以通过注解@Column设置字段名或字段默认值</span></span><br><span class="line">	<span class="hljs-meta">@PrimaryKey</span>(isAutoGenerate=<span class="hljs-keyword">true</span>)</span><br><span class="line">	<span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> id;</span><br><span class="line">		</span><br><span class="line">	<span class="hljs-keyword">private</span> String name;</span><br><span class="line">		</span><br><span class="line">	<span class="hljs-comment">//设置age字段默认值为1</span></span><br><span class="line">	<span class="hljs-meta">@Column</span>(defaultValue=<span class="hljs-string">"1"</span>)</span><br><span class="line">	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;</span><br><span class="line">		</span><br><span class="line">	<span class="hljs-comment">//该字段不作为数据表中的字段</span></span><br><span class="line">	<span class="hljs-meta">@NotDBColumn</span></span><br><span class="line">	<span class="hljs-keyword">private</span> String bz;</span><br><span class="line">		</span><br><span class="line">	<span class="hljs-comment">//必须实现无参构造</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">super</span>();</span><br><span class="line">		<span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="hljs-meta">@Override</span></span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">		<span class="hljs-keyword">return</span> <span class="hljs-string">"&#123;id="</span> + id + <span class="hljs-string">",name="</span> + name + <span class="hljs-string">"&#125;"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="hljs-comment">//SQLite相关配置，包括数据库名字、创建路径、版本号、数据创建和升级时的监听</span></span><br><span class="line">SQLiteDBConfig config = <span class="hljs-keyword">new</span> SQLiteDBConfig(<span class="hljs-keyword">this</span>);</span><br><span class="line"><span class="hljs-comment">//设置数据库创建更新时的监听，有提供空实现：SimpleDBListener</span></span><br><span class="line">config.setDbListener(<span class="hljs-keyword">new</span> IDBListener() &#123;</span><br><span class="line"> 	<span class="hljs-meta">@Override</span></span><br><span class="line"> 	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUpgradeHandler</span><span class="hljs-params">(SQLiteDatabase db, <span class="hljs-keyword">int</span> oldVersion, <span class="hljs-keyword">int</span> newVersion)</span> </span>&#123;</span><br><span class="line">  				</span><br><span class="line">  	&#125;</span><br><span class="line">  			</span><br><span class="line">  	<span class="hljs-meta">@Override</span></span><br><span class="line">  	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDbCreateHandler</span><span class="hljs-params">(SQLiteDatabase db)</span> </span>&#123;</span><br><span class="line">  		showLongToast(<span class="hljs-string">"数据库创建成功"</span>);</span><br><span class="line">  	&#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="hljs-comment">//创建db，在创建数据库的时候，不需要在onDbCreateHandler手动去创建相关的数据表，在对实体对象进行数据操作的时候，会自动判断表是否存在，不存在的话会自动创建，同时如果有新增的字段也会自动更新表结构</span></span><br><span class="line"> SQLiteDB db = SQLiteDBFactory.createSQLiteDB(config);</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">//保存单个实体对象</span></span><br><span class="line">User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">"添加单个对象"</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> rtn = db.save(user)</span><br><span class="line">		</span><br><span class="line"><span class="hljs-comment">//保存集合对象</span></span><br><span class="line">List list = <span class="hljs-keyword">new</span> ArrayList();</span><br><span class="line"><span class="hljs-keyword">int</span> rtn = db.save(list)</span><br><span class="line">		</span><br><span class="line"><span class="hljs-comment">//查询User表中的所有数据</span></span><br><span class="line">List list = db.queryAll(User.class);</span><br><span class="line">	</span><br><span class="line"><span class="hljs-comment">//根据实体id(主键)查询User</span></span><br><span class="line">User user = db.query(User.class, <span class="hljs-string">"1"</span>);</span><br><span class="line">	</span><br><span class="line"><span class="hljs-comment">//查询User表中的数据总数</span></span><br><span class="line"><span class="hljs-keyword">long</span> total = db.queryTotal(User.class);</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">//删除指定实体对象</span></span><br><span class="line">db.delete(user);</span><br><span class="line">	</span><br><span class="line"><span class="hljs-comment">//更新实体对象</span></span><br><span class="line">db.update(user);</span><br><span class="line">	</span><br><span class="line"><span class="hljs-comment">//分页查询</span></span><br><span class="line">db.queryPage(claxx, curPage, pageSize);</span><br><span class="line">	</span><br><span class="line"><span class="hljs-comment">//根据SQL查询</span></span><br><span class="line">Cursor cursor = db.query(sql, bindArgs)；</span><br></pre></td></tr></table></figure></p>
<p>源码及Demo地址：<a href="https://github.com/huyongli/TigerDB，大家可以自行下载查看" target="_blank" rel="noopener">https://github.com/huyongli/TigerDB，大家可以自行下载查看</a></p>
<p>如果大家有什么疑问和建议，欢迎提出</p>
<p>write by  laohu</p>
<p>2015年9月28日</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> DB </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WordPress安装插件提示无法定位WordPress内容目录（wp-content）]]></title>
      <url>http://ittiger.cn/WordPress%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E6%8F%90%E7%A4%BA%E6%97%A0%E6%B3%95%E5%AE%9A%E4%BD%8DWordPress%E5%86%85%E5%AE%B9%E7%9B%AE%E5%BD%95%EF%BC%88wp-content%EF%BC%89.html</url>
      <content type="html"><![CDATA[<p>在我刚把WordPress环境搭建好后，安装插件的时候提示如下错误信息：</p>
<p>WordPress安装插件提示无法定位WordPress内容目录（wp-content），最后找网上搜索之后，发现下面的方法可行：</p>
<p>在WordPress配置文件 <code>wp-config.php</code>最后加上如下代码：</p>
<figure class="highlight php hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//-----无法定位WordPress Content目录(wp-content)  解决方案---------begin  </span></span><br><span class="line"><span class="hljs-keyword">if</span>(is_admin()) &#123;add_filter(<span class="hljs-string">'filesystem_method'</span>, create_function(<span class="hljs-string">'$a'</span>, <span class="hljs-string">'return "direct";'</span> ));define( <span class="hljs-string">'FS_CHMOD_DIR'</span>, <span class="hljs-number">0751</span> );&#125;  </span><br><span class="line"><span class="hljs-comment">//-----无法定位WordPress Content目录(wp-content)  解决方案---------end</span></span><br></pre></td></tr></table></figure>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> WordPress </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[WordPress安装插件提示无法创建目录]]></title>
      <url>http://ittiger.cn/WordPress%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E6%8F%90%E7%A4%BA%E6%97%A0%E6%B3%95%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95.html</url>
      <content type="html"><![CDATA[<p>出现这个问题有几种可能：</p>
<ol>
<li>服务器没有安装vsftpd服务，很明显我装了</li>
<li><p>vsftpd的用户没有对plugin目录的写权限，检查之后发现我新建的用户是有这个权限的</p>
<ul>
<li>如果没有写权限的话，需要对WordPress的目录 <code>/var/www/html/wp-content/plugins</code>赋予写权限的，我们来个直接的运行命令：   <code>chmod 777 /var/www/html/wp-content/plugins</code>，主要是的第三个7起作用，对其他用户赋予读写权限</li>
</ul>
</li>
<li><p>最后检查发现我的vsftpd.conf配置文件中 chroot_local_user的值设置成了No， 该配置表示我的本地Ftp用户不能切换到ftp主目录外的其他目录，而我的ftp主目录与WordPress的Plugin的目录明显不是同一个。既然该用户都不能切换目录，如何到Plugin目录进行写操作呢，所以立马更改该配置为YES，再次安装插件就成功了</p>
</li>
<li><p>另外，如果还不行的话可以检查下vsftpd.conf配置文件中 chroot_list_enable的值，如果chroot_list_enable=YES该配置表示 /etc/vsftpd.chroot_list文件中列出的用户，可以切换到其他目录。</p>
</li>
</ol>
<a id="more"></a>
<p><code>chroot_local_user</code>配置与<code>chroot_list_enable</code>配置通过搭配能实现以下几种效果：</p>
<ul>
<li>①当<code>chroot_list_enable=YES</code>，<code>chroot_local_user=YES</code>时，在<code>/etc/vsftpd.chroot_list</code>文件中列出的用户，可以切换到其他目录；未在文件中列出的用户，不能切换到其他目录。</li>
<li>②当<code>chroot_list_enable=YES</code>，<code>chroot_local_user=NO</code>时，在<code>/etc/vsftpd.chroot_list</code>文件中列出的用户，不能切换到其他目录；未在文件中列出的用户，可以切换到其他目录。</li>
<li>③当<code>chroot_list_enable=NO</code>，<code>chroot_local_user=YES</code>时，所有的用户均不能切换到其他目录。</li>
<li>④当<code>chroot_list_enable=NO</code>，<code>chroot_local_user=NO</code>时，所有的用户均可以切换到其他目录</li>
</ul>
<p>如果WordPress上传多媒体文件(图片)时提示无法建立目录<code>wp-content/uploads…</code>，则可以将目录 <code>/var/www/html/wp-contents</code>的权限也赋予为读写权限</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> WordPress </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[阿里云服务器安装vsftpd]]></title>
      <url>http://ittiger.cn/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85vsftpd.html</url>
      <content type="html"><![CDATA[<p>运行命令：<code>yun install vsftpd</code>  安装vsftpd</p>
<p>将vsftpd设置为开机启动：<code>chkconfig vsftpd on</code></p>
<p>启动vsftpd服务： <code>service vsftpd start</code></p>
<p>管理vsftpd相关服务：</p>
<p>停止：<code>service vsftpd stop</code></p>
<p>重启：<code>service vsftpd restart</code></p>
<a id="more"></a>
<p>为vsftpd添加用户，用户名为<code>ftpuser</code>，设置其主目录为<code>/home/ftp：</code></p>
<p>运行命令：<code>useradd -d /home/ftp -g ftp -s /sbin/nologin ftpuser</code></p>
<p>设置该用户的密码：<code>passwd ftpuser</code></p>
<p>配置vsftpd服务，只允许刚刚新添加的用户ftpuser登陆ftp服务，其默认主配置文件在：<code>/etc/vsftpd/vsftpd.conf</code></p>
<ol>
<li><p><code>userlist_enable=YES              # 是否启用vsftpd.user_list文件</code></p>
</li>
<li><p><code>userlist_deny=NO                 # 决定vsftpd.user_list文件中的用户是否能够访问FTP服务器。若设置为YES，则vsftpd.user_list文件中的用户不允许访问FTP，若设置为NO，则只有vsftpd.user_list文件中的用户才能访问FTP</code></p>
</li>
<li><p><code>将 /etc/vsftpd/user_list文件中的所有用户全部注释掉，添加刚刚添加的用户ftpuser</code>，如下：</p>
<figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># vsftpd userlist </span></span><br><span class="line"><span class="hljs-comment"># If userlist_deny=NO, only allow users in this file</span></span><br><span class="line"><span class="hljs-comment"># If userlist_deny=YES (default), never allow users in this file, and </span></span><br><span class="line"><span class="hljs-comment"># do not even prompt for a password. </span></span><br><span class="line"><span class="hljs-comment"># Note that the default vsftpd pam config also checks /etc/vsftpd/ftpusers </span></span><br><span class="line"><span class="hljs-comment"># for users that are denied.</span></span><br><span class="line"><span class="hljs-comment">#root </span></span><br><span class="line"><span class="hljs-comment">#bin</span></span><br><span class="line"><span class="hljs-comment">#daemon </span></span><br><span class="line"><span class="hljs-comment">#adm</span></span><br><span class="line"><span class="hljs-comment">#lp </span></span><br><span class="line"><span class="hljs-comment">#sync </span></span><br><span class="line"><span class="hljs-comment">#shutdown </span></span><br><span class="line"><span class="hljs-comment">#halt </span></span><br><span class="line"><span class="hljs-comment">#mail </span></span><br><span class="line"><span class="hljs-comment">#news </span></span><br><span class="line"><span class="hljs-comment">#uucp </span></span><br><span class="line"><span class="hljs-comment">#operator </span></span><br><span class="line"><span class="hljs-comment">#games </span></span><br><span class="line"><span class="hljs-comment">#nobody </span></span><br><span class="line">ftpuser</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>配置到这里，就可以远程用FTP客户端登录并上传文件，文件会保存在ftpuser的主目录，也就是<code>/home/ftp</code></p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[阿里云服务器安装MySQL]]></title>
      <url>http://ittiger.cn/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85MySQL.html</url>
      <content type="html"><![CDATA[<p>运行命令：<code>yun install mysql</code>  安装MySQL客户端</p>
<p>紧接着运行命令：<code>yun install mysql-server</code>  安装MySQL服务</p>
<p>运行命令：<code>chkconfig –levels 235 mysqld on</code>  让MySQL服务可以自动启动</p>
<p>运行命令：<code>/etc/init.d/mysqld start</code>  立刻启动MySQL服务</p>
<a id="more"></a>
<p>设置MySQL的root密码，运行命令<code>/usr/bin/mysqladmin -u root password ‘new-password’</code>，其中<code>’new-password’</code>是新设的密码，如<code>123456</code></p>
<p>安装完成之后，MySQL的安装路径为：<code>/usr/share/mysql/</code>    其主配置文件在： <code>/etc/my.cnf</code></p>
<p>如果要MySQL支持中文，还需要进行相关字符配置，即在主配置文件<code>/etc/my.cnf</code>中添加如下两行配置：<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">character_set_server = utf8</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure></p>
<p>如果想通过自己机器上的客户端远程连接MySQL(阿里云默认是不允许远程连接的)，还需要做相关配置：</p>
<ol>
<li>在服务器上本地登陆MySQL：<code>mysql -u root -p …</code></li>
<li>切换到系统数据库：<code>use mysql</code></li>
<li>将user表中的host设置为%表示任何ip都能连接mysql<figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> host=’%’ <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span>=’root’ <span class="hljs-keyword">and</span> host=’localhost’;</span><br><span class="line"><span class="hljs-keyword">flush</span> <span class="hljs-keyword">privileges</span>;        <span class="hljs-comment">#刷新权限表，使配置生效</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果想关掉远程连接，按照上面的方式将host设置为localhost就可以了</p>
<p><code>update user set host=’localhost’ where user=’root’;</code></p>
<p>可以参考阿里云的官方bbs: <a href="https://bbs.aliyun.com/read.php?spm=5176.775973948.2.5.1ZxyGR&amp;tid=130069" target="_blank" rel="noopener">阿里云服务器新手入门</a></p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[阿里云服务器安装Apache]]></title>
      <url>http://ittiger.cn/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Apache.html</url>
      <content type="html"><![CDATA[<p>使用阿里云自带的安装命令：<code>yun install httpd</code><br>安装完成之后运行命令：<code>chkconfig --levels 235 httpd on</code><br>上面的命令可以让Apache开机自动启动。<br>运行命令：<code>/etc/init.d/httpd start</code> 让Apache立刻启动</p>
<p>启动过程中如果出现<code>Could not reliably determine the server&#39;s fully qualified domain name, using 10.161.94.31 for ServerName</code>提示，则将Apache安装目录<code>/etc/httpd/conf/</code>下的<code>httpd.conf</code>文件中的<code>#ServerName localhost:80</code>注释去掉即可，或是添加一行<code>ServerName localhost:80</code></p>
<p>阿里云上Apache安装路径为<code>/etc/httpd/</code></p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android基础之点击两次返回键退出程序]]></title>
      <url>http://ittiger.cn/android-exit-app-for-double-click.html</url>
      <content type="html"><![CDATA[<p>Android应用中退出应用程序通常有两种做法，一种是使用选择对话框询问用户是否退出应用程序，另外一种是快速点击返回按钮两次然后退出应用。其中第二种实现方式较为普遍，而且我个人认为这种方式用户体验性要好点。下面，我介绍两种常用的点击两次返回退出应用的实现方式。</p>
<a id="more"></a>
<ul>
<li><p>通过标识变量进行控制。首先定义一个布尔变量，赋初始值false。然后监听手机返回按钮，当点击返回按钮时，如果该布尔变量值为false，则把这个变量置为true；如果该变量为true，则退出程序。最后定义一个时间任务，2秒执行一次，如果布尔变量为true，则重置为false。这里定义一个循环周期为2秒的任务是为了达到快速点击两次的效果。<br>这样，在第一次点击返回按钮时，仅仅改变布尔值变量，而不会退出，第二次点击才会退出。如果用户点击了一次，那么2秒之后布尔变量又被重置为false，只有2秒内的两次点击才会退出程序。代码如下：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Boolean isQuit = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> Timer timer = <span class="hljs-keyword">new</span> Timer();</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBackPressed</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (isQuit == <span class="hljs-keyword">false</span>) &#123;</span><br><span class="line">        isQuit = <span class="hljs-keyword">true</span>;</span><br><span class="line">        Toast.makeText(getBaseContext(), <span class="hljs-string">"再按一次返回键退出程序"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        TimerTask task = <span class="hljs-keyword">null</span>;</span><br><span class="line">        task = <span class="hljs-keyword">new</span> TimerTask() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                isQuit = <span class="hljs-keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        timer.schedule(task, <span class="hljs-number">2000</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        finish();</span><br><span class="line">        System.exit(<span class="hljs-number">0</span>);</span><br><span class="line">        android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过两次点击返回按钮时的时间间隔进行判断。这种实现方式主要是用第二次点击返回按钮时的时间减去第一次点击的返回按钮时的时间，看这个时间差是否大于2秒，如果大于2秒则提示需要再点击一次才能退出，如果时间差小于等于2秒，则退出应用，实现代码如下：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> exitTime = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onBackPressed</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(System.currentTimeMillis() - exitTime &gt; <span class="hljs-number">2000</span>) &#123;</span><br><span class="line">        Toast.makeText(<span class="hljs-keyword">this</span>, <span class="hljs-string">"再按一次退出程序"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        exitTime = System.currentTimeMillis();</span><br><span class="line">   &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">       finish();</span><br><span class="line">       System.exit(<span class="hljs-number">0</span>);</span><br><span class="line">       android.os.Process.killProcess(android.os.Process.myPid());    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>我个人认为第二种实现方式更简单，更好理解，推荐使用这种实现方式。</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android调用相机无法执行onActivityResult或data为null]]></title>
      <url>http://ittiger.cn/android-camera-result-null.html</url>
      <content type="html"><![CDATA[<p>最近项目中调用系统相机时遇到了这么个问题：红米手机无法执行onActivityResult回调，部分华为手机无法获取到照片数据，最后各种分析，各种网上搜索资料折腾了好久，最后终于把问题解决，当看到问题的最终原因时，我也是醉了，简直就是坑爹坑大发了。</p>
<p>最开始用红米手机调用系统相机的时，当我拍照完成点击那个勾勾始终无法返回到前面的界面上，也就是无法调用onActivityResult函数取到拍照的照片，在网上搜索了一圈，没找到解决办法，都说是红米的系统问题，无法解决，项目比较紧张，刚好客户的手机全部是统一型号的华为荣耀6Plus，这个问题丢着暂时没管了。<br>后来现场同事批量测试机器时，发现有3台手机可以拍照，但是在onActivityResult回调中获取到的照片数据为null，但是其他的同型号手机又没这个问题，这问题看着真是坑爹啊。</p>
<a id="more"></a>
<p>远程调试代码后发现，我在调用系统相机时设置的照片存放目录无法创建成功，我调用系统相机的代码如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">takePicture</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//照片存放目录</span></span><br><span class="line">    File file = <span class="hljs-keyword">new</span> File(mPicDirectory);</span><br><span class="line">    <span class="hljs-keyword">if</span>(!file.exists()) &#123;<span class="hljs-comment">//目录不存在则创建该目录及其不存在的父目录</span></span><br><span class="line">        file.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    Intent intent = <span class="hljs-keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">    mPicName = getPictureName();<span class="hljs-comment">//获取照片名称</span></span><br><span class="line">    mPicPath = mPicDirectory + mPicName;<span class="hljs-comment">//照片存储路径</span></span><br><span class="line">    <span class="hljs-comment">//将照片保存到mPicPath位置</span></span><br><span class="line">    intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(<span class="hljs-keyword">new</span> File(mPicPath)));</span><br><span class="line">    startActivityForResult(intent, CODE_RESULT_TAKE_PHOTO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我调试的时候在onActivityResult回调里通过照片路径获取Bitmap对象的时候发现获取到的Bitmap对象一直为null，所以就猜想是不是照片没保存成功，我在文件管理系统里去找这个照片的时候发现，连照片存储目录mPicDirectory都不存在，我再次跟踪代码发现file.mkdirs()始终返回的都是false。看来问题的最终原因是这个：无法创建目录和文件(华为手机系统在拍照输出的时候，如果输出文件路径不存在时竟然没有任何提示和异常，这点对于发现问题的根源有点困难)。然后我又去检查了权限、手机设置里面的权限等所有有可能涉及的问题，结果依然没有效果。既然这些都不是导致目录创建失败的原因，那会不会是目录路径本身不正确呢，我的目录路径是这样获取的：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">String mPicDirectory = FileManager.getPath() + Configuration.SYS_PHOTO_PATH;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">//FileManager的部分代码是这样的，这个代码是以前的同事写的，没有细看过：</span></span><br><span class="line"> </span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getPath</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-keyword">boolean</span> sdCardExist = Environment.getExternalStorageState()</span><br><span class="line">        .equals(android.os.Environment.MEDIA_MOUNTED); <span class="hljs-comment">//判断sd卡是否存在 </span></span><br><span class="line"><span class="hljs-keyword">return</span> !sdCardExist ? MOBILE_PATH : SD_PATH;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">//sdcard路径</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span>  String SD_PATH = Environment.getExternalStorageDirectory().getAbsolutePath();</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">//应用数据路径</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String MOBILE_PATH = Environment.getDataDirectory().getAbsolutePath();</span><br><span class="line"> </span><br><span class="line"><span class="hljs-comment">//这里有一段静态代码块</span></span><br><span class="line"><span class="hljs-keyword">static</span>&#123;</span><br><span class="line">    File f = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"/storage/sdcard1"</span>);</span><br><span class="line">    <span class="hljs-keyword">if</span>(f.exists())&#123;</span><br><span class="line">        <span class="hljs-keyword">long</span> size = getFreeSize(<span class="hljs-string">"/storage/sdcard1"</span>);</span><br><span class="line">        <span class="hljs-keyword">long</span> sd0Size =  getFreeSize(<span class="hljs-string">"/storage/sdcard0"</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span>(size &gt; sd0Size)&#123;</span><br><span class="line">            SD_PATH = <span class="hljs-string">"/storage/sdcard1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我看到上面的静态代码块的时候，我立马就知道了问题的原因，静态代码块中做了一个剩余空间判断，选取的是空间比较大的那个sdcard路径，而且代码都是写死的<br><code>Environment.getExternalStorageDirectory().getAbsolutePath()</code>系统这个代码是获取手机里的内置SDCard的路径，我的红米手机自己又额外插了一张内存卡，这个是手机的外接SDCard，用<code>Environment.getExternalStorageDirectory()</code>获取到只是手机自带的外置SDCard路径，不能获取自己插入的内存卡路径，我的手机通过<code>Environment.getExternalStorageDirectory()</code>方式获取的路径是<code>/storage/sdcard0</code>（我手机内置的SDCard），而通过可用空间比较之后发现该卡的可用空间少于<code>/storage/sdcard1</code>（我自己插入的SDCard），所以最终路径变成了<code>/storage/sdcard1</code>，而在Android4.4以上后，不允许三方App对外接的SDCard进行操作，因此我们队最后得到的这个目录是没有写入权限的，所以我创建照片存储目录的时候一直失败，所以拍照的时候照片数据没有地方可以输出，华为手机是直接体现在照片数据无法获取，而红米手机则是直接不允许返回到前面的调用界面。</p>
<p>Google在Android中限制三方App操作外接SDCard的原文如下：</p>
<blockquote>
<p>The WRITE_EXTERNAL_STORAGE permission must only grant write access to the primary external storage on a device. Apps must not be allowed to write to secondary external storage devices, except in their package-specific directories as allowed by synthesized permissions.</p>
</blockquote>
<p>后来想了想，调用相机这么简单的一个功能，红米的系统应该不可能给阉割掉，所以出了问题还是老老实实的先找自己代码的问题吧。至于那个外接SDCard的写入权限还有待寻找答案。</p>
<p>系统内置SDCard写入、删除、读写权限：</p>
<figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//文件创建、删除权限</span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.MOUNT_UNMOUNT_FILESYSTEMS"</span> /&gt;</span></span><br><span class="line">//文件读写权限，只针对于手机内存的SDCard，对外接SDCard无效</span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.WRITE_EXTERNAL_STORAGE"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android基础之解压zip中文乱码处理]]></title>
      <url>http://ittiger.cn/android-random-code-for-unzip.html</url>
      <content type="html"><![CDATA[<p>####乱码原因分析<br>一般我们使用的Windows系统外部文件默认都是GBK编码方式，Mac系统默认的好像是UTF-8(同事的电脑就是，不知道其他人的是不是)，Linux的没验证过，这里我讨论的是Windows下打包的zip文件。   </p>
<p>Java中自带的ZipEntry解压缩的编码方式是UTF-8，而且没有可以自定义编码方式的接口，所以当我们使用UTF-8编码去解压缩GBK编码的文件的时，解压缩出来的中文部分当然是乱码，所以Mac上打包的zip用Java的自带解压缩接口解压出来是没有问题的。</p>
<a id="more"></a>
<p>####解决方式<br>找到了问题所在，解决方式也就比较简单了，既然是编码方式不同导致的，那我们保证编码方式统一即可，压缩zip时系统编码很难改变，那我们就从解压缩的编码方式入手，自定义解压缩的编码。</p>
<p>Apache中是有完整的替代解决方式的，但是Apache的包相对于Android说有点偏大不适合于Android环境，我们只需要找到解压缩的那部分代码进行改造即可，我这里找到了一个改造好的解压缩替代包，测试可行。示例代码如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> com.file.zip.ZipEntry;</span><br><span class="line"><span class="hljs-keyword">import</span> com.file.zip.ZipFile;</span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> file      待解压文件</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> dir       解压后文件的存放目录</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unzip</span><span class="hljs-params">(File file, String dir)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ZipFile zipFile = <span class="hljs-keyword">new</span> ZipFile(file, <span class="hljs-string">"GBK"</span>);<span class="hljs-comment">//设置压缩文件的编码方式为GBK</span></span><br><span class="line">    Enumeration&lt;ZipEntry&gt; entris = zipFile.getEntries();</span><br><span class="line">    ZipEntry zipEntry = <span class="hljs-keyword">null</span>;</span><br><span class="line">    File tmpFile = <span class="hljs-keyword">null</span>;</span><br><span class="line">    BufferedOutputStream bos = <span class="hljs-keyword">null</span>;</span><br><span class="line">    InputStream is = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];</span><br><span class="line">    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (entris.hasMoreElements()) &#123;</span><br><span class="line">        zipEntry = entris.nextElement();</span><br><span class="line">        <span class="hljs-comment">// 不进行文件夹的处理,些为特殊处理</span></span><br><span class="line">        tmpFile = <span class="hljs-keyword">new</span> File(dir + zipEntry.getName());</span><br><span class="line">        <span class="hljs-keyword">if</span> (zipEntry.isDirectory()) &#123;<span class="hljs-comment">//当前文件为目录</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (!tmpFile.exists()) &#123;</span><br><span class="line">                tmpFile.mkdir();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (!tmpFile.exists()) &#123;</span><br><span class="line">                tmpFile.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">            is = zipFile.getInputStream(zipEntry);</span><br><span class="line">            bos = <span class="hljs-keyword">new</span> BufferedOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(tmpFile));</span><br><span class="line">            <span class="hljs-keyword">while</span> ((len = is.read(buf)) &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                bos.write(buf, <span class="hljs-number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            bos.flush();</span><br><span class="line">            bos.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改造后的ZipEntry.jar包的下载地址：<a href="http://download.csdn.net/detail/huyongl1989/9120755" target="_blank" rel="noopener">http://download.csdn.net/detail/huyongl1989/9120755</a></p>
<hr>
<p>write by laohu<br>2015-09-26 21:34:09</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android基础之shape使用]]></title>
      <url>http://ittiger.cn/android-for-shape.html</url>
      <content type="html"><![CDATA[<p>Android中的shape标签用于描述形状，可以在布局文件layout和选择器selector中使用，它有6个子标签，具体如下：</p>
<a id="more"></a>
<figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">shape</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span> &gt;</span></span><br><span class="line">    <span class="hljs-comment">&lt;!-- 设置圆角效果 --&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">corners</span> </span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:radius</span>=<span class="hljs-string">"5dp"</span>/&gt;</span>                   </span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">&lt;!-- 设置背景渐变色 --&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">gradient</span> </span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:startColor</span>=<span class="hljs-string">"@color/red"</span>         </span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:endColor</span>=<span class="hljs-string">"@color/black"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:centerColor</span>=<span class="hljs-string">"@color/white"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:angle</span>=<span class="hljs-string">"-90"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:gradientRadius</span>=<span class="hljs-string">"90"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">&lt;!-- 边距间隔 --&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">padding</span> </span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:left</span>=<span class="hljs-string">"10dp"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:top</span>=<span class="hljs-string">"10dp"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:right</span>=<span class="hljs-string">"10dp"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:bottom</span>=<span class="hljs-string">"10dp"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">&lt;!-- 大小 --&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">size</span> </span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:width</span>=<span class="hljs-string">"20dp"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:height</span>=<span class="hljs-string">"20dp"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">&lt;!-- 背景填充色 --&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">solid</span> </span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:color</span>=<span class="hljs-string">"@color/red"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">&lt;!--边框线 --&gt;</span></span><br><span class="line">    <span class="hljs-tag">&lt;<span class="hljs-name">stroke</span> </span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:color</span>=<span class="hljs-string">"@color/black"</span></span></span><br><span class="line"><span class="hljs-tag">        <span class="hljs-attr">android:width</span>=<span class="hljs-string">"2dp"</span>/&gt;</span></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>shape</code>：根节点 <shape>有一个shape属性，可以设置不同的形状<ol start="2">
<li><code>android:shape=&quot;line&quot;</code>：设置shape为线形（包括实线、虚线）</li>
<li><code>android:shape=&quot;rectangle&quot;</code>：设置shape为矩形</li>
<li><code>android:shape=&quot;oval&quot;</code>：设置shape为椭圆形</li>
<li><code>android:shape=&quot;ring&quot;</code>：设置shape为环形</li>
</ol>
</shape></li>
<li><code>corners子节点</code>：设置圆角效果<ol start="7">
<li><code>android:radius</code>：圆角的半径</li>
</ol>
</li>
<li><code>gradient子节点</code>：背景渐变色<ol start="9">
<li><code>android:startColor</code>：渐变起始色</li>
<li><code>android:endColor</code>：渐变结束色</li>
<li><code>android:centerColor</code>:渐变过程中中间的颜色</li>
<li><code>android:angle</code>:渐变的角度朝向(45的倍数)，默认朝向为从左至右，每增加45度，则逆时针转动45度开始渐变</li>
<li><code>android:gradientRadius</code>:这个属性还不知道是什么意思</li>
</ol>
</li>
<li><code>padding子节点</code>：边距，该标签的几个属性就比较常用比较简单了，就不描述了</li>
<li><code>size子节点</code>：大小，这个标签的属性也比较简单</li>
<li><code>solid子节点</code>：背景填充色<ol start="17">
<li><code>android:color</code>:背景颜色，设置该标签属性之后，gradient标签将不会起作用</li>
</ol>
</li>
<li><code>stroke子节点</code>：线（可以设置控件的边框，也可以设置一条实线或虚线）<ol start="19">
<li><code>android:color</code>：线的颜色</li>
<li><code>android:width</code>：线的宽度</li>
<li><code>android:dashGap</code>：虚线间的间距</li>
<li><code>android:dashWidth</code>：每个虚线段的长度（当设置为虚线的时候，最好不要设置android:width属性）</li>
</ol>
</li>
</ol>
<p>一般比较常用的是边线，填充色，背景色这三个标签</p>
<p>如果要为某个控件设置背景边框、渐变色、填充色或者是通过View设置控件间的分割线，都可以使用shape配合selector来进行实现</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
            <tag> Shape </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈JSONP跨域请求]]></title>
      <url>http://ittiger.cn/talk-jsonp-cross-domain-request.html</url>
      <content type="html"><![CDATA[<p>第一次听说JSONP跨域请求还是去年刚入职实习的时候，也借那个机会在网上好好了解了下用法，但是对于其如何实现还是不太明白。昨天一同事问我当时对JSONP的使用情况，突然发现一年多没用，对于这个跨域请求技术又忘的差不多了，刚好不知道这个星期该写篇什么方面的文章，那就趁这个机会再把JSONP琢磨琢磨顺便把过程记录下来，免得下次不记得了又得到网上到处找资源查阅。</p>
<p>OK，进入正题！！！！</p>
<p>先看JSONP定义</p>
<p><code>JSONP(JSON with Padding)</code>是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 <code>server1.example.com</code>的网页无法与不是 <code>server1.example.com</code>的服务器沟通，而 HTML 的<code>&lt;script&gt;</code> 元素是一个例外。利用 <code>&lt;script&gt;</code> 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。<br>JSONP它是一个非官方的协议，它允许在服务器端集成Script tags返回至客户端，通过javascript callback的形式实现跨域访问（这仅仅是JSONP简单的实现形式）。<br>——来自百度</p>
<p>同源策略</p>
<p>同源策略是一种约定，也是浏览器本身最核心最基本的一个安全功能。<br>所谓同源是指协议、域名、端口相同，也就是说同源策略不允许一个站点的某个文档或脚本加载请求另一个站点的文档或脚本，具体看下如下实验：</p>
<a id="more"></a>
<p>我新建一个站点作为本地站点，端口号为8080，如下：<br><img src="/img/2016072811.png" alt><br>再建一个站点作为远程站点，端口号为8085，如下：<br><img src="/img/2016072812.png" alt><br>我在本地站点中添加两个按钮，一个请求远程站点文档，一个请求本地站点文档，我们来看看效果如何<br>请求代码如下：<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//请求远程站点文档</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remoteBtnClick</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    $.<span class="hljs-keyword">get</span>("http://localhost:8085/Remote/jslib/jquery-1.7.2.js",</span><br><span class="line">            function(data)&#123;</span><br><span class="line">                <span class="hljs-built_in">console</span>.log(data);</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//请求本地站点文档</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">localBtnClick</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    $.<span class="hljs-keyword">get</span>("http://localhost:8080/Local/jslib/jquery-1.7.2.js",</span><br><span class="line">            function(data)&#123;</span><br><span class="line">                <span class="hljs-built_in">console</span>.log(data);</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请求响应结果如下：<br><img src="/img/2016072813.png" alt><br>正如前面说的，根据同源策略浏览器不允许本地站点直接通过Http请求读取另外一个远程站点的资源信息。</p>
<p>看到这，相信大家很快会想到一种情况———引入外部js类库<code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&quot;&gt;&lt;/script&gt;</code>比如这个引入百度地图JS类库的代码，很明显，这个地图JS类库和我们自己的站点明显不是在同一个域内，对于这种情况我也写一个测试程序验证一下。<br>我在本地站点8080的页面中添加这样一行代码<code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:8085/Remote/jslib/remote.js&quot;&gt;&lt;/script&gt;</code>以希望在本地页面加载的时候同时加载远程站点8085里的remote.js文件，remote.js文件中的内容如下：<br><img src="/img/2016072814.png" alt><br>运行代码之后的效果图如下：<br><img src="/img/2016072815.png" alt><br>很显然，通过这种方式是完全可以读取远程站点的文档信息的，也就是说像这种src属性的加载方式是不受同源策略所约束可以访问任何站点的文档信息，另外像大家用的很多的图片加载标签，也经常通过其src属性加载网络图片。</p>
<p>实现基本的跨域请求</p>
<p>看了上面的例子和JSONP的定义相信大家已经明白了JSONP跨域请求的基本原理，利用script的这种加载方式我们就可以实现跨域请求。</p>
<p>我在本地站点中动态构造一个script标签，然后将其src的url指向远程站点的文档，最后将这个script标签添加到页面dom中，先写个例子看这种方式能不能行得通。<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//远程站点8085上remote.js中的内容依然和上面一样，不做任何改变</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remoteBtnClick</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="hljs-string">"&lt;script&gt;&lt;//script&gt;"</span>).attr(<span class="hljs-string">"src"</span>, <span class="hljs-string">"http://localhost:8085/Remote/jslib/remote.js"</span>).appendTo(<span class="hljs-string">"body"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行之后的结果和上面直接通过<code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost:8085/Remote/jslib/remote.js&quot;&gt;&lt;/script&gt;</code>加载的效果是一样，这里就不继续贴图，因为原理是一样，很显然结果必然相同，而且也没必要动态写这么麻烦，直接加载岂不是更直接。</p>
<p>接着我们来另外一个情况，既然JSONP定义中说了JSONP拿到的是JSON数据，那我们将远程站点请求文件remote.js换成一个JSON数据文件<code>remote.json({&quot;data&quot;:&quot;来自远程站点的数据&quot;,&quot;time&quot;:&quot;2014-12-20&quot;})</code>再试试。<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remoteBtnClick</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="hljs-string">"&lt;script&gt;&lt;//script&gt;"</span>).attr(<span class="hljs-string">"src"</span>, <span class="hljs-string">"http://localhost:8085/Remote/remote.json"</span>).appendTo(<span class="hljs-string">"body"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>图1：<br><img src="/img/2016072816.png" alt>   </p>
<p>图2：<br><img src="/img/2016072817.png" alt></p>
<p>看图1中的请求响应结果，很明显，这个json数据已经从远程站点请求成功并且拿到了本地站点下。通过图2我们发现这里有个javascript的语法错误，因为我们是通过javascript标签的方式加载的，而这个标签是将文档加载完成后会立即把其当做js执行，而这个json数据很明显不是一个合法的js语句。既然这样，那我们就想办法让这个json数据变成一个合法的js语句，最简单的方法就是将这个json数据当做一个函数的参数给塞进去，例如：<code>callbackHandler({&quot;data&quot;:&quot;来自远程站点的数据&quot;,&quot;time&quot;:&quot;2014-12-20&quot;})</code>，如果本地站点中有一个callbackHandler函数，那么远程站点返回的这个数据就是一个合法的js函数，很显然这个时候单纯的通过js客户端来验证这个例子是无法实现的，因为在远程站点8085中无论是json文件还是js文件中都无法直接构造<code>callbackHandler({&quot;data&quot;:&quot;来自远程站点的数据&quot;,&quot;time&quot;:&quot;2014-12-20&quot;})</code>这么一段代码(语法不正确)给本地站点8080去远程调用。<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callbackHandler</span>(<span class="hljs-params">json</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(json)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个时候就需要远程站点的服务端进行配合，由于远程站点后端服务不知道本地客户端的回调函数名是callbackHandler，所以，我们需要在远程调用的时候告诉服务端本地的回调函数名是callbackHandler，此时的本地站点8080上的请求方式则换这样：<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="hljs-string">"&lt;script&gt;&lt;//script&gt;"</span>).attr(<span class="hljs-string">"src"</span>, <span class="hljs-string">"http://localhost:8085/Remote/JSONPServlet?callback=callbackHandler"</span>).appendTo(<span class="hljs-string">"body"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callbackHandler</span>(<span class="hljs-params">data</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>远程站点8085上服务端代码如下：   </p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="hljs-function">        <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String callback = request.getParameter(<span class="hljs-string">"callback"</span>);</span><br><span class="line">    response.setContentType(<span class="hljs-string">"text/html"</span>);</span><br><span class="line">    PrintWriter out = response.getWriter();</span><br><span class="line">    out.println(callback + <span class="hljs-string">"(&#123;'data':'The data from remote','time':'2014-12-20'&#125;)"</span>);</span><br><span class="line">    out.flush();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务端通过参数解析知道本地站点客户端的回调函数名是callbackHandler，远程服务端构造一段<code>callbackHandler({&quot;data&quot;:&quot;The data from remote&quot;,&quot;time&quot;:&quot;2014-12-20&quot;})</code>返回即可，这样在script标签加载完成后会直接将取得的json数据当做参数传入该回调函数中执行，这样整个跨域请求(请求服务端)就完成了。JSONP的跨域请求差不多就这样实现了，但是<br>运行效果如下：<br><img src="/img/2016072818.png" alt><br>运行结果正如我们所想，通过script方式加载远程服务返回<code>javascript tags</code>可以顺利实现跨域访问，这里我也继续试验下直接通过ajax方式访问远程后端服务，将<code>remoteBtnClick()</code>实现改为如下方式：<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="hljs-keyword">get</span>("http://localhost:8085/Remote/JSONPServlet?callback=callbackHandler",</span><br><span class="line">            function(data)&#123;</span><br><span class="line">                <span class="hljs-built_in">console</span>.log(data);</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请求结果如下：<br><img src="/img/2016072819.png" alt><br>显然，请求的结果和前面的请求远程站点客户端文档信息是一样，因为同源策略而无法访问。</p>
<p>OK，JSONP的实现方式和相关验证基本上就爱完成了，现在也知道了JSONP的实现原理和实现方式，但是上面这种实现方式有点麻烦，既要自己添加script标签，同时还要自己定义一个回调函数，感觉略显麻烦，其实jQuery中已经直接提供类似的JSONP请求方式，我们只需要按照其定义好调用方式即可进行Http的跨域请求。现在我将<code>remoteBtnClick()</code>实现方式修改为如下，远程服务端代码不修改：<br><figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remoteBtnClick</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="line">     $.ajax(&#123;</span><br><span class="line">            url: <span class="hljs-string">'http://localhost:8085/Remote/JSONPServlet'</span>,</span><br><span class="line">            dataType: <span class="hljs-string">"jsonp"</span>,</span><br><span class="line">            jsonp: <span class="hljs-string">"callback"</span>,</span><br><span class="line">            jsonpCallback: <span class="hljs-string">"callbackHandler"</span>,</span><br><span class="line">            success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;</span><br><span class="line">                <span class="hljs-built_in">console</span>.log(data);</span><br><span class="line">                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"success"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//客户端回调</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callbackHandler</span>(<span class="hljs-params">json</span>) </span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(json);</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"callbackHandler"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请求结果如下：<br><img src="/img/2016072820.png" alt></p>
<p>可以看到，现在直接通过ajax请求远程站点服务也成功实现了跨域请求，这个是jQuery自己已经帮我们封装好的功能。对于ajax请求中的几个参数我简单说描述下作用：</p>
<ol>
<li><code>dataType:’jsonp’</code>，这个是代表当前Http请求为jsonp的请求方式；</li>
<li><code>jsonp：’callback’</code>,这个代表的是远程服务端接收客户端回调函数名的参数名，即：<code>String callback = request.getParameter(&quot;callback&quot;)</code>这个参数，ajax请求中jsonp参数的默认值就是callback，这个也可以自己随便更换；</li>
<li><code>jsonpCallback:’callbackHandler’</code>,这个代表远程服务调用结束后的本地回调函数名，比如上面的代码中的那个客户端回调函数名，这个jsonpCallback的参数值也是可以自己随便定义的，也可以不给这个jsonpCallback参数，其实jQuery会自动为我们生成一个函数和函数名，从上面的结果图中我们可以看到，远程服务调用成功后，既执行了SUCCESS这个回调函数，也执行我们自己定义的callbackHandler这个回调函数，所以我们完全可以使用jQuery给我们生成的回调函数，在调用结束后在SUCCESS回调中做相应的处理即可，如下是不加该参数的调用方式：<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">        url: <span class="hljs-string">'http://localhost:8085/Remote/JSONPServlet'</span>,</span><br><span class="line">        dataType: <span class="hljs-string">"jsonp"</span>,</span><br><span class="line">        jsonp: <span class="hljs-string">"callback"</span>,</span><br><span class="line">        success: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;</span><br><span class="line">            <span class="hljs-built_in">console</span>.log(data);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="/img/2016072821.png" alt></p>
<p>上面结果图中的圈中部分就是jQuery为我们自动生成的回调函数名。</p>
<p>OK，JSONP的实现方式及实现原理基本上介绍演示完了，至于jQuery中对于JSONP的实现封装方式等我有时间研究下了再继续吧<del>~</del><del>~</del></p>
<p>write by laohu<br>2015年3月20日</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> JavaScript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> JSONP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Lucene近实时搜索应用总结]]></title>
      <url>http://ittiger.cn/lucene-search-in-action.html</url>
      <content type="html"><![CDATA[<p>最近因工作需要，用到了Lucene，在需求中，需要对生成的索引文件不断的更新、新增、删除等操作，同时还要实时的看到索引改动后的数据，在使用过程中碰到了Lucene里几个比较常见的问题，特来总结记录下。</p>
<p>我使用的是Lucene4.3，本来是想使用最高的版本Lucene4.9的(不知道现在又有么有新的版本出现)，但是因为公司项目的JDK都是JDK6的，而Lucene4.9的支持的最低JDK版本是7+的，所以最后选择了这个版本。第一次碰这个东东，也是在网上搜罗各种资料，当然官网是少不了的，还有一个网址，这个里面的版本更全面，包含了Lucene所有的版本，有需要的可以去下载自己想要的版本。</p>
<p>OK，进入正题。</p>
<ol>
<li><p>在读取索引文件内容时，索引文件的打开操作 <code>new IndexSearcher(DirectoryReader.open(FSDirectory.open(new File(indexPath))))</code> 是个非常耗时耗资源的操作，所以在搜索索引数据时把<code>IndexSearcher</code>对象给缓存起来可以提高搜索性能，这个地方可以将索引目录对应的<code>IndexSearcher</code>对象做成一个单例模式进行获取。</p>
</li>
<li><p>在问题1的操作基础上，我对索引进行了更新操作，紧接着我就发现了一个问题，索引更新后我查询出来的结果和我更新后的结果对不上号。再网上查了半天没找到原因，后来在一个群里请教之后，才知道更新完索引之后，索引文件需要重新打开，否则搜索得到的还是原来索引的数据，Lucene里面的这个原理非常重要。</p>
</li>
<li><p>因为当时对<code>Lucene</code>了解的不是很多，所以为了每次更新后能搜索到正确的数据，我的做法是每次更新完索引就将我之前缓存的<code>IndexSearcher</code>对象和<code>Reader</code>对象给移除掉，下次搜索时重新打开索引，这样来保证搜索结果的正确性。</p>
</li>
</ol>
<a id="more"></a>
<p>索引的更新代码大致如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//获取索引的写对象</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IndexWriter <span class="hljs-title">getIndexWriter</span><span class="hljs-params">(String indexPath)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Directory dir = FSDirectory.open(<span class="hljs-keyword">new</span> File(indexPath));</span><br><span class="line">      <span class="hljs-keyword">if</span>(IndexWriter.isLocked(dir)) &#123;</span><br><span class="line">          IndexWriter.unlock(dir);</span><br><span class="line">      &#125;</span><br><span class="line">      IndexWriterConfig iwriterConfig = <span class="hljs-keyword">new</span> IndexWriterConfig(Version.LUCENE_43, <span class="hljs-keyword">new</span> ComplexAnalyzer());</span><br><span class="line">      IndexWriter indexWriter=<span class="hljs-keyword">new</span> IndexWriter(dir, iwriterConfig);</span><br><span class="line">     <span class="hljs-keyword">return</span> indexWriter;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-comment">//索引更新操作，索引中的更新逻辑是将旧的文档删除，再将新的文档新增进去</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateLucene</span><span class="hljs-params">(String indexPath，要更新的数据参数)</span> </span>&#123;</span><br><span class="line">      IndexSearcher indexSearcher = getIndexSearcher(indexPath);</span><br><span class="line">      Document oldDoc = ....<span class="hljs-comment">//根据IndexSearcher查询得到被更新的旧文档--1处</span></span><br><span class="line">      Document newDoc = ....<span class="hljs-comment">//根据旧文档和要更新的具体数据得到要更新的新文档</span></span><br><span class="line">      indexWriter.updateDocument(doc);<span class="hljs-comment">//更新操作--3处</span></span><br><span class="line">      removeReader(indexPath);<span class="hljs-comment">//移除IndexSearcher缓存对象--2处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li>问题3中的这个跟新操作写完之后实际应用的时候，出了好几个问题，都是Lucene里面比较常见，容易犯错的问题。<br>异常1：org.apache.lucene.store.AlreadyClosedException: this IndexReader is closed<br>经过分析之后发现是因为多并发情况下时，同一个索引文件对应的Reader对象别多个线程持有，在我这个代码里存在线程1刚好执行完2处代码将Reader缓存清理掉(同时关掉了该Reader对象)，而刚好，线程2在执行代码1处的查询操作，这个时候就会出现这个异常。在我这个代码里的更新操作总共分3部，首先查询出旧的文档，紧接着构造新文档并执行更新操作，第三步是移除缓存，所以这三步应该归结为一个原子操作，所以我很自然的就想到了同步锁synchronized，在该方法上添加Class级的同步锁，由于我的代码里有多个这种更新索引的方法，所以每个方法都加一个同步锁，后来证明这种方式也不行仍然出现了该异常，具体代码的问题出在哪我现在真记不起来了，而且这种多个静态方法都加Class级的同步锁性能注定不怎么样，后续的解决办法下面问题中继续说。<br>异常2：LockObtainFailedException<br>经过查询资料知道这是因为在IndexWriter的构造函数在试图获取另外一个IndexWriter已经加锁的索引目录时抛出的错误，这是因为在Lucene中只能允许一个线程去进行写操作，当该线程获取到这个写对象后，会在索引目录中生成一个write.lock文件，所以在这个线程没有释放该索引目录的锁对象前，其他线程无法获取该目录的写对象，根据这个write.lock文件，我们可以很方便的判断当前索引目录有没有被写对象占用，改造后的代码如下： <figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> Object synchronized_w = <span class="hljs-keyword">new</span> Object();</span><br><span class="line">      <span class="hljs-function"><span class="hljs-keyword">private</span> IndexWriter <span class="hljs-title">getIndexWriter</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">          <span class="hljs-keyword">synchronized</span> (synchronized_w) &#123;</span><br><span class="line">              <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                  Directory dir = <span class="hljs-keyword">null</span>;</span><br><span class="line">                  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;</span><br><span class="line">                      dir = FSDirectory.open(<span class="hljs-keyword">new</span> File(indexPath));</span><br><span class="line">                      <span class="hljs-keyword">if</span>(!IndexWriter.isLocked(dir)) &#123;</span><br><span class="line">                          <span class="hljs-keyword">if</span>(indexWriter == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                              indexWriter = <span class="hljs-keyword">new</span> IndexWriter(dir, <span class="hljs-keyword">new</span> IndexWriterConfig(Version.LUCENE_43, LuceneManager.getAnalyzer()));</span><br><span class="line">                          &#125;</span><br><span class="line">                          <span class="hljs-keyword">break</span>;</span><br><span class="line">                      &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                          <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                              dir.close();</span><br><span class="line">                              Thread.sleep(<span class="hljs-number">100</span>);</span><br><span class="line">                              Thread.yield();</span><br><span class="line">                          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                              logger.error(<span class="hljs-string">"获取索引"</span> + indexPath + <span class="hljs-string">"写对象IndexWriter失败"</span>, e);</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  logger.error(<span class="hljs-string">"获取索引"</span> + indexPath + <span class="hljs-string">"写对象IndexWriter失败"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="hljs-keyword">return</span> indexWriter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>获取索引写对象的代码经过如此改造之后，成功运行，没有出现问题。</p>
<ol start="5">
<li>继续问题4中的第一个异常，分析之后觉得问题出现的最终原因还是在第三步移除缓存时关闭Reader对象这里，所以如果Lucene能不需要手动关闭Reader对象就可以解决这个问题，带着这个问题我重新去查看了Lucene4.3的API文档，看了之后发现了两个个比较重要的API，DirectoryReader.openIfChanged(dirReader)和DirectoryReader.isCurrent()，前者是个静态方法，可以判断当前Reader对象的索引有没有被修改过，如果索引文件被更新过则重新加载该索引目录，但是这个时候的重新加载则比单纯的open(indexPath)要高效很多，它只是重新加载被更新过的文档，而单纯的open则是加载全部的文档，重新加载后我们查询的时候就可以查询到最新的数据结果了。而第二个API是个实例方法，用来判断当前Reader对象所代表的索引文件是不是最开始那个，即判断当前索引文件有没有被更新过，有更新则返回false，否则返回true，则两个API结合在一起刚好可以解决我之前的Reader关闭问题。有了这种重新加载机制，我就不需要每次更新索引之后清除缓存关掉旧的Reader对象并打开新的对象。改造的代码如下： <figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> IndexSearcher <span class="hljs-title">getIndexSearcher</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">          <span class="hljs-keyword">synchronized</span> (lock_r) &#123;</span><br><span class="line">              <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                  <span class="hljs-keyword">if</span>(indexSearcher == <span class="hljs-keyword">null</span> &amp;&amp; dirReader == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                      dirReader = DirectoryReader.open(FSDirectory.open(<span class="hljs-keyword">new</span> File(indexPath)));</span><br><span class="line">                      indexSearcher = <span class="hljs-keyword">new</span> IndexSearcher(dirReader);</span><br><span class="line">                  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(indexSearcher != <span class="hljs-keyword">null</span> &amp;&amp; dirReader != <span class="hljs-keyword">null</span> &amp;&amp; !dirReader.isCurrent()) &#123;</span><br><span class="line">                      <span class="hljs-comment">//判断有没有更新过，有更新则重新加载更新过的文档</span></span><br><span class="line">                      DirectoryReader newDirReader = DirectoryReader.openIfChanged(dirReader);</span><br><span class="line">                      indexSearcher = <span class="hljs-keyword">new</span> IndexSearcher(newDirReader);</span><br><span class="line">                      dirReader = newDirReader;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                  logger.error(<span class="hljs-string">"获取索引"</span> + indexPath + <span class="hljs-string">"搜索对象IndexSearcher失败"</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="hljs-keyword">return</span> indexSearcher;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这个代码里面有个问题就是旧的Reader对象没有关闭掉，如果加上这reader.close()这句话又会出现那个异常，不加的话运行没有问题，但是我总觉得不关掉不太好，感觉占着资源。然后继续查看API文档，发现了SearcherManager这个类，这个是Lucene里面提供的工具类，主要是用来了管理IndexSearcher对象的，仔细阅读了该类的说明及其源代码后觉得用这个工具类更靠谱，所以最后毫不犹豫的重新写了一个IndexSearcher对象的获取方式，代码如下：<br>        <figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> IndexSearcher <span class="hljs-title">getIndexSearcher</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    IndexSearcher indexSearcher = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (synchronized_r) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(searcherManager == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            searcherManager = <span class="hljs-keyword">new</span> SearcherManager(FSDirectory.open(<span class="hljs-keyword">new</span> File(indexPath)), <span class="hljs-keyword">new</span> SearcherFactory());</span><br><span class="line">        &#125;</span><br><span class="line">        searcherManager.maybeRefresh();<span class="hljs-comment">//这个方法同DirectoryReader.openIfChanged(dirReader)效果一样，其实底层还是调用的该方法实现的</span></span><br><span class="line">        indexSearcher = searcherManager.acquire();<span class="hljs-comment">//借用一个IndexSearcher对象的引用，记住该对象用完之后要归还的，有借有还再借不难</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> indexSearcher;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeIndexSearcher</span><span class="hljs-params">(IndexSearcher indexSearcher)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(indexSearcher != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        searcherManager.release(indexSearcher);<span class="hljs-comment">//归还从SearcherManager处借来的IndexSearcher对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    indexSearcher = <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如此实现之后，就不需要我们自己管理这个旧的Reader对象，而是交由Lucene本身自己去进行管理，而且此种实现方式更简洁明了，也完美解决了我的问题。</p>
<p>实现了索引更新后的数据的读取实时性就可以实现一个简单的实时搜索功能。</p>
<p>最后为了保证项目中Lucene使用的稳定性，我对索引文件的更新和查询都添加了读写锁ReentrantReadWriteLock来进行控制，更新的时候添加写锁，查询的时候添加读锁，这样更加的保证了Lucene使用的安全性。</p>
<hr>
<p>简单介绍下读写锁ReentrantReadWriteLock的机制(多线程并发的时候很有用)：</p>
<ol>
<li>在某个线程获取到读锁时，其他线程不能获取写锁，但是可以获取读锁</li>
<li>在某个线程获取到写锁时，其他线程既不能获取写锁也不能获取读锁</li>
<li>给个示例代码：<pre><code><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> ReentrantReadWriteLock  w_lock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<span class="hljs-comment">//读写锁</span></span><br><span class="line">   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateDocument</span><span class="hljs-params">(Term term, Document doc)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">           w_lock.writeLock().lock();<span class="hljs-comment">//获得写锁</span></span><br><span class="line">           getIndexWriter();</span><br><span class="line">           indexWriter.updateDocument(term, doc);</span><br><span class="line">           indexWriter.commit();</span><br><span class="line">       &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(e);</span><br><span class="line">       &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">           closeIndexWriter();</span><br><span class="line">           w_lock.writeLock().unlock();释放写锁</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre></li>
</ol>
<p>OK，到这里我的问题基本上就写完了，有时间再去研究研究Lucene的其他的特性。</p>
<hr>
<p>write by laohu<br>2014年12月11日19:12:55</p>
<hr>
<p>原创文章，转载请出处注明。   </p>
<p>下面是我的个人公众号，欢迎关注交流<br><img src="/img/qrcode/weixinGzhQrcode.jpg" width="200" height="200" alt></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
